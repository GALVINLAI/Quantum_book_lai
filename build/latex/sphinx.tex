%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{第一章 背景知识}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{xeCJK}
\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]{STSong}
\setCJKsansfont[BoldFont=STHeiti]{STXihei}
\setCJKmonofont{STFangsong}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\parindent 2em
\definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}
\setcounter{tocdepth}{3}
\renewcommand\familydefault{\ttdefault}
\renewcommand\CJKfamilydefault{\CJKrmdefault}


\title{量子计算与编程入门}
\date{Apr 30, 2024}
\release{1.0.0}
\author{Original Quantum}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{前言}
\label{\detokenize{index:id2}}
\sphinxAtStartPar
  自量子计算研究受到广泛关注的几十年来，国内出版了一些量子计算相关的书籍，但内容较为单薄，涵盖内容并不全面，与当前量子计算行业真实的技术发展状况尚有一段距离，并不能给目标读者带来较高的阅读与学习价值。

\sphinxAtStartPar
  在量子计算研究进入发展快车道之际，集聚力量，重新编写出一套体系完整、内容全面、能够为新时期量子计算人才培养服务的专业教材，无论是从当前还是从未来来看，都是一件具有积极意义的工作。

\sphinxAtStartPar
  作为本源量子教材编写出版计划的第一册教材，书中对于量子计算的背景知识、量子计算数学基础、量子计算机硬件系统、量子算法与编程、量子计算前沿话题等都进行了清晰介绍。

\sphinxAtStartPar
  第一部分背景知识章节主要介绍了量子计算的发展现状以及量子力学的发展历史，通过了解量子计算的基本概念和量子计算软件，对量子计算入门起到导引作用。

\sphinxAtStartPar
  第二部分量子计算基础部分，从量子系统、观测量和计算基下的测量、复合系统与联合测量等量子计算基础理论的讲解，逐步带你进入量子计算世界。本章还介绍了量子逻辑门、量子线路、量子计算的if和while等内容。

\sphinxAtStartPar
  第三部分量子计算机硬件基础板块，主要解析本源量子基于量子计算研发的各种硬件产品。学完本章你将了解量子计算信号传输的重要性、量子计算控制系统的不可或缺性及量子计算芯片的基本情况。

\sphinxAtStartPar
  第四部分量子算法与编程深入介绍了量子算法的基础知识及运用。内容涵盖量子算法简介、量子—经典混合算法、几种主流的量子算法及本源自主研发的量子语言QRunes和量子编程软件QPanda2。

\sphinxAtStartPar
  第五部分介绍了量子计算的前沿话题，包括利用QPanda测试量子系统噪声、量子机器学习与量子神经网络、使用单振幅和部分振幅量子虚拟机、将量子程序编译到不同的量子芯片上等行业前沿知识。

\sphinxAtStartPar
  在附录中，编者收录了学习量子计算所需的基础数学内容和本源量子编程工具的安装与配置方法，期望为读者们学习量子计算与编程提供更多参考。

\sphinxAtStartPar
  尽管量子计算时代何时真正开始，还存在着所有类似叠加的不确定性，但必须承认，量子计算技术产生的成果正越来越多地应用到我们的生活之中。

\sphinxAtStartPar
  本源联合创始人郭光灿院士说：“要成为科学强国不是一代人的事，必须要有传承，这离不开量子信息人才的教育和培养。”希望本套教材的问世，能为量子计算教育事业的发展，为量子计算人才的培养，作出应有的贡献。

\sphinxAtStartPar
  著者

\sphinxAtStartPar
  2019年8月

\sphinxstepscope


\section{1.1 三问量子计算}
\label{\detokenize{rst/1.1_u4e09_u95ee_u91cf_u5b50_u8ba1_u7b97:id1}}\label{\detokenize{rst/1.1_u4e09_u95ee_u91cf_u5b50_u8ba1_u7b97::doc}}

\subsection{1.1.1 什么是量子计算}
\label{\detokenize{rst/1.1_u4e09_u95ee_u91cf_u5b50_u8ba1_u7b97:id2}}
\sphinxAtStartPar
  量子计算是一种遵循量子力学规律调控量子信息单元进行计算的新型计算模式。在理解量子计算的概念时，通常将它和经典计算相比较。
如图1.1.1，经典计算使用2进制的数字电子方式进行运算，而二进制总是处于0或1的确定状态。量子计算和现有的计算模式完全不同，它借助量子力学的叠加特性，能够实现计算状态的叠加，它不仅包含0和1，还包含0和1同时存在的叠加态（Superposition）。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.1}.png}\hspace*{\fill}}

\begin{center}图1.1.1 经典计算与量子计算的区别
\end{center}
\sphinxAtStartPar
  普通计算机中的2位寄存器在某一时间仅能存储4个二进制数（00、01、10、11）中的一个，而量子计算机中的2位量子位（qubit）寄存器可同时存储这四种状态的叠加状态。
随着量子比特数目的递增，对于n个量子比特而言，量子信息可以处于2种可能状态的叠加，配合量子力学演化的并行性，可以展现比传统计算机更快的处理速度；加上量子纠缠（Entanglement）等特性，理论上，量子计算机相较于当前使用最强算法的经典计算机，在一些具体问题上，有更快的处理速度和更强的处理能力。


\subsection{1.1.2 为什么我们需要量子计算}
\label{\detokenize{rst/1.1_u4e09_u95ee_u91cf_u5b50_u8ba1_u7b97:id3}}
\sphinxAtStartPar
  根据摩尔定律，集成电路上可容纳的晶体管数目每隔约18\sphinxhyphen{}24个月增加一倍，性能也相应增加一倍。例如当前智能手机的CPU芯片，业内已经能够达到5nm的工艺节点，但是随着芯片元件集成度的不断提高，芯片内部单位体积内散热也相应增加，再由于现有材料散热速度有限，就会因“热耗效应”产生计算上限；
另一方面，元器件尺寸的不断缩小，在纳米甚至更小尺度下经典计算世界的物理规律将不再适用，产生“尺寸效应”。受到来自这两个方面的阻碍，再加之信息化社会的计算数据每日都在海量剧增，人类必须另觅他途，寻找新的计算方式，而量子计算可能是一个答案。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.2}.png}\hspace*{\fill}}

\begin{center}图1.1.2 寻找新的计算方式
\end{center}
\sphinxAtStartPar
  量子计算的基本思想是利用量子力学的规则和思想来处理问题和信息，遵循这样的思维导向可以轻易了解到量子计算的优势所在。
在传统的计算机中，每当输入对应数量的信息，电脑即会相应地输出对应的数据；而如今将量子力学应用在计算机硬件设备中并且输入信息，就不仅是有序提供一些输入和读出数据那么简单，利用量子叠加态定律可实现一键式处理多个输入的强并行性；与传统的程序相比，这是一个指数级的加速和飞跃。除了理论意义上的计算速度的增长，量子计算还具有在不同领域发挥作用的现实可能性。

\sphinxAtStartPar
\sphinxstylestrong{大数据检索}

\sphinxAtStartPar
  在当前的大数据和人工智能时代，量子计算可以解决海量的数据检索问题、以及当前令人束手无策的物流优化问题，实现成本节省和减少碳排放等。在海量信息充斥和庞杂的时代，强大的数据分析和梳理工具无疑对人们的生活和工作有着很大帮助。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.3}.png}\hspace*{\fill}}

\begin{center}图1.1.3 大数据检索
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子模拟}

\sphinxAtStartPar
  在量子模拟方面，特别是生化制药中，量子模拟有望利用相应的量子算法在更长的时间范围内准确地进行分子模拟，从而实现当前技术水平无法做到的精确建模，这有助于加速寻找能够挽救生命的新型药物，并显著地缩短药物的开发周期。在这方面的一个领域特别有希望，模拟化学刺激对大量亚原子粒子的影响，称为量子化学。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.4}.png}\hspace*{\fill}}

\begin{center}图1.1.4 量子化学
\end{center}
\sphinxAtStartPar
  量子计算机可以帮助加快对比不同药物对一系列疾病的相互作用和影响的过程，来确定最佳药物。此外，量子计算还可以带来真正的个性化医疗，利用基因组学的先进技术为每个病人量身定制治疗计划；基因组测序产生了大量的数据，整条DNA链的表达需要强大的计算能力和存储容量。一些公司正在迅速降低人类基因组测序所需的成本和资源。从理论上来说，量子计算机将使基因组测序更加高效，更容易在全球范围内扩展。

\sphinxAtStartPar
  利用量子计算机，还能够分析全世界范围内的DNA 数据模式，以便在更深层次上了解基因组成，并有可能发现以前未知的疾病模式。

\sphinxAtStartPar
\sphinxstylestrong{金融服务}

\sphinxAtStartPar
  金融分析师工作中通常依赖由市场和投资组合表现的概率和假设组成的算法。量子计算可以帮助消除数据盲点，防止毫无根据的金融假设造成损失。

\sphinxAtStartPar
  具体来说，量子计算影响金融服务行业的方式是解决复杂的优化问题，如投资组合风险优化和欺诈检测。量子计算可以更好地确定有吸引力的投资组合，因为有成千上万的资产具有相互关联的依赖性，并且可以更有效地识别关键的欺诈模式。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.5}.png}\hspace*{\fill}}

\begin{center}图1.1.5 金融服务
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{人工智能}

\sphinxAtStartPar
  在人工智能方面，量子计算能有效提高机器学习的深度和速度，突破人工智能发展的瓶颈。量子机器学习可以帮助人工智能以类似人类的方式，更有效地执行复杂的任务，例如，使人形机器人能够在不可预知的情况下实时做出优化决策。在量子计算机上训练人工智能可以提高计算机视觉识别、模式识别、语音识别、机器翻译等性能。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.6}.png}\hspace*{\fill}}

\begin{center}图1.1.6 人工智能
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{现代农业}

\sphinxAtStartPar
  量子计算机可以更有效地制造肥料。几乎所有的肥料都是由氨制成，提高生产氨(或替代物)的能力则意味着更便宜、更低能耗的肥料；高质量的肥料将有利于环境，并有助于养活地球上不断增长的人口；但由于催化剂组合数量是无限的，所以在改进制造或替代氨的工艺方面进展甚微。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.7}.png}\hspace*{\fill}}

\begin{center}图1.1.7 现代农业
\end{center}
\sphinxAtStartPar
  从本质上讲，如果没有1900年代被称为Haber\sphinxhyphen{}Bosch Process的工业技术，则无法人工模拟这一过程， 因为它需要极高的热量和压力将氮、氢和铁转化成氨。如果用今天的超级计算机进行数字化测试，找出合适的催化剂组合来制造氨，那么则需要几个世纪的时间；但是，量子计算机能够快速分析化学催化过程，并提出最佳的催化剂组合来产生氨。

\sphinxAtStartPar
\sphinxstylestrong{云计算}

\sphinxAtStartPar
  量子云计算正在成为富有前景的领域。量子云平台可以简化编程，并提供对量子计算机的低成本访问。IBM、谷歌和阿里巴巴在内的大公司均在部署量子云计算项目，本源量子的云平台早在2017年就已上线，不断迭代更新的强大功能为量子编程和量子计算提供了全新的视角和可能性。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.8}.png}\hspace*{\fill}}

\begin{center}图1.1.8 量子云计算
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{网络安全}

\sphinxAtStartPar
  量子计算机可以用来破解保护敏感数据和电子通信安全的密码，同时，量子计算机也可以用来保护数据免受量子黑客攻击，这需要一种被称为量子加密的技术。量子加密是一种将纠缠光子(entangled photons)通过量子密钥分配(QKD)进行远距离传输的想法，目的是保护敏感的通信；最重要的一点是，如果量子加密通信被人截获，加密方案将立即显示中断迹象，并显示通信不安全。这依赖于测量量子系统的行为会破坏系统的原理，被称之为“测量效应”。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.9}.png}\hspace*{\fill}}

\begin{center}图1.1.9 量子加密
\end{center}
\sphinxAtStartPar
  随着量子计算资源成本的下降以及量子基础知识的普及，更多的相关行业者将会出现，量子计算将会在各个行业中有越来越多的应用，特别是在那些传统计算机效率低下的领域，量子计算机的作用将会愈发明显。


\subsection{1.1.3 什么样的研究机构参与量子计算的研发}
\label{\detokenize{rst/1.1_u4e09_u95ee_u91cf_u5b50_u8ba1_u7b97:id4}}
\sphinxAtStartPar
  近年来，世界各个科技强国都高度重视量子计算研究，纷纷发布自己的量子信息科技战略，企图抢占下一轮科技发展的制高点，争取早日实现“量子霸权”。其中，D\sphinxhyphen{}Wave、谷歌、Rigetti Computing、1Qbit、IBM等都是研发量子计算的世界领军机构。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.10}.png}\hspace*{\fill}}

\begin{center}图1.1.10 量子计算的研发机构
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{D\sphinxhyphen{}Wave}

\sphinxAtStartPar
  D\sphinxhyphen{}Wave Systems，总部位于加拿大，致力于量子计算机的研发和探索。于2011年5月11日正式发布了全球第一款商用型量子计算机“D\sphinxhyphen{}Wave One”。该机器采用了128\sphinxhyphen{}qubit（量子比特）的处理器，理论运算速度已经远远超越现有任何超级电子计算机，不过严格来说，这还算不上真正意义的通用量子计算机，只是借助一些量子力学方法解决特殊问题的机器。通用任务方面还远不是传统硅处理器的对手，而且编程方面也需要重新学习，此外，为尽可能降低qubit的能级，需要利用低温超导状态下的铌产生qubit，D\sphinxhyphen{}Wave 的工作温度需保持在绝对零度附近（20 mK）。

\sphinxAtStartPar
  2017年1月，D\sphinxhyphen{}Wave公司推出D\sphinxhyphen{}Wave 2000Q，其声称该系统由2000个qubit构成，可以用于求解最优化、网络安全、机器学习和采样等问题。对于测试一些基准问题，如最优化问题和基于机器学习的采样问题，D\sphinxhyphen{}Wave 2000Q胜过当前高度专业化的算法1000到10000倍。

\sphinxAtStartPar
\sphinxstylestrong{谷歌}

\sphinxAtStartPar
  全球最大的搜索引擎公司也在量子计算方面有所涉足和进展。2016年，谷歌与加州大学合作布局超导量子计算，报道了9位超导量子比特的高精度操控，并购买了初创企业D\sphinxhyphen{}Wave公司的量子退火机，探索人工智能领域。

\sphinxAtStartPar
\sphinxstylestrong{微软}

\sphinxAtStartPar
  微软在2018年宣布，争取在五年内造出第一台拥有100个拓扑量子比特的量子计算机，并且将其整合到Azure云业务当中。

\sphinxAtStartPar
  微软的量子技术采用“拓扑量子比特（Topological qubit）”进行计算，而不是普通的“逻辑量子比特（logical qubit）”。拓扑量子比特通过基本粒子的拓扑位置和拓扑运动来处理信息，无论外界如何干扰基本粒子的运动路径，从拓扑角度来看，只要它还是连续变化，两个对换位置的基本粒子都是完全等价的；也即是说，用拓扑量子比特进行计算，对于外界的干扰有极强的容错能力，这样一来基于拓扑量子比特的计算机就可以把规模做得很大，能力做得很强。

\sphinxAtStartPar
\sphinxstylestrong{英特尔}

\sphinxAtStartPar
  在CES 2018（国际消费类电子产品展览会），英特尔正式展示了49量子比特的超导量子计算芯片，这块49量子比特的量子计算芯片大小与消费级x86 CPU相当。与传统计算芯片一样，量子计算芯片在计算单元数量增加、密度增大的情况下，会产生一定的干扰。而现阶段量子计算对于内部、外部干扰极其敏感，以致于只能在超低温超导条件下运行。英特尔将49量子比特芯片做到这种密度和大小，具有里程碑式的意义。

\sphinxAtStartPar
\sphinxstylestrong{IBM}

\sphinxAtStartPar
  IBM在CES 2019正式亮相了Q System One，将其宣传为”世界上为商用和科研打造的首个全面集成化的通用量子计算系统”，拥有20个量子位的计算力。IBM 表示，它的主要成就是将一个实验性的量子计算机在可靠性（和外观）上与大型量子计算机更接近。量子计算需要极其精细的环境，量子芯片需要保持在绝对零度，并且受到的电波动或物理振动干扰要尽可能最小。IBM 表示，Q System One 可以最大限度地减少这些问题。

\sphinxAtStartPar
\sphinxstylestrong{阿里巴巴}

\sphinxAtStartPar
  2015年，阿里巴巴与中科院联合成立了量子计算机实验室，主攻量子计算机难题。

\sphinxAtStartPar
  2018年5月8日，阿里巴巴宣布已经研制出世界上运算最快的量子电路模拟器“太章”，并已成功模拟了81（9x9）比特40层基准的谷歌随机量子电路。

\sphinxAtStartPar
  对于阿里巴巴的核心业务在线购物平台而言，量子计算机处理电商平台的搜索、购买、交易等海量数据的效率将提高数十倍。阿里早已布局云计算领域，目前阿里的云计算已经服务全球超18个国家与地区，在阿里巴巴2018财年（从2017年4月1日至2018年3月31日），云计算业务收入已到133.90亿元。量子计算机的出现将会极大地提高阿里云计算的能力，并能够更加高效精准的利用大数据。

\sphinxAtStartPar
\sphinxstylestrong{百度}

\sphinxAtStartPar
  2018年3月8日上午，百度宣布成立量子计算研究所，开展量子计算软件和信息技术应用业务研究。百度全力推动“百度量子、量子百度”的研究规划，计划五年时间里组建世界一流的量子计算研究所，并在之后的五年将量子计算逐渐融入百度的业务中来。

\sphinxAtStartPar
\sphinxstylestrong{本源量子}

\sphinxAtStartPar
  2017年9月11日，本源量子计算科技有限责任公司成立。作为国内首家以量子计算为主营业务的新势力公司，以量子芯片、量子测控、量子软件、量子云、量子计算机以及未来的量子人工智能等为核心业务，目前已研制出量子比特处理器玄微XW B2\sphinxhyphen{}100、量子测控一体机OriginQ Quantum AIO，并且上线了本源量子计算云平台、发布了完全自主的高级量子编程语言QRunes、量子编程软件开发工具QPanda等产品。通过与中国科学院量子信息重点实验室的强强联合，本源量子的未来发展不可限量。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.1.11}.png}\hspace*{\fill}}

\begin{center}图1.1.11 本源量子
\end{center}
\sphinxstepscope


\section{1.2 量子计算的发展历史}
\label{\detokenize{rst/1.2_u91cf_u5b50_u8ba1_u7b97_u7684_u53d1_u5c55_u5386_u53f2:id1}}\label{\detokenize{rst/1.2_u91cf_u5b50_u8ba1_u7b97_u7684_u53d1_u5c55_u5386_u53f2::doc}}

\subsection{1.2.1 量子力学的发展}
\label{\detokenize{rst/1.2_u91cf_u5b50_u8ba1_u7b97_u7684_u53d1_u5c55_u5386_u53f2:id2}}
\sphinxAtStartPar
  理想黑体可以吸收所有照射到它表面的电磁辐射，并将这些辐射转化为热辐射，其光谱特征仅与该黑体的温度有关，与黑体的材质无关，黑体也是理想的发射体。1859年，古斯塔夫·基尔霍夫(GustavKirchhoff) 证明了黑体辐射发射能量 \(E\) 只取决于温度 \(T\) 和频率 \(v\) ，即 \(E = J ( T,v )\) ，然而这个公式中的函数 \(J\) 却成为了一个物理挑战。 \(^{[1]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps12}.jpg}\hspace*{\fill}}

\begin{center}图1.2.1 古斯塔夫·基尔霍夫
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.2.2}.jpg}\hspace*{\fill}}

\begin{center}图1.2.2 黑体辐射（classical theory\sphinxhyphen{}经典理论，wavelength\sphinxhyphen{}波长，spectral radiance\sphinxhyphen{}光谱辐射）
\end{center}
\sphinxAtStartPar
  1879年，约瑟夫·斯特凡(Josef Stefan)通过实验提出，热物体释放的总能量与温度的四次方成正比。1884年，路德维希·玻尔兹曼(Ludwig Boltzmann)对黑体辐射得出了同样的结论，由于这一结论基于热力学和麦克斯韦电磁理论的理论，后被称为斯特凡\sphinxhyphen{}玻尔兹曼（Stefan\sphinxhyphen{}Boltzmann）定律。 \(^{[1]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps14}.jpg}\hspace*{\fill}}

\begin{center}图1.2.3 约瑟夫·斯特凡
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps15}.jpg}\hspace*{\fill}}

\begin{center}图1.2.4 路德维希·玻尔兹曼
\end{center}
\sphinxAtStartPar
  1896年，德国物理学家威廉·维恩（Wilhelm Wien）提出了基尔霍夫挑战的解决方案。尽管他的解决方案与实验观察结果非常接近，但是这个公式只有在短波（高频）、温度较低时才与实验结果相符，在长波区域完全不适用。 \(^{[1]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps16}.jpg}\hspace*{\fill}}

\begin{center}图1.2.5 威廉·维恩
\end{center}
\sphinxAtStartPar
  1900年，为了解决威廉·维恩提出的维恩近似公式在长波范围内偏差较大的问题，普朗克（Max Planck）应用玻尔兹曼（Boltzmann）的将连续能量分为单元的技术，提出固定单元大小使指正比于振动频率，这样可以导出精确的黑体辐射光谱，量子化的概念就此诞生。 \(^{[1]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps17}.jpg}\hspace*{\fill}}

\begin{center}图1.2.6 普朗克
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps18}.png}\hspace*{\fill}}

\begin{center}图1.2.7 量子化
\end{center}
\sphinxAtStartPar
  1901年，里奇和列维\sphinxhyphen{}西维塔（Levi\sphinxhyphen{}Civita,Tullio）出版了《绝对微分学》（Absolute differential calculus）。1869年，克里斯托费尔(Christoffel)发现了“协变微分”，这让里奇将张量分析理论扩展到 \(n\) 维黎曼空间。里奇和列维\sphinxhyphen{}西维塔（Levi\sphinxhyphen{}Civita,Tullio）的定义被认为是张量最一般的形式，这项工作并不是用量子理论来完成的，但正如经常发生的那样，体现物理理论所必需的数学恰好在正确的时刻出现了。 \(^{[1]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps19}.jpg}\hspace*{\fill}}

\begin{center}图1.2.8 里奇和列维\sphinxhyphen{}西维塔
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps20}.jpg}\hspace*{\fill}}

\begin{center}图1.2.9 克里斯托费尔
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps21}.jpg}\hspace*{\fill}}

\begin{center}图1.2.10 张量分析
\end{center}
\sphinxAtStartPar
  1905年，爱因斯坦（ Einstein）研究了光电效应（photoelectric effect）。光电效应是在光的作用下，某些金属或半导体释放出电子。但是光的电磁理论给出的结果与实验证据不符，为此爱因斯坦提出了光量子理论来解决这个难题。到1906年，爱因斯坦已经正确地推测出，能量的变化发生在量子材料振荡器的跳跃变化中，跳跃变化是 \(h{v}\) 的倍数，其中 \(h\) 普朗克常数， \(v\) 是频率。 \(^{[2]}\)
\begin{equation*}
\begin{split}E = hv\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps25}.png}\hspace*{\fill}}

\begin{center}图1.2.11 爱因斯坦
\end{center}
\sphinxAtStartPar
  1913年，尼尔斯·波尔（Niels Henrik David Bohr）发表了一篇关于氢原子的革命性论文，他发现了光谱线的主要规律。阿瑟·康普顿（Arthur Compton）在1923年从静止的电子行为导出了光子(光量子)散射的相对论运动学。 \(^{[2]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps26}.jpg}\hspace*{\fill}}

\begin{center}图1.2.12 尼尔斯·波尔
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps27}.jpg}\hspace*{\fill}}

\begin{center}图1.2.13 阿瑟·康普顿
\end{center}
\sphinxAtStartPar
  1924年玻色（SatyendraNath Bose）发表了一篇基础论文，为光子提出了不同的状态，他还提出光子的数量没有守恒的概念。玻色假设这时不考虑粒子的统计独立性，将粒子放入多个单元中，只需要谈论单元的统计独立性，时间证明，玻色的这些做法都是正确的。 \(^{[2]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps28}.jpg}\hspace*{\fill}}

\begin{center}图1.2.14 玻色
\end{center}
\sphinxAtStartPar
  1924年11月，德布罗意（Duc de Broglie）写出了一篇题为《量子理论的研究》的博士论文。文中运用了两个最亮眼的公式： \(E=hv\) 和 \(E=m c^{2}\) 。这都是爱因斯坦最著名的关系式，前者对光子能量而言，后者对实物粒子能量而言。德布罗意（Duc de Broglie）把两个公式综合再作出假设，他认为光量子的静止质量不为零，而像电子等一类实物粒子则具有频率的周期过程，所以在论文中他得出一个石破天惊的结论——任何实物微粒都伴随着一种波动，这种波称为相位波，后人也称之为物质波或德布罗意波。 \(^{[3,4]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps31}.jpg}\hspace*{\fill}}

\begin{center}图1.2.15 德布罗意
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps32}.jpg}\hspace*{\fill}}

\begin{center}图1.2.16 德布罗意波
\end{center}
\sphinxAtStartPar
  1926年薛定谔（Schrödinger）发表了一篇论文，给出了氢原子的方程式，并宣告了波动力学的诞生，同时引入了与每个动力学变量相关的算符。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps33}.jpg}\hspace*{\fill}}

\begin{center}图1.2.17 薛定谔
\end{center}
\sphinxAtStartPar
  继德布罗意（Duc de Broglie）之后，从另一个方面对微观物理理论作出根本性突破的是直接受到玻尔（David Bohr）影响的23岁的海森堡（Heisenberg）。1924年他前往哥本哈根研究量子论，1925年发表了一篇有历史意义的论文《对于一些运动学和力学关系的量子论的重新解释》。 \(^{[3]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps34}.jpg}\hspace*{\fill}}

\begin{center}图1.2.18 海森堡
\end{center}
\sphinxAtStartPar
  海森堡（Heisenberg）认为他当时是受了爱因斯坦建立狭义相对论时否定牛顿绝对时间概念的启发。他抛弃了玻尔的电子轨道概念及其有关的古典运动学的量，取而代之以可观察到的辐射频率和强度的这些光学量，同时把玻尔的对应原理加以扩充，使它不是用来猜测量子论某一特殊问题的解，而是用来猜测新力学理论的数学方案。这套新的数学方案，在当时一般物理学家看来是非常陌生的，海森堡（Heisenberg）的老师玻恩（Bonn）发现，海森堡（Heisenberg）创造的这套数学就是矩阵论，是数学家在70多年前就已创造出了的，它是普通数的一种推广。它的最奇特的特征是：“两个矩阵的相乘是不可对易的，即 \(pq \neq qp\) ”。为了进一步搞清楚海森堡论文所揭示的数学问题，玻恩找约尔丹合作。当年9月他们写了一篇长论文，用数学的矩阵方法，把海森堡的思想发展成为量子力学的系统理论。这就是矩阵力学，也通称为量子力学。 \(^{[3]}\)

\sphinxAtStartPar
  1925年7月，海森堡应邀到剑桥讲学，在卡文迪许（Cavendish）实验室作了一系列报告，最后介绍了他的量子力学新思想；但这些新思想当时并未引起狄拉克注意。8～9月间，狄拉克从他的导师福勒处读到海森堡第一篇量子力学论文的校样，开始时他不感兴趣，觉得太烦琐了，把它搁在一边；十来天后再去仔细读一下，”突然认识到，它对我们所关切的困难，提供了全部解决的线索”，可是狄拉克不满足于海森堡的表达方式，试图使它同19世纪发展起来的古典力学的推广形式相适应。 \(^{[3]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps35}.png}\hspace*{\fill}}

\begin{center}图1.2.19 狄拉克
\end{center}
\sphinxAtStartPar
  1925年11月7日他完成论文《量子力学的基本方程》，使用了一种比矩阵更为方便和普适的数学工具——法国数学物理学家泊松于1809年为研究行星运动而创造的“泊松括号”。它是古典力学中最有力的分析工具之一，能用极其简单的形式把古典力学的基本方程表示出来，狄拉克借助这种工具，应用对应原理，轻而易举地把古典方程改造成为量子力学方程。两个月后，他发布了第二篇论文，用他的方法来处理氢原子；在这篇论文中，他把量子力学变数称为“ \(q\) 数”，而把古典物理学的变数称为“ \(c\) 数”， \(c\) 数是可对易的； \(q\) 数则不可对易，也不能比较大小。但为了得到可以同实验相比较的结果，必须设法用  \(c\) 数来表示  \(q\) 数。不久，他又发表题为《量子代数学》的论文，使量子力学成为一个概念上自主的和逻辑上一致的（即自洽的）理论体系。 \(^{[3]}\)

\sphinxAtStartPar
  就在海森堡的量子力学新思想通过玻恩和狄拉克的工作得到重大进展的时候，德布罗意的物质波理论也通过薛定谔的工作而取得辉煌成就。爱因斯坦1925年2月发表的关于量子统计理论的论文引起了薛定谔对德布罗意思想的极大兴趣，当年12月他写了一篇题为《关于爱因斯坦的气体理论》的论文中讲到：“按照德布罗意—爱因斯坦运动粒子的波动理论，粒子不过是波动背景上的一种‘波峰’而已。”当时他试图把德布罗意波推广到束缚粒子上，得到一个巧妙的解。他随即把这方法用于氢原子中的电子，并且充分考虑到电子运动的相对论性力学，但结果同实验不一致，他很失望，断定他的方法不好，于是束之高阁。事实上，薛定谔最初的相对论性波动方程是正确的，不过它所描述的是没有自旋的粒子，而电子的自旋刚于1925年11月发现，对它的意义还不很了解。 \(^{[3]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps36}.jpg}\hspace*{\fill}}

\begin{center}图1.2.20 粒子自旋
\end{center}
\sphinxAtStartPar
  薛定谔受到挫折后不久，放弃了相对论的考虑，重新用他原来的方法来处理氢原子的电子问题，结果同实验非常接近，受到这一结果的鼓舞，1926年他一连发表了6篇论文，从1月到6月的4篇都用一个题目：《作为本征值问题的量子化》。这些论文大大发展了德布罗意的物质波思想，加深了对微观客体的波粒二象性的理解，为数学上解决原子物理学、核物理学、固体物理学和分子物理学问题提供了一种方便而适用的基础，波动力学就这样诞生了。 \(^{[3]}\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.2.21}.png}\hspace*{\fill}}

\begin{center}图1.2.21 单个光量子的示意图
\end{center}
\sphinxAtStartPar
  现在，在同一微观领域中，出现了两种同样有效但形式上完全不同的物理理论。一方面是海森堡的矩阵力学，它在数学运算中所碰到的是不可对易的量和以前罕见的计算规则，并且蔑视任何图象解释，它是一种代数方法，从所观察到光谱线的分立性着手，强调不连续性，尽管它弃绝空间和时间中的古典描述，但是从根本上说来，它的基本概念还是粒子；另一方面是薛定谔的波动力学，它所依据的则是人们所熟悉的微分方程这种数学工具，它类似于古典的流体力学，并且提供了一种容易形象化的表示，它是一种分析方法，从推广古典的运动定律着手，强调连续性，而且它的基本概念是波动。 \(^{[3]}\)

\sphinxAtStartPar
  1926年3月，薛定谔发现，波动力学和矩阵力学在数学上是完全等价的，同时，泡利等人也独立地发现了这种等价性。由于这两种理论所研究的对象是一样的，所得到的结果又是完全一致的，只不过着眼点和处理方法各不相同，因此，这两种理论就通称为量子力学，薛定谔波动方程通常作为量子力学的基本方程，这个方程在微观物理学中的地位就像牛顿运动定律在古典物理学中的地位一样。 \(^{[3]}\)


\subsection{1.2.2 量子计算的发展}
\label{\detokenize{rst/1.2_u91cf_u5b50_u8ba1_u7b97_u7684_u53d1_u5c55_u5386_u53f2:id3}}
\sphinxAtStartPar
  类似经典计算之于宏观物理的关系，量子计算同样也与微观物理有着千丝万缕的联系。

\sphinxAtStartPar
  在微观物理中，量子力学衍生了量子信息科学。量子信息科学是以量子力学为基础，把量子系统“状态”所带的物理信息， 进行信息编码、计算和传输的全新技术。 在量子信息科学中，量子比特（qubit）是其信息载体，对应经典信息里的0和1，量子比特两个可能的状态一般表示为 \(|0\rangle\) 和 \(|1\rangle\)  。在二位复向量空间中， \(|0\rangle\) 和  \(|1\rangle\) 作为单位向量构成了这个向量空间的一组标准正交基，量子比特的状态是用一个叠加态表示的，如 \(| \varphi\rangle = a |0 \rangle + b|1 \rangle\) ，其中 \(a^{2}+b^{2}=1\) ，而且测量结果为 \(|0 \rangle\) 态的概率是 \(a^{2}\) ，得到 \(|1 \rangle\) 态的概率是  \(b^{2}\)  。这说明一个量子比特能够处于既不是 \(|0 \rangle\) 又不是 \(|1 \rangle\) 的状态上，而是处于和的一个线性组合的所谓中间状态之上。 经典信息可表示为 \(0110010110 \ldots\) , 而量子信息可表示为 \(|\varphi\rangle_{1}|\varphi\rangle_{2}|\varphi\rangle_{3}|\varphi\rangle_{4}|\varphi\rangle_{5} \ldots\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps54}.png}\hspace*{\fill}}

\begin{center}图1.2.22 量子纠缠示意图
\end{center}
\sphinxAtStartPar
  一个经典的二进制存储器只能存一个数：要么存 0，要么存 1；但一个二进制量子存储器却可以同时存储0和1这两个数。两个经典二进制存储器只能存储以下四个数中的一个数: 00，01，10 或 11，倘若使用两个二进制量子存储器，则以上四个数可以同时被存储下来。按此规律，推广到N个二进制存储器的情况，理论上，n个量子存储器与n个经典存储器分别能够存 \(2^n\) 个数和1个数。

\sphinxAtStartPar
  由此可见，量子存储器的存储能力是呈指数增长的，它与经典存储器相比，具有更强大的存储数据的能力，尤其是当 n 很大时(如 n=250 )，量子存储器能够存储的数据量比宇宙中所有原子的数目还要多。 \(^{[5]}\) 量子信息技术内容广泛，由于它是量子力学与信息科学形成的一个交叉学科，所以它有很多分支，最主要的两支为量子通信和量子计算。量子通信主要研究的是量子介质的信息传递功能进行通信的一种技术，而量子计算则主要研究量子计算机和适合于量子计算机的量子算法。由于这个量子计算分支具有巨大的潜在应用价值和重大的科学意义，获得了世界各国的广泛关注和研究。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps56}.png}\hspace*{\fill}}

\begin{center}图1.2.23 量子信息科学
\end{center}
\sphinxAtStartPar
  对于量子计算的真正发展，业界普遍认为源自20世纪最具丰富多彩的科学家，诺贝尔奖获得者Richard Feynman在1982年一次公开演讲中提出的两个问题：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps57}.jpg}\hspace*{\fill}}

\begin{center}图1.2.24 理查德·费曼
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{（1）经典计算机是否能够有效地模拟量子系统？}

\sphinxAtStartPar
  虽然在量子理论中，仍用微分方程来描述量子系统的演化，但变量的数目却远远多于经典物理系统。所以Richard Feynman针对这个问题的结论是：不可能，因为目前没有任何可行的方法，可以求解出这么多变量的微分方程。

\sphinxAtStartPar
\sphinxstylestrong{（2）如果放弃经典的图灵机模型，是否可以做得更好？}

\sphinxAtStartPar
  Richard Feynman提出如果拓展一下计算机的工作方式，不使用逻辑门来建造计算机，而是一些其他的东西，比如分子和原子；如果使用这些量子材料，它们具有非常奇异的性质，尤其是波粒二象性，是否能建造出模拟量子系统的计算机？于是他提出了这个问题并做了一些验证性实验，然后他推测，这个想法也许可以实现。由此，基于量子力学的新型计算机的研究被提上了科学发展的历程。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.2.25}.png}\hspace*{\fill}}

\begin{center}图1.2.25 量子计算机发展历程
\end{center}
\sphinxAtStartPar
  此后，计算机科学家们一直在努力攻克这一艰巨挑战。伴随时代发展的趋势，在20世纪90年代，量子计算机的算法发展得到了巨大的进步：

\sphinxAtStartPar
  1992年Deutsch和Jozsa提出了D\sphinxhyphen{}J量子算法，开启了如今量子计算飞速发展的大幕。

\sphinxAtStartPar
  1994年Peter Shor提出了Shor算法，这一算法在大数分解方面比目前已知的最有效的经典质因数分解算法快得多，因此对RSA加密极具威胁性，该算法带来巨大影响力的同时也进一步坚定了科学家们发展量子计算机的决心。

\sphinxAtStartPar
  1996年Lov Grover提出了Grover量子搜索算法，该算法被公认为继Shor算法后的第二大算法。

\sphinxAtStartPar
  1998年Bernhard Omer提出量子计算编程语言，拉开了量子计算机可编程的帷幕。

\sphinxAtStartPar
  2009年MIT三位科学家联合开发了一种求解线性系统的HHL量子算法。众所周知，线性系统是很多科学家和工程领域的核心，由于HHL算法在特定条件下实现了相较于经典算法有指数加速效果，这是未来能够在机器学习，人工智能科技得以突破的关键性技术。

\sphinxAtStartPar
  自2010年以后，在量子计算软硬件方面各大研究公司均有不同程度的突破。

\sphinxAtStartPar
  2013年加拿大D\sphinxhyphen{}Wave系统公司发布了512Q的量子计算设备。

\sphinxAtStartPar
  2016年，IBM发布了6量子比特的可编程量子计算机。

\sphinxAtStartPar
  2017年本源量子发布了32位量子计算虚拟系统，同时还建立了以32位量子计算虚拟系统为基础的本源量子计算云平台。

\sphinxAtStartPar
  2018年初Intel和Google分别测试了49位和72位量子芯片。

\sphinxAtStartPar
  2018年12月6日，本源量子发布了第一款测控一体机Origin Quantum AIO，不仅提高了综合量子测控能力，更节约了量子测控环节各种大型设备的空间，为量子计算行业的高精尖仪器带来了更多的可能。

\sphinxAtStartPar
  2019年1月，IBM发布了世界上第一台独立的量子计算机IBM Q System One。

\sphinxAtStartPar
\sphinxstylestrong{参考文献}

\sphinxAtStartPar
{[}1{]} 引自卧卧网络平台，同济量子力学，量子力学发展史（1）.2019.3.14

\sphinxAtStartPar
{[}2{]} 引自卧卧网络平台，同济量子力学，量子力学发展史（2），2019.3.18

\sphinxAtStartPar
{[}3{]} 引自卧卧网络平台，同济量子力学，量子计算发展史（4），2019.3.22

\sphinxAtStartPar
{[}4{]} 引自卧卧网络平台，同济量子力学，量子计算发展史（3），2019.3.21

\sphinxAtStartPar
{[}5{]} 郭光灿，张昊，王琴. 量子信息技术发展概况{[}J{]}. 南京邮电大学学报(自然科学版)， 2017， 37(3):1\sphinxhyphen{}14.

\sphinxstepscope


\section{1.3 量子计算软件介绍}
\label{\detokenize{rst/1.3_u91cf_u5b50_u8ba1_u7b97_u8f6f_u4ef6_u4ecb_u7ecd:id1}}\label{\detokenize{rst/1.3_u91cf_u5b50_u8ba1_u7b97_u8f6f_u4ef6_u4ecb_u7ecd::doc}}

\subsection{1.3.1 量子语言}
\label{\detokenize{rst/1.3_u91cf_u5b50_u8ba1_u7b97_u8f6f_u4ef6_u4ecb_u7ecd:id2}}
\sphinxAtStartPar
  由于当前量子计算机的通用体系架构未得到统一，在硬件层面上的技术路线也未最终确定，所以目前还无法确定哪种量子机器指令集相对更科学、更合理。现阶段在量子计算编程领域的研究者们大多从“量子线路图”、“量子计算汇编语言”、“量子计算高级编程语言”的方式入手，不断寻找未来可能最受量子计算机发展欢迎的编程语言。

\sphinxAtStartPar
  自20世纪80年代以来，专业从事物理和计算复杂性研究的学者提出了诸多量子算法，他们多数不具备计算机编程思维，使用图形化的方式表示量子程序、量子算法，在某种程度上来说，曾是最简洁的量子编程语言。直到现在，在量子比特数量较少的前提条件下，量子线路图是大多数从事量子计算的研究者一开始采用的最广泛的形式，目前大多数的量子计算平台（如本源量子计算云平台、IBM Q平台）均支持这一编程方式。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.3.1}.png}\hspace*{\fill}}

\begin{center}图1.3.1 本源量子计算云平台图形量子线路
\end{center}
\sphinxAtStartPar
  随着量子计算技术研究的不断深入，人类能够使用的量子比特数量也逐步增长，在这种情况下，量子线路图的编程方式显然无法适应研究需要了，量子汇编语言应用而生。类似于经典计算语言，量子汇编语言在最基本的层面上是能够被量子计算机直接识别和执行的一种机器指令集，它是量子计算机设计者通过量子计算机的物理结构赋予量子计算机的操作功能。从最早提出的QASM到本源推出的初代量子计算汇编语言QRunes、Rigetti提出的Quil，这些汇编语言基本都属于量子计算汇编语言这个范畴。

\sphinxAtStartPar
  在经典计算世界，高级编程语言分为命令式和函数式两大类，而在量子计算编程领域，同样适用。命令式量子编程语言有可以将经典代码和量子代码组合在同一程序中的 QCL、微软开发的Q\#、适用于量子退火器的QMASM；函数式量子编程语言包括Peter Selinger定义的两种密切相关的量子编程语言QFC 和 QPL、微软研究院StationQ工作的LIQUi|>、Quipper。

\sphinxAtStartPar
  由于每个量子机器必须由经典设备控制，现有的量子编程语言包含经典控制结构，例如循环和条件执行，并允许对经典和量子数据进行操作；量子编程语言有助于使用高级构造表达量子算法。


\subsection{1.3.2 量子软件开发包}
\label{\detokenize{rst/1.3_u91cf_u5b50_u8ba1_u7b97_u8f6f_u4ef6_u4ecb_u7ecd:id3}}
\sphinxAtStartPar
  使用量子语言进行量子编程，是一件顺理成章的事，但是在开发工程师的眼中，用量子语言进行量子编程只是最基础的一种方法，如何最大效率的使用量子语言构建最为便捷或功能足够强大的量子程序是一直追求的目标。

\sphinxAtStartPar
  随着量子语言的不断成熟，量子计算行业中各类量子软件开发包层出不穷，它们提供着各种量子编程工具，诸如各类数据库、代码示例、程序开发的流程和指南，允许开发人员在特定量子平台上创造量子软件应用程序等。

\sphinxAtStartPar
  在量子计算行业，量子软件开发包是指一个提供了创建和操作量子程序的量子计算工具集，以及提供了模拟量子程序的方法包，并且允许开发者使用基于云的量子设备来运行、检验自己所开发的量子计算程序。根据不同的后端处理系统，量子软件开发工具分为两大类：一类是可以访问量子处理器的SDK，一类是基于量子计算模拟器的SDK。前者以苏黎世联邦理工学院开发的ProjectQ、IBM的qiskit、Rigetti的Forest为代表，这类SDK允许开发者在原型量子器件和量子模拟器上运行量子电路；后者的使用范围相对较大，是目前量子计算行业采取的相对普遍的量子软件开发包后端处理形式，采用量子模拟器制作的量子软件开发包的好处是——它们不需要跟量子芯片产生直接的物理关联，用户在自己的电脑上通过SDK模拟量子计算芯片的物理功能，执行量子计算过程，获得量子计算模拟成果，并可利用量子虚拟机、模拟器的程序优点，模拟量子算法，同时可在通用量子计算机问世之后快速对接使用。微软的Q\#开发套件、Google的Criq以及本源的QPanda均属于量子软件开发工具。


\subsection{1.3.3 量子云平台}
\label{\detokenize{rst/1.3_u91cf_u5b50_u8ba1_u7b97_u8f6f_u4ef6_u4ecb_u7ecd:id4}}
\sphinxAtStartPar
  自1982年Richard Feynman提出建造量子计算机的设想以来，近半个世纪的时间里人类一直在坚持不懈地实现这一目标。2000年以后，虽然世界各国在量子计算机的硬件研发方面不断取得进步，但是由于量子态非常“挑剔”——它们需要在非常低的温度下储存，否则可能会受到干扰和破坏。

\sphinxAtStartPar
  就目前的技术和工艺，还远远达不到像经典计算机那样在常温下批量制造、运行，这就间接限制了量子计算机的现实应用。在这样的背景下，越来越多的量子计算公司、研究机构发布了各自的量子计算云平台，已知的包括IBM的Quantum Experience、Rigetti的 Forest、本源量子计算云平台等，主要的目的是在量子计算领域占得先机。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.3.2}.png}\hspace*{\fill}}

\begin{center}图1.3.2 本源量子云平台
\end{center}
\sphinxAtStartPar
  量子云平台，全称应该是量子云计算平台；一定程度上可以理解为用户与各家公司、研究机构的量子计算机之间的介质平台；用户通过量子云平台经由调度服务器和互联网向部署在远程的量子计算机提交任务，量子计算机在处理这些任务后再通过调度服务器和互联网将结果返回给用户。这一过程如图1.3.3所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{1.3.3}.png}\hspace*{\fill}}

\begin{center}图1.3.3 量子计算流程图
\end{center}
\sphinxAtStartPar
  个人用户在本地的经典计算机上通过web界面或量子软件编写量子线路、量子代码，然后将编写的内容提交给远程调度服务器，调度服务器安排用户任务按照次序传递给后端量子计算机，量子计算机完成任务后，将计算结果一一返回给调度服务器，调度服务器再将计算结果变成可视化的统计分析发送给用户，至此完成整个量子计算过程。

\sphinxstepscope


\section{2.1 量子力学基础理论}
\label{\detokenize{rst/2.1_u91cf_u5b50_u529b_u5b66_u7406_u8bba_u57fa_u7840:id1}}\label{\detokenize{rst/2.1_u91cf_u5b50_u529b_u5b66_u7406_u8bba_u57fa_u7840::doc}}

\subsection{2.1.1 量子系统}
\label{\detokenize{rst/2.1_u91cf_u5b50_u529b_u5b66_u7406_u8bba_u57fa_u7840:id2}}
\sphinxAtStartPar
  对于一个非物理专业的人而言，量子力学概念晦涩难懂。鉴于此，本章节仅介绍量子力学的一些基础概念加之部分数学的相关知识，甚至不涉及薛定谔方程，就足够开始量子计算机的应用。这如同不需去了解CPU的工作原理以及经典计算机的组成原理，但仍能在日常生活中使用经典计算机或者编写经典程序一样。

\sphinxAtStartPar
  在本章里，彻底抛却数学公式，纯粹去介绍宽泛的概念，目的仅仅想让读者都能了解这个问题——“量子究竟是什么”。

\sphinxAtStartPar
  如果不想被量子的诡异事实所颠覆，并且对于线性代数很有把握的话，那么可以直接过渡到本教材的后面章节开始学习。

\sphinxAtStartPar
\sphinxstylestrong{量子化 Quantization与量子态 Quantum State}

\sphinxAtStartPar
  简而言之，量子态就是一个微观粒子的状态。

\sphinxAtStartPar
  描述一个粒子的状态时，总要找一些能够用来区分微观粒子的属性。如图2.1.1，在宏观世界中，假设一个人在一栋楼中活动，如果他在一层，就称处于”1态”；在二层，就称处于“2态”；在地下一层，就称处于“\sphinxhyphen{}1 态”。微观粒子也有这样的属性，比如它的位置。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps62}.png}\hspace*{\fill}}

\begin{center}图2.1.1 一个人在一栋楼中活动
\end{center}
\sphinxAtStartPar
  但是假设这个人正在上楼梯，进入到一个模糊的状态，这样就不太容易区分到底是在“1态”还是“2态”，此时就需要找一些客观存在的参数去描述这一方面的属性，比如所处的海拔。通常，在日常生活中，这些描述都是连续的，因为这些参数会被分割成更小的部分。

\sphinxAtStartPar
  然而，无限分割下去，直到不得不靠“几个原子”这种单位去描述物体的长度时，量子效应就出场了。薛定谔方程告诉人们，一定会遇到不可分割的最小单位，这种最小单位，统称为量子；这种现象，被称为量子化。这是量子的第一个特性。

\sphinxAtStartPar
  量子化的属性有很多种，但在此优先考虑一种——能量。经过长期探索得知，原子的光谱只会有几个峰值，而不是连续的谱线，这代表了原子内电子的能量只会出现几种情况，电子不可能具有几种情况之外的中间值，这就是能量的量子化。每一种能量，被称之为一个“能级”。

\sphinxAtStartPar
  同样以一栋楼为例，在微观的世界里面，一栋楼的楼梯被拆掉了，这使得微观粒子要么在一楼，要么在二楼，仅存在于整数的楼层，但是，这不代表微观粒子就失去了上下楼的机会。这里就是量子的第二个特性——跃迁。

\sphinxAtStartPar
  当一个原子中的电子获得了来自原子外的能量时，它就有可能克服能级之间能量的差距，跳跃到另外一个态上面，并且这个电子也可以将自己的能量释放出来，跳跃到能量较低的能级上面。当然，能级本身是稳定的，不管怎么跃迁，电子的能量都只能处在这几个能级上，这是原则。

\sphinxAtStartPar
  最后，回顾下什么是量子态呢？你可以想象一下电子处在不同的能级（类似宏观世界的楼层）上面，给这些楼层命名称之  \(|1F\rangle\) ,  \(|2F\rangle\) ,  \(|3F\rangle\) ……，电子处于不同的能级就说明它处在不同的量子态，这样就可以区分出来不同的量子态。如果能想象到此种情形，那就已经明白了什么是量子态了。

\sphinxAtStartPar
\sphinxstylestrong{量子叠加性 Quantum Superposition}

\sphinxAtStartPar
  如果仅仅是把能级建成大楼，然后把大楼的楼梯、电梯全拆掉，（并且不追问原因）这件事情倒也不难理解，然而剩余部分，就无法用普通的现实去想象了。

\sphinxAtStartPar
  量子叠加性是量子的第三个特性。量子理论中，薛定谔的猫的故事是量子叠加性的一个典型示例，故事的末尾告诉我们：猫处于生与死的叠加态。什么是生与死的叠加态？既生又死？实际上，这个故事是关于量子叠加性的一个有争议的思想实验。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps63}.png}\hspace*{\fill}}

\begin{center}图2.1.2 薛定谔的猫实验
\end{center}
\sphinxAtStartPar
  首先，必须接受一个假设，即量子的世界里面，同时存在几个状态是可能的。就像这栋楼里面的每个人，在不去观察他们时，他们同时存在于所有楼层，这就是量子叠加性。

\sphinxAtStartPar
  但或许大家会有疑问，即便在现实生活中，也无法得知一栋大楼里面任何一个人的位置，最多了解他在办公桌上坐着的概率比较大而已，那这样就是量子叠加性吗？很遗憾，并非如此。因为某一时刻，即便无法确定，但这个人肯定存在于这栋楼某一个位置，不可能出现在这栋楼不同的位置，量子叠加不是一种“概率性”存在，事实上，对于量子本身，它就是“同时存在”于很多状态的叠加上。经过无数的实验证明，当物体小到分子、原子、电子那个级别的时候，叠加是客观存在的，尽管无人知道原因。

\sphinxAtStartPar
  那么为什么我们感受不到叠加性呢？如果每个粒子都有这种叠加性，那是不是作为粒子组合的人也应该具有叠加性呢？

\sphinxAtStartPar
  一个宏观物体是由巨大数量的粒子构成的集合体。一个粒子虽然是叠加的，但是一群粒子就能开始体现统计的平均性，就像连续扔一百次硬币，还是有可能出现全部是正面的情况，但是扔一亿次硬币的时候（如果没有做假），那会得到一个趋于稳定的结果——正反面各一半。何况每个人身体里的粒子比一亿还要多几亿倍的几亿倍（差不多有27 ∼ 28位数那么多），所以人是绝无可能有叠加性的。

\sphinxAtStartPar
\sphinxstylestrong{状态的演化 Evolution of State}

\sphinxAtStartPar
  状态的演化是指量子态随时间发生变化。对于一个两能级的量子系统，量子状态的演化类似于地球上的位置随时间变化一样，量子态可以想象成一个单位球面上的点，它随时间演化就同球面上点的位置随时间发生变化类似。

\sphinxAtStartPar
\sphinxstylestrong{测量和坍缩 Measurement And Collapse}

\sphinxAtStartPar
  薛定谔宣称，不打开盒子，猫就处于生和死的“叠加态”，又称：“当我们打开盒子，经过了我们的观察，猫就会坍缩到一个确定的生、死状态上”。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps64}.png}\hspace*{\fill}}

\begin{center}图2.1.3 薛定谔的猫
\end{center}
\sphinxAtStartPar
  什么叫做“观察”之后“坍缩”到确定的状态上？难道不是这个装置而是第一个看到猫的人决定了猫的生死吗？

\sphinxAtStartPar
  这里提出量子的第四个特性：“测量和坍缩假设”。测量和坍缩对量子态的影响仍然是一个争议话题，所以用了“假设”。这个特性的描述如下：
对于一个叠加态而言，可以去测量它，测量的结果一定是这一组量子化之后的、确定的、分立的态中的一个。测量得到任意的态的概率是这个叠加态和测量态的内积的平方，测量之后，叠加态就会坍缩到这个确定的态之上。

\sphinxAtStartPar
  简而言之，如果在一个微观粒子处在1楼和2楼叠加态的话，只能测出来它在1楼或者2楼，这个概率是由它们的叠加权重决定的，但是一旦对这个粒子进行测量，这个粒子的状态就会发生变化，不再是原来那个既在1楼又在2楼的叠加态，而是处在一个确定的状态（1楼或者2楼）。换句话说，测量影响了这个粒子本身的状态。   在上一节中，已经说明了叠加本身是一种客观存在的现象，那么测量、观察这种主观的事情是如何影响到客观叠加的呢？

\sphinxAtStartPar
  比较主流的理论是说因为微观粒子太小，测量仪器本身会对这个粒子产生一定的影响，导致粒子本身发生了变化。但是没有足够的证据证明这种说法。

\sphinxAtStartPar
  回到薛定谔的猫。薛定谔之所以提出这个思想实验，是想让宏观事物——猫，和微观事物——放射性原子，建立“纠缠”，从而把量子力学的诡异现象从微观世界引到现实世界中来。“如果我们承认微观粒子具有这些“叠加“、”坍缩“的性质的话，那猫也具有了”——这是薛定谔的思想。关于这个问题，目前并没有确切的证据证明猫不是处于这样的状态。

\sphinxAtStartPar
  通过形象的描述介绍了量子力学的一些基础概念，下面将用数学的方式将这些概念重新表述一遍。（阅读下面的内容需要一定的数理基础，包括高等数学，线性代数，概率论中的基本概念。）

\sphinxAtStartPar
\sphinxstylestrong{1）态矢 State Vector}

\sphinxAtStartPar
  量子态可用线性代数中的向量来描述，在物理学中，向量常称作矢量。在量子理论中，描述量子态的向量称为态矢，态矢分为左矢和右矢。

\sphinxAtStartPar
  右矢（ket）：
\begin{equation*}
\begin{split}|\psi\rangle=\left[\mathrm{c}{1}, c{2}, \ldots, c_{n}\right]^{T}\end{split}
\end{equation*}
\sphinxAtStartPar
  左矢（bra）：
\begin{equation*}
\begin{split}\langle\psi|=\left[\mathrm{c}{1}^{*}, c{2}^{*}, \ldots, c_{n}^{*}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  采用竖线和尖括号的组合描述一个量子态，其中每一个分量都是复数，右上角标 \(T\) 表示转置。这种形式表示量子态是一个矢量。右矢表示一个 \(n \times 1\) 的列矢量，左矢表示一个 \(1 \times n\) 的行矢量。另外，在讨论同一个问题时，如果左矢和右矢在括号内的描述相同的话，那么这两个矢量互为转置共轭。

\sphinxAtStartPar
\sphinxstylestrong{2）内积和外积}

\sphinxAtStartPar
  对于任意的两个量子态的矩阵（坐标）表示如下：
\begin{equation*}
\begin{split}\begin{aligned} &|\alpha\rangle=\left[a_{1}, a_{2}, \ldots, a_{n}\right]^{T} \\ &|\beta\rangle=\left[b_{1}, b_{2}, \ldots, b_{n}\right]^{T} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
其内积定义为：
\begin{equation*}
\begin{split}\langle\alpha \mid \beta\rangle=\sum_{i=1}^{n} a_{i}^{*} b_{i}\end{split}
\end{equation*}
\sphinxAtStartPar
其外积定义为：
\begin{equation*}
\begin{split}|\alpha\rangle\langle\beta|=\left[a_{i} b^{*}_{j} \right]_{n \times n}\end{split}
\end{equation*}
\sphinxAtStartPar
表示一个 \(n \times n\) 矩阵。

\sphinxAtStartPar
\sphinxstylestrong{两能级系统 Two Level System}

\sphinxAtStartPar
  事物的二元化：0和1、无和有、高和低、开和关、天和地、阴和阳、生和死、产生和消灭。二元化是一种将事物关系简化的哲学，基于二进制的计算理论正是利用了这种哲学思想。

\sphinxAtStartPar
  在谈论量子计算原理前，先了解经典计算机的工作流程。经典计算机就是在不断地处理0、1的二进制数码，它们代表着逻辑电路中的高低电平，对于这些二进制数码的产生、传输、处理、读取，最终反馈到像显示器这种输出设备上的信号，就是一个计算机的工作流程。

\sphinxAtStartPar
  对于微观量子而言，有一个决定粒子性质的最直接参量——能量。粒子的能量只会在几个分立的能级上面取值，限制取值的可能性种类为两种，这就构成了两能级系统。除了某些特殊的情况之外，这两个能级必定能找出来一个较低的，称之为基态(ground state)，记为 \(|\mathrm{g}\rangle\) ；另一个能量较高的，称之为激发态(excited state)，记为  \(|\mathrm{e}\rangle\) 。

\sphinxAtStartPar
  量子计算机里面也由两种状态来构成基本计算单元，只不过这里的两种状态是指量子态的 \(|\mathrm{e}\rangle\) 和  \(|\mathrm{g}\rangle\) ，这就是一个两能级系统的特征。以列矢量的方式将它们记为
\begin{equation*}
\begin{split}|\mathrm{e}\rangle=\left[\begin{array}{l} 1 \\ 0 \end{array}\right],|\mathrm{g}\rangle=\left[\begin{array}{l} 0 \\ 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  行矢量的形式记为
\begin{equation*}
\begin{split}\langle\mathrm{e}|=\left[\begin{array}{ll} 1 & 0 \end{array}\right],\langle\mathrm{g}|=\left[\begin{array}{ll} 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  和经典的比特类比，常将 \(|\mathrm{e}\rangle\) 记做 \(|0\rangle\) ，将 \(|\mathrm{g}\rangle\) 记做，并称 \(|\mathrm{1}\rangle\) 之为量子比特（quantum bits）。

\sphinxAtStartPar
  任意叠加态（superposition）  \(|\psi\rangle\) 可以写作 \(|\mathrm{0}\rangle\) 和 \(|\mathrm{1}\rangle\) 的线性组合
\begin{equation*}
\begin{split}|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  其中复数 \(\alpha\) 和  \(\beta\) 称为振幅（amplitudes），并且满足归一化条件
\begin{equation*}
\begin{split}|\alpha|^{2}+|\beta|^{2}=1\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(|\alpha|\) 表示复数 \(\alpha\) 的模。

\sphinxAtStartPar
\sphinxstylestrong{状态的演化 Evolution of State}

\sphinxAtStartPar
  量子态可以由态矢（或称向量）来表示，量子也可以有不同的状态，并且可以同时处于不同的状态，那么量子态是如何随时间演化呢？如下例：

\sphinxAtStartPar
  假设：封闭的(closed)量子系统的演化（evolution）由酉变换（unitary transformation）来描述。具体地，在 \(t_1\) 时刻系统处于状态 \(|\psi_1 \rangle\) ，经过一个和时间 \(t_1\) 和  \(t_2\) 有关的酉变换  \(U\) ，系统在  \(t_2\) 时刻的状态
\begin{equation*}
\begin{split}\left|\psi_{2}\right\rangle=U\left|\psi_{1}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  这里的酉变换 \(U\) 可以理解为是一个矩阵，并且满足
\begin{equation*}
\begin{split}U U^{\dagger}=I\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(U^{\dagger}\) 表示对矩阵 \(U\) 取转置共轭。根据可逆矩阵的定义可知， \(U\) 也是一个可逆矩阵，因此酉变换也是一个可逆变换。

\sphinxAtStartPar
  而在量子计算中，各种形式的酉矩阵被称作量子门。例如Pauli矩阵也是一组酉矩阵，
\begin{equation*}
\begin{split}\begin{aligned} &\sigma_{0} \equiv I \equiv\left[\begin{array}{ll} 1 & 0 \\ 0 & 1 \end{array}\right] \quad \sigma_{1} \equiv \sigma_{x} \equiv X \equiv\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right] \\ &\sigma_{2} \equiv \sigma_{y} \equiv Y \equiv\left[\begin{array}{cc} 0 & -i \\ i & 0 \end{array}\right] \quad \sigma_{3} \equiv \sigma_{z} \equiv Z \equiv\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  以X门作用在量子态上为例，
\begin{equation*}
\begin{split}\begin{aligned} &X|0\rangle=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \end{array}\right]=\left[\begin{array}{l} 0 \\ 1 \end{array}\right]=|1\rangle \\ &X|1\rangle=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\left[\begin{array}{l} 0 \\ 1 \end{array}\right]=\left[\begin{array}{l} 1 \\ 0 \end{array}\right]=|0\rangle \end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X|\psi\rangle=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\left[\begin{array}{c} \beta \\ \alpha \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  从上述中看出，量子态的演化本质上可以看作是对量子态对应的矩阵做变换，即是做矩阵的乘法。 由于 \(X\) 门和经典逻辑门中的非门类似，有时也常称 \(X\) 门为量子非门（quantum NOT gate）。

\sphinxAtStartPar
\sphinxstylestrong{叠加态和测量 Superposition State And Measurement}

\sphinxAtStartPar
  按照态矢的描述，这两个矢量可以构成一个二维空间的基。任何一个态都可以写为这两个基在复数空间上的线性组合，即
\begin{equation*}
\begin{split}|\psi\rangle=\alpha|0\rangle+\beta e^{i {\theta}}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  其中  \(e^{i \theta}\) 表示模为1幅角为  \(\theta\) 的复数。

\sphinxAtStartPar
  可以定义测量就是将量子态 \(|\psi\rangle\) 投影到另一个态 \(|\alpha\rangle\) 上。获得这个态的概率是它们内积的平方，即
\begin{equation*}
\begin{split}P_{\alpha}=|\langle\psi \mid \alpha\rangle|^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  其它概率下会将量子态投影到它的正交态上去，即
\begin{equation*}
\begin{split}P_{\alpha \perp}=1-P_{\alpha}\end{split}
\end{equation*}
\sphinxAtStartPar
测量之后量子态就坍缩到测量到的态上。

\sphinxAtStartPar
\sphinxstylestrong{相位、纯态和混合态 Phase, Pure State and Mixed State}

\sphinxAtStartPar
  如果将量子态初始化到某一个未知的叠加态上面，能否通过反复的测量得到它的表达式呢？看以下这两种情况：
\begin{equation*}
\begin{split}\begin{aligned} &\left|\psi_{1}\right\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle) \\ &\left|\psi_{2}\right\rangle=\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  发现在 \(|0\rangle\) ， \(|1\rangle\) 的方向上测量，它们的表现都是一半概率为0，一半概率为1，根本不能区分。从这个现象可以知道无法通过概率得到态的相位信息  \(\theta\) ，实际上，量子态的相位是量子相干性的体现。

\sphinxAtStartPar
  另一种情况，假设左手抓着一个袋子，这个袋子里面有无数的量子态，它们全都是  \(\left|\psi_{1}\right\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\) 这种叠加态；另外，有一个机器可以在 \(|0\rangle\) ， \(|1\rangle\) 的方向上测量。

\sphinxAtStartPar
  每次拿出一个态，对它进行测量，不管它是 \(|0\rangle\) ，还是 \(|1\rangle\) ，都扔到右手边的另一个袋子里面，如此反复，这样右边袋子里面的态越来越多了。由于测量结果对于这两种情况是等概率的，所以袋子里面约有一半的态是 \(|0\rangle\) ，另一半是 \(|1\rangle\) 。

\sphinxAtStartPar
  假设从右边的袋子里取出一个，在不知道手上的态是什么情况下，能说它和左边袋子里的态一样都是 \(\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\) 吗？

\sphinxAtStartPar
  答案是不能。右边袋子里的态，实际上是一种经典的概率叠加，和等量的红球白球装在袋子里面一样。这样的态是不具有相位的。它只能表示为
\begin{equation*}
\begin{split}\left\{\left|\psi_{0}\right\rangle=|0\rangle: P_{0}=0.5,\left|\psi_{1}\right\rangle=|1\rangle: P_{1}=0.5\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  这种类似于概率列表的形式。

\sphinxAtStartPar
  所以，定义纯态就是“纯粹的量子态”，它不仅具有概率，还具有相位（也就是量子相干性）。混合态是纯态的概率性叠加，它往往失去了（部分或全部的）相位信息。

\sphinxAtStartPar
\sphinxstylestrong{密度矩阵和布洛赫球 Density Matrix And Bloch Sphere}

\sphinxAtStartPar
  态矢是对纯态的描述，如果要描述一个混合态，就必须写成态集合和概率的列表形式，非常繁琐。因此采用密度矩阵来描述。

\sphinxAtStartPar
  对于一个纯态而言，密度矩阵的形式是：
\begin{equation*}
\begin{split}\rho=|\psi\rangle\langle\psi|\end{split}
\end{equation*}
\sphinxAtStartPar
  而对于一个混合态而言，密度矩阵的形式是：
\begin{equation*}
\begin{split}\rho=\sum_{i} P_{i}\left|\psi_{i}\right\rangle\left\langle\psi_{i}\right|\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(\{P_{i},\left|\psi_{i}\right\rangle\}\) 是系统所处的态及其概率。

\sphinxAtStartPar
  密度矩阵有以下的性质：

\sphinxAtStartPar
  对于一个两能级体系表述的态，不论是纯的还是混合的，都可以用密度矩阵  \(\rho\) 表示
\begin{quote}

\sphinxAtStartPar
\(\rho=\rho^{2}\) 当且仅当量子态是纯态时成立。
\end{quote}

\sphinxAtStartPar
   \(\rho\) 对角线上的分量表示整个系统如果经历一次测量，那么可以得到这个态的概率。如果只去操作和测量一个两能级体系，那么是分辨不出相同的密度矩阵的。

\sphinxAtStartPar
  密度矩阵已经完备地表示了一个两能级系统可能出现的任何状态。为了更加直观地理解量子叠加态与逻辑门的作用，引入布洛赫球的概念，如图2.1.4，它能够方便地表示一个量子比特的任意状态。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.1.4}.png}\hspace*{\fill}}

\begin{center}图2.1.4 布洛赫球
\end{center}
\sphinxAtStartPar
  如果量子态是一个纯态，那么它是球面上的点。点的 \(z\) 坐标衡量了它的  \(|0\rangle\) 和  \(|1\rangle\) 的概率，即
\begin{equation*}
\begin{split}\begin{aligned} &P(0)=\frac{1+z}{2} \\ &P(1)=\frac{1-z}{2} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  最上面表示  \(|0\rangle\) 态，最下面表示 \(|1\rangle\) 态。

\sphinxAtStartPar
  再沿着平行于 \(XY\) 平面的方向，并且穿过这个点的 \(Z\) 坐标，可以得到一个圆，这个圆就象征着相位的复平面；这个点在这个圆上交 \(X\) 轴的角度就是单位复数的幅角。经过这个过程可以将每个纯态都与球面上的点一一对应了起来。

\sphinxAtStartPar
  对于混合态而言，因为根据之前的描述，混合态实际上是多个纯态的经典统计概率的叠加。对于每一个纯态分量，连接球心和球面上的点，可以形成一个矢量。根据概率列表，对所有的纯态矢量进行加权平均，即可得到混合态的矢量，即得到了混合态对应的点。

\sphinxAtStartPar
  混合态是布洛赫球内部的点，根据混合的程度不同，矢量的长度也不同。最大混合态是球心，它意味着这里不存在任何量子叠加性。

\sphinxAtStartPar
  例如 \((1,0,0)\) 和 \((-1,0,0)\) 点在布洛赫球上就是在 \(X\) 方向上的顶点和 \(-X\) 方向上的顶点。它们对应的量子态的概率分布就是 \(Z\) 坐标，即为 \(0\) ​。所以，
\begin{equation*}
\begin{split}P 0(|\psi _{1}\rangle)=P 0(|\psi _{2}\rangle)=0.5\end{split}
\end{equation*}
\sphinxAtStartPar
  沿 \(XY\) 平面横切，得到一个圆，可以看到这两个点对应的幅角是 \(\theta_1 =0\) ， \(\theta_2 = \pi\) ，由此推断出量子态分别为：
\begin{equation*}
\begin{split}\begin{aligned} &\left|\psi_{1}\right\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle) \\ &\left|\psi_{2}\right\rangle=\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  如果将这两个态以 \(1/2\) ,  \(1/2\) 的概率混合，在布洛赫球上面的坐标将表示为 \((0,0,0)\) ，也就是球心。对应到密度矩阵的表述，为：
\begin{equation*}
\begin{split}\rho=\frac{1}{2}|\psi_{1}\rangle\langle\psi_{1} |+\frac{1}{2}|\ \psi_{2}\rangle\langle\psi_{2}| \ =\left[\begin{array}{cc} 0.5 & 0 \\ 0 & 0.5 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  即为最大混合态。


\subsection{2.1.2 观测量和计算基下的测量}
\label{\detokenize{rst/2.1_u91cf_u5b50_u529b_u5b66_u7406_u8bba_u57fa_u7840:id3}}
\sphinxAtStartPar
  量子比特（qubit）不同于经典的比特（bit），一个量子比特 \(|\psi\rangle\) 可以同时处于 \(|0 \rangle\) 和 \(|1 \rangle\) 两个状态，可用线性代数中的线性组合（linear combination）来表示为
\begin{equation*}
\begin{split}|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  在量子力学中常称量子比特 \(|\psi\rangle\) 处于 \(|0\rangle\) 和 \(|1\rangle\) 的叠加态（superpositions），其中α、β都是复数（complex number），两维复向量空间的一组标准正交基（orthonormal basis）组成一 \(|0 \rangle\) 和 \(|1 \rangle\) 组计算基（computational basis）。

\sphinxAtStartPar
  量子比特的信息不能直接获取，而是通过测量来获取量子比特的可观测的信息。可观测量在量子理论中由自伴算子（self\sphinxhyphen{}adjoint operators）来表征，自伴的有时也称Hermitian。量子理论中的可观测量与经典力学中的动力学量，如位置、动量和角动量等对应，而系统的其他特征，如质量或电荷，并不在可观测量的类别之中，它是作为参数被引入到系统的哈密顿量（Hamiltonian）。

\sphinxAtStartPar
  在量子力学中测量（measure）会导致坍塌，即是说测量会影响到原来的量子状态，因此量子状态的全部信息不可能通过一次测量得到。当对量子比特 \(|\psi\rangle\) 进行测量时，仅能得到该量子比特概率 \(|\alpha|^2\) 处在 \(|0 \rangle\) 态，或概率 \(|\beta|^2\) 处在 \(|1 \rangle\) 态。由于所有情况的概率和为 \(1\) ，则有 \(|\alpha|^{2}+|\beta|^{2}=1\) 。

\sphinxAtStartPar
  当对量子进行测量时，会发生什么变化呢？

\sphinxAtStartPar
  假设：量子测量是由测量算子（measurement operators）的集合 \(\{M_{i}\}\) 来描述，这些算子可以作用在待测量系统的状态空间（state space）上。指标（index） \(i\) 表示在实验上可能发生的结果。如果测量前的量子系统处在最新状态 \(|\psi\rangle\) ，那么结果  \(i\) 发生的概率为
\begin{equation*}
\begin{split}p(i)=\left\langle\psi\left|M_{i}^{\dagger} M_{i}\right| \psi\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  并且测量后的系统状态变为
\begin{equation*}
\begin{split}\frac{M_{i}|\psi\rangle}{\sqrt{\left\langle\psi\left|M_{i}^{\dagger} M_{i}\right| \psi\right\rangle}}\end{split}
\end{equation*}
\sphinxAtStartPar
  由于所有可能情况的概率和为 \(1\) ​，即
\begin{equation*}
\begin{split}1=\sum_{i} p(i)=\sum_{i}\left\langle\psi\left|M_{i}^{\dagger} M_{i}\right| \psi\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  因此，测量算子需满足
\begin{equation*}
\begin{split}\sum_{i} M_{i}^{\dagger} M_{i}=I\end{split}
\end{equation*}
\sphinxAtStartPar
  该方程被称为完备性方程（completeness equation）。

\sphinxAtStartPar
  再例如，在计算基下单量子比特的测量。单量子比特在计算基下有两个测量算子，分别是 \(M_{0}=|0\rangle\left\langle 0\left|, M_{1}=\right| 1\right\rangle\langle 1|\) ​。注意到这两个测量算子都是自伴的，即
\begin{equation*}
\begin{split}M_{0}^{\dagger}=M_{0}, M_{1}^{\dagger}=M_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  且
\begin{equation*}
\begin{split}M_{0}^{2}=M_{0}, M_{1}^{2}=M_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  因此
\begin{equation*}
\begin{split}M_{0}^{\dagger} M_{0}+M_{1}^{\dagger} M_{1}=M_{0}+M_{1}=I\end{split}
\end{equation*}
\sphinxAtStartPar
  该测量算子满足完备性方程。

\sphinxAtStartPar
  设系统被测量时的状态是 \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) ，则测量结果为 \(0\) 的概率为
\begin{equation*}
\begin{split}p(0)=\left\langle\psi\left|M_{0}^{\dagger} M_{0}\right| \psi\right\rangle=\left\langle\psi\left|M_{0}\right| \psi\right\rangle=|\alpha|^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  对应测量后的状态为
\begin{equation*}
\begin{split}\frac{M_{0}|\psi\rangle}{\sqrt{\left\langle\psi\left|M_{0}^{\dagger} M_{0}\right| \psi\right\rangle}}=\frac{M_{0}|\psi\rangle}{|\alpha|}=\frac{\alpha}{|\alpha|}|0\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  测量结果为1的概率为
\begin{equation*}
\begin{split}p(1)=\left\langle\psi\left|M_{1}^{\dagger} M_{1}\right| \psi\right\rangle=\left\langle\psi\left|M_{1}\right| \psi\right\rangle=|\beta|^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  测量后的状态为
\begin{equation*}
\begin{split}\frac{M_{1}|\psi\rangle}{\sqrt{\left\langle\psi\left|M_{1}^{\dagger} M_{1}\right| \psi\right\rangle}}=\frac{M_{1}|\psi\rangle}{|\beta|}=\frac{\beta}{|\beta|}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  量子测量有很多种方式，比如投影测量（projective measurements）、POVM测量（Positive Operator\sphinxhyphen{}Valued Measure）。

\sphinxAtStartPar
\sphinxstylestrong{投影测量}

\sphinxAtStartPar
  为什么要介绍投影测量呢？因为当测量算子具有酉变换性质时，投影测量和一般测量等价。

\sphinxAtStartPar
  投影测量由一个可观测量（observable） \(\Lambda\) 来描述，可观测量 \(\Lambda\) 是一个待观测系统的状态空间上的自伴算子。可观测量 \(\Lambda\) 可以写成谱分解的形式
\begin{equation*}
\begin{split}\Lambda=\sum_{i} \lambda_{i} P_{i}\end{split}
\end{equation*}
\sphinxAtStartPar
  这里的 \(P_i\) ​为在 \(\Lambda\) ​的特征值 \(\lambda_{1}\) ​对应特征空间上的投影。测量的可能结果对应于可观测量的特征 \(\Lambda\) 值 \(\lambda_{i}\) ​。在对状态 \(|\psi\rangle\) ​测量之后，得到结果  \(i\) 的概率为
\begin{equation*}
\begin{split}p_{i}=p\left(\lambda=\lambda_{i}\right)=\left\langle\psi\left|P_{i}\right| \psi\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  若测量后，结果 \(i\) 发生，则量子系统最新的状态为
\begin{equation*}
\begin{split}\frac{P_{i}|\psi\rangle}{\sqrt{p_{i}}}\end{split}
\end{equation*}
\sphinxAtStartPar
  投影测量有一个重要的特征就是很容易计算投影测量的平均值 \(E(\Lambda)\) 。
\begin{equation*}
\begin{split}\begin{array}{r} E(\Lambda)=\sum_{i} \lambda_{i} p_{i} \\ =\sum_{i} \lambda_{i}\left\langle\psi\left|P_{i}\right| \psi\right\rangle \\ =\left\langle\psi|\left(\sum_{i} \lambda_{i} P_{i}\right) \mid \psi\right\rangle \\ =\langle\psi|\Lambda| \psi\rangle \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  这个公式它能够简化很多计算。观测量 \(\Lambda\) 的平均值通常也记作 \(\langle\Lambda\rangle \equiv\langle\psi|\Lambda| \psi\rangle\) 。因此，观测量 \(\Lambda\) 的标准差（standard deviation） \(\Delta(\Lambda)\) 满足
\begin{equation*}
\begin{split}[\Delta(\Lambda)]^{2}=\left\langle(\Lambda-\langle\Lambda\rangle)^{2}\right\rangle=\left\langle\Lambda^{2}\right\rangle-\langle\Lambda\rangle^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  标准差是一个刻画典型分散程度的度量。


\subsection{2.1.3 复合系统与联合测量}
\label{\detokenize{rst/2.1_u91cf_u5b50_u529b_u5b66_u7406_u8bba_u57fa_u7840:id4}}
\sphinxAtStartPar
  拥有两个或两个以上的量子比特的量子系统通常被称为复合系统（composite systems）。单量子比特系统的描述与测量已有所了解，那么多个量子比特的系统该如何描述以及怎样去测量呢？单量子比特系统与多量子比特系统之间又有怎样的关系呢？首先，解决这些问题，需要认识一个新的运算\sphinxhyphen{}张量积（tensor products）。

\sphinxAtStartPar
\sphinxstylestrong{张量积}

\sphinxAtStartPar
  张量积是两个向量空间形成一个更大向量空间的运算。在量子力学中，量子的状态由希尔伯特空间（Hilbert spaces）中的单位向量来描述。

\sphinxAtStartPar
  设 \(H_1\) 和 \(H_2\) 分别为 \(n_1\) 和 \(n_2\) 维的希尔伯特空间。 \(H_1\) 和 \(H_2\) 的张量积为一个 \(n_{1} n_{2}\) 维的希尔伯特空间 \(H \equiv H_{1} \otimes H_{2}\) ，对于 \(H_1\) 中的每一个向量 \(\left|h_{1}\right\rangle\) 和 \(H_2\) 中的每一个向量 \(\left|h_{2}\right\rangle\) 在 \(H\) 都有中唯一的向量 \(\left|h_{1}\right\rangle \otimes\left|h_{2}\right\rangle\) ，并且 \(H\) 中向量可表示为向量 \(\left|h_{1}\right\rangle \otimes\left|h_{2}\right\rangle\) 的线性叠加。还要满足以下基本性质：

\sphinxAtStartPar
（i）对任意 \(\left|h_{1}\right\rangle \in H_{1},\left|h_{2}\right\rangle \in H_{2}\) ​ ，以及任意复数  \(c \in \mathbb{C}\) ​，都有
\begin{equation*}
\begin{split}c\left(\left|h_{1}\right\rangle \otimes\left|h_{2}\right\rangle\right)=\left(c\left|h_{1}\right\rangle\right) \otimes\left|h_{2}\right\rangle=\left|h_{1}\right\rangle \otimes\left(c\left|h_{2}\right\rangle\right)\end{split}
\end{equation*}
\sphinxAtStartPar
（ii）对任意 \(\left|h_{1}^{1}\right\rangle,\left|h_{1}^{2}\right\rangle \in H_{1}\)  ，任意 \(\left|h_{2}\right\rangle \in H_{2}\)  ，都有
\begin{equation*}
\begin{split}\left(\left|h_{1}^{1}\right\rangle+\left|h_{1}^{2}\right\rangle\right) \otimes\left|h_{2}\right\rangle=\left|h_{1}^{1}\right\rangle \otimes\left|h_{2}\right\rangle+\left|h_{1}^{2}\right\rangle \otimes\left|h_{2}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
（iii）对任意  \(\left|h_{1}\right\rangle \in H_{1}\)  ，任意  \(\left|h_{2}^{1}\right\rangle,\left|h_{2}^{2}\right\rangle \in H_{2}\) ，都有
\begin{equation*}
\begin{split}\left|h_{1}\right\rangle \otimes\left(\left|h_{2}^{1}\right\rangle+\left|h_{2}^{2}\right\rangle\right)=\left|h_{1}\right\rangle \otimes\left|h_{2}^{1}\right\rangle+\left|h_{1}\right\rangle \otimes\left|h_{2}^{2}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\(\left|h_{1}\right\rangle \otimes\left|h_{2}\right\rangle\)  经常被简写为   \(\left|h_{1}\right\rangle\left|h_{2}\right\rangle,\left|h_{1}, h_{2}\right\rangle\) 或  \(\left|h_{1} h_{2}\right\rangle\)  。

\sphinxAtStartPar
  如果  \(|i\rangle\) 和  \(|j\rangle\) 分别为  \(H_{1}\) 和  \(H_{2}\) 的标准正交基，那么  \(|i\rangle \otimes|j\rangle\) 为  \(H \equiv H_{1} \otimes H_{2}\) 的标准正交基。例如，现在有两个 \(2\) 维的希尔伯特空间  \(H_{1}\) 和  \(H_{2}\) ，并且都 有一组标准正交基  \({|0\rangle,|1\rangle}\) ，那么  \(H\) 的标准正交基为  \({|00\rangle,|01\rangle,|10\rangle,|11\rangle}\) 。因此，任意给定  \(H\) 中的向量  \(|\psi\rangle\) 都可以表示成这组标准正交基的线性组合
\begin{equation*}
\begin{split}|\psi\rangle=\varepsilon_{00}|00\rangle+\varepsilon_{01}|01\rangle+\varepsilon_{10}|10\rangle+\varepsilon_{11}|11\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
其中  \(\varepsilon_{i j} \equiv\langle i j \mid \psi\rangle, i, j \in{0,1}\) 。

\sphinxAtStartPar
  设  \(A\) 和  \(B\) 分别为  \(H_{1}\) 和  \(H_{2}\) 上的线性算子，那么算子 \(A \otimes B\) 作用到  \(H\) 中的任意向量
\begin{equation*}
\begin{split}|\psi\rangle=\sum_{i j} \varepsilon_{i j}|i j\rangle=\sum_{i j} \varepsilon_{i j}|i\rangle \otimes|j\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  被定义为
\begin{equation*}
\begin{split}(A \otimes B)|\psi\rangle=(A \otimes B)\left(\sum_{\ddot j} \varepsilon_{i j}|i\rangle \otimes|j\rangle\right) \equiv \sum_{i j} \varepsilon_{i j}(A|i\rangle) \otimes(B|j\rangle)\end{split}
\end{equation*}
\sphinxAtStartPar
  可以证明以这种方式定义  \(A \otimes B\) 为  \(H_{1} \otimes H_{2}\) 上的线性算子。

\sphinxAtStartPar
  对于  \(H\) 中的两个任意向量  \(|\alpha\rangle=\sum_{ij} \alpha_{i j}|i j\rangle\) 和  \(|\beta\rangle=\sum_{ij} \beta_{i j}|i j\rangle\) ，这两个向量的内积被定义为
\begin{equation*}
\begin{split}\langle\alpha \mid \beta\rangle \equiv \sum_{i j} \alpha_{i j}^{*} \beta_{i j}\end{split}
\end{equation*}
\sphinxAtStartPar
  也可以证明这种函数满足之前的内积定义。

\sphinxAtStartPar
  这样的表达形式优点是表示比较简练，缺点是不太容易有直观的认识。下面给出线性算子张量积的矩阵表示的运算规则\sphinxhyphen{}克罗内科积（Kronecker product）。设   \(A\) 是   \(m \times n\) 的矩阵，  \(B\) 是  \(p \times q\) 的矩阵。  \(A \otimes B\) 的矩阵形式定义为
\begin{equation*}
\begin{split}A \otimes B \equiv\left[\begin{array}{cccc} A_{11} B & A_{12} B & \cdots & A_{1 n} B \\ A_{21} B & A_{22} B & \cdots & A_{2 n} B \\ \vdots & \vdots & \ddots & \vdots \\ A_{m 1} B & A_{m 2} B & \cdots & A_{m n} B \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  这里  \(A \otimes B\) 是一个  \(m p \times n q\) 的矩阵， \(A_{i j} B\) 表示矩阵  \(A\) 的中的第  \(i\) 行，第  \(j\) 列元素与矩阵  \(B\) 相乘。

\sphinxAtStartPar
  例如, Pauli矩阵  \(\sigma_{x}\) 和  \(\sigma_{y}\) 做张量积生成的矩阵为
\begin{equation*}
\begin{split}\sigma_{x} \otimes \sigma_{y}=\left[\begin{array}{cc} 0 \cdot \sigma_{y} & 1 \cdot \sigma_{y} \\ 1 \cdot \sigma_{y} & 0 \cdot \sigma_{y} \end{array}\right]=\left[\begin{array}{cccc} 0 & 0 & 0 & -i \\ 0 & 0 & i & 0 \\ 0 & -i & 0 & 0 \\ i & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  举个反例就可以验证张量积并不满足交换律。
\begin{equation*}
\begin{split}\sigma_{y} \otimes \sigma_{x}=\left[\begin{array}{cc} 0 \cdot \sigma_{x} & -i \cdot \sigma_{x} \\ i \cdot \sigma_{x} & 0 \cdot \sigma_{x} \end{array}\right]=\left[\begin{array}{cccc} 0 & 0 & 0 & -i \\ 0 & 0 & -i & 0 \\ 0 & i & 0 & 0 \\ i & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  可以看出  \(\sigma_{x} \otimes \sigma_{y} \neq \sigma_{y} \otimes \sigma_{x}\) 。

\sphinxAtStartPar
  两个向量做张量积该如何表示呢? 其实在给定基下，向量的坐标表示也可以看作一个特殊的矩阵。例如向量  \(|\alpha\rangle=\alpha_{1}|0\rangle+\alpha_{2}|1\rangle\) 和  \(|\beta\rangle=\beta_{1}|0\rangle+\beta_{2}|1\rangle\) 在标准正交基  \({|0\rangle,|1\rangle}\) 下的矩阵表示分别为  \(|\alpha\rangle=\left[\alpha_{1}, \alpha_{2}\right]^{T}\) 和  \(|\beta\rangle=\left[\beta_{1}, \beta_{2}\right]^{T}\) 。因此, \(|\alpha\rangle \otimes|\beta\rangle\) 的矩阵表示为
\begin{equation*}
\begin{split}|\alpha\rangle \otimes|\beta\rangle=\left[\begin{array}{c} \alpha_{1}|\beta\rangle \\ \alpha_{2}|\beta\rangle \end{array}\right]=\left[\begin{array}{c} \alpha_{1} \beta_{1} \\ \alpha_{1} \beta_{2} \\ \alpha_{2} \beta_{1} \\ \alpha_{2} \beta_{2} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  假设: 复合物理系统的状态空间由子物理系统状态空间的张量积生成，即是说，如果有被 \(1\) 到 \(n\) 标记的系统，第  \({i}\) 个系统的状态为  \(\left|\psi_{i}\right\rangle\) ，那么生成的整个系统的联合状态为  \(\left|\psi_{1}\right\rangle \otimes\left|\psi_{2}\right\rangle \otimes \cdots \otimes\left|\psi_{n}\right\rangle\) 。

\sphinxAtStartPar
  复合系统有单量子系统不具有的另一个奇特现象就是纠缠 (entanglement)。在数学上，设态  \(|\psi\rangle \in H_{1} \otimes H_{2}\) ，若不存在  \(|\alpha\rangle \in H_{1},|\beta\rangle \in H_{2}\) ，使得
\begin{equation*}
\begin{split}|\psi\rangle=|\alpha\rangle \otimes|\beta\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  则称  \(|\psi\rangle\) 是纠缠的 (entangled)。否则, 称  \(|\psi\rangle\) 不处于纠缠态 (entangled state) 。

\sphinxAtStartPar
  例如， 在双量子比特系统中：  \(\left|\psi_{1}\right\rangle=1 / \sqrt{2}(|00\rangle-|11\rangle)\) 处于纠缠态。而  \(\left|\psi_{2}\right\rangle=1 / \sqrt{2}(|00\rangle+|01\rangle)\) 是非纠缠的，这是因为  \(\left|\psi_{2}\right\rangle\) 还可分成  \(1 / \sqrt{2}|0\rangle \otimes(|0\rangle+|1\rangle)\) 。

\sphinxAtStartPar
\sphinxstylestrong{复合系统的状态演化}

\sphinxAtStartPar
  已知两能级的量子系统的状态是通过酉变换来实现演化的，那么复合系统的状态该如何随时间发生演化呢? 复合系统可以看成是子系统的张成，因此以下假设可以 说明复合系统中量子态的变化。

\sphinxAtStartPar
  假设：复合系统中量子态的演化是由张成复合系统的子系统中量子态的演化对应的酉变换做张量生成的变换来描述，即是说，如果有被 1 到n标记的系统，第 \({i}\) 个系统在  \(t_{1}\) 时刻的状态为  \(\left|\psi_{i}^{1}\right\rangle\) ，那么生成的整个系统的联合状态  \(\left|\psi^{1}\right\rangle\) 为  \(\left|\psi_{1}^{1}\right\rangle \otimes\left|\psi_{2}^{1}\right\rangle \otimes \cdots \otimes\left|\psi_{n}^{1}\right\rangle ` ；在  :math:`t_{2}\) 时刻，通过酉变换 \(U_{i}\) 将第  \({i}\) 个系统的状态演化为  \(\left|\psi_{i}^{2}\right\rangle\) ，那么在  \(t_{2}\) 时刻，复合系统的状态通过变换  \(U_{1} \otimes U_{2} \otimes \cdots \otimes U_{n}\) 演化为  \(\left|\psi_{1}^{2}\right\rangle \otimes\left|\psi_{2}^{2}\right\rangle \otimes \cdots \otimes\left|\psi_{n}^{2}\right\rangle\) 。

\sphinxAtStartPar
  例如，复合系统  \(H\) 由两能级系统  \(H_{1}\) 和  \(H_{2}\) 复合而成，在  \(t_{1}\) 时刻，两个系统的状态都为  \(|0\rangle\) ，则复合系统的状态为  \(|00\rangle\) ; 在时刻  \(t_{2}\) 第一个系统经过 \(X\) 门，状态变为  \(|1\rangle\) ，第二个系统经过  \(Z\) 门，状态为  \(|0\rangle\) ，那么复合系统的状态经过变换
\begin{equation*}
\begin{split}X \otimes Z=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right] \otimes\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]=\left[\begin{array}{cccc} 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & -1 \\ 0 & 0 & -1 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  变为
\begin{equation*}
\begin{split}[X \otimes Z]|00\rangle=\left[\begin{array}{cccc} 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & -1 \\ 0 & 0 & -1 & 0 \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right]=\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right]=|01\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  本质上复合系统中量子态的演化也是矩阵的乘法，与单个子系统相比，只不过是多了张量积的运算。

\sphinxstepscope


\section{2.2 量子程序}
\label{\detokenize{rst/2.2_u91cf_u5b50_u7a0b_u5e8f:id1}}\label{\detokenize{rst/2.2_u91cf_u5b50_u7a0b_u5e8f::doc}}

\subsection{2.2.1 量子计算原理}
\label{\detokenize{rst/2.2_u91cf_u5b50_u7a0b_u5e8f:id2}}
\sphinxAtStartPar
  经典计算中，最基本的单元是比特，而最基本的控制模式是逻辑门，可以通过逻辑门的组合来达到控制电路的目的。类似地，处理量子比特的方式就是量子逻辑门，使用量子逻辑门，有意识的使量子态发生演化，所以量子逻辑门是构成量子算法的基础。

\sphinxAtStartPar
\sphinxstylestrong{酉变换}

\sphinxAtStartPar
  酉变换是一种矩阵，也是一种操作，它作用在量子态上得到的是一个新的量子态。使用  \(U\) 来表达酉矩阵,  \(U^{\dagger}\) 表示酉矩阵的转置复共轭矩阵，二者满足运算关系  \(UU^{\dagger}=I\) ，所以酉矩阵的转置复共轭矩阵也是一个酉矩阵，说明酉变换是一种可逆变换。

\sphinxAtStartPar
  一般酉变换在量子态上的作用是变换矩阵左乘以右矢进行计算的。例如一开始有一个量子态  \(|\psi_{0}\rangle\) , 经过酉变换  \(U\) 之后得到  \(|\psi\rangle=U\left|\psi_{0}\right\rangle`\)

\sphinxAtStartPar
  或者也可以写为
\begin{equation*}
\begin{split}\langle\psi|=\left\langle\psi_{0}\right| U^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  由此可见，两个矢量的内积经过同一个酉变换之后保持不变。
\begin{equation*}
\begin{split}\langle\varphi \mid \psi\rangle=\langle\varphi|U^{\dagger}U| \psi\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  类似地，也可以通过酉变换表示密度矩阵的演化；
\begin{equation*}
\begin{split}\rho=U{\rho_{0}} U^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  这样就连混合态的演化也包含在内了。

\sphinxAtStartPar
\sphinxstylestrong{矩阵的指数函数}

\sphinxAtStartPar
  一旦定义了矩阵乘法, 就可以利用函数的幂级数来定义矩阵的函数，这其中就包含矩阵的指数函数。如果 \(A\) 是一个矩阵，那么 \(\exp (A)=1+A+\frac{A^{2}}{2 !}+\frac{A^{3}}{3 !}+\ldots\) . 就为矩阵  \(A\) 的指数函数形式。

\sphinxAtStartPar
  如果 \(A\) 是一个对角矩阵，即  \(A=\text{diag}\left(A_{11} A_{22} A_{33} \ldots . .\right)\) , 则由此验证
\begin{equation*}
\begin{split}\mathrm{A}^{n}=\text{diag}\left(A_{11}^{n}, A_{22}^{n}, A_{33}^{n} \cdots\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  从而得到
\begin{equation*}
\begin{split}\exp (A)=\text{diag}\left(e^{A_{11}} ,\mathrm{e}^{A_{22}}, \mathrm{e}^{A_{33}} \ldots\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  如果 \(A\) 不是一个对角矩阵，则利用酉变换可以将它对角化， \(D=U D U^{\dagger}\) ，从而有
\begin{equation*}
\begin{split}\mathrm{A}^{n}=U ^{\dagger} {\mathrm{D}^{n} \mathrm U}\end{split}
\end{equation*}
\sphinxAtStartPar
  那么，类似地
\begin{equation*}
\begin{split}\exp (\mathrm{A})=U ^{\dagger}\exp (\mathrm{D}) U\end{split}
\end{equation*}
\sphinxAtStartPar
  必须要引起注意的是
\begin{equation*}
\begin{split}\exp (A+B) \neq \exp (A) \exp (B) \neq \exp (B) \exp (A)\end{split}
\end{equation*}
\sphinxAtStartPar
  当 \(A\) 是表示数的时候等号是成立的，那么，当 \(A\) 表示是矩阵时，等式成立要满足什么条件？

\sphinxAtStartPar
  通常，下面这种表达形式被称之为以 \(A\) 为生成元生成的酉变换；
\begin{equation*}
\begin{split}U(\theta)=\exp (-\mathrm{i} \theta A)\end{split}
\end{equation*}
\sphinxAtStartPar
  这种矩阵的指数运算可以利用数值计算软件Matlab中的expm，或者Mathematica中的MatrixExp命令进行方便地计算。

\sphinxAtStartPar
\sphinxstylestrong{单位矩阵}
\begin{equation*}
\begin{split}I=\left[\begin{array}{ll} 1 & 0 \\ 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  以单位矩阵为生成元，可以构建一种特殊的酉变换。
\begin{equation*}
\begin{split}\begin{array}{cc} u(\theta)=\exp (-i \theta I)=\left(\begin{array}{cc} e^{-i \theta} & 0 \\ 0 & e^{-i \theta} \end{array}\right)=\exp (-i \theta) I \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  它作用在态矢上面，相当于对于态矢整体（或者说每个分量同时）乘以一个系数。如果将这种态矢带入到密度矩阵的表达式中，会发现这一项系数会被消去。

\sphinxAtStartPar
  这项系数称为量子态的整体相位。因为任何操作和测量都无法分辨两个相同的密度矩阵，所以量子态的整体相位一般情况下是不会对系统产生任何影响的。

\sphinxAtStartPar
\sphinxstylestrong{单量子比特逻辑门}

\sphinxAtStartPar
  在经典计算机中，单比特逻辑门只有一种——非门（NOT gate），但是在量子计算机中，量子比特情况相对复杂，存在叠加态、相位，所以单量子比特逻辑门会有更加丰富的种类。

\sphinxAtStartPar
\sphinxstylestrong{泡利矩阵}

\sphinxAtStartPar
  泡利矩阵（Pauli matrices）有时也被称作自旋矩阵（spin matrices）。有以下三种形式，分别是
\begin{equation*}
\begin{split}\left.\sigma_{x}=\left(\begin{array}{rr} 0 & 1 \\ 1 & 0 \end{array}\right) \quad \sigma_{y}=\left(\begin{array}{cc} 0 & -i \\ i & 0 \end{array}\right) \quad \sigma_{z}=\left(\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right)\right.\end{split}
\end{equation*}
\sphinxAtStartPar
  三个泡利矩阵所表示的泡利算符代表着对量子态矢量最基本的操作。如将  \(\sigma_{x}\) 作用到 \(|0\rangle\) 态上， 经过矩阵运算，得到的末态为  \(|1\rangle\) 态。 泡利矩阵的线性组合是完备的二维酉变换生成元，即所有满足  \(U U ^{\dagger}=I\) 的  \(U\) 都能通过下面这种方式得到
\begin{equation*}
\begin{split}\mathrm{U}=\mathrm{e}^{-i \theta\left(a \sigma_{x}+b \sigma_{y}+c \sigma_{z}\right)}\end{split}
\end{equation*}
\sphinxAtStartPar
  介绍单量子逻辑门时，会使用图2.2.1来表示。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{2.2.1}.png}\hspace*{\fill}}

\begin{center}图2.2.1 单量子逻辑门
\end{center}
\sphinxAtStartPar
  横线表示一个量子比特从左到右按照时序演化的路线，方框表示量子逻辑门， 这个图标表示一个名为 \(U\) 的逻辑门作用在这条路线所代表的量子比特上。对于一个处 于  \(\left|\psi_{0}\right\rangle\) 的量子态，将这个量子逻辑门作用在上面时，相当于将这个量子逻辑门代表的酉矩阵左乘这个量子态的矢量，然后得到下一个时刻的量子态  \(\left|\psi_{1}\right\rangle\) 。

\sphinxAtStartPar
  即:  \(\left|\psi_{1}\right\rangle=U\left|\psi_{0}\right\rangle\)

\sphinxAtStartPar
  这个表达式对于所有的单比特门或者多比特门都是适用的。对于一个有 \({n}\) 个量子比特的量子系统，它的演化是通过一个  \(2^{n} \times 2^{n}\) 的酉矩阵来表达。

\sphinxAtStartPar
\sphinxstylestrong{常见逻辑门以及含义}

\sphinxAtStartPar
\sphinxstylestrong{1）Hadamard (H) 门}

\sphinxAtStartPar
  Hadamard 门是一种可将基态变为叠加态的量子逻辑门，有时简称为H门。Hadamard 门作用在单比特上，它将基态 \(|0 \rangle\) 变成 \((|0\rangle +|1\rangle)/\sqrt{2}\) ，将基态 \(|1 \rangle\) 变成 \((|0\rangle -|1\rangle)/\sqrt{2}\) 。

\sphinxAtStartPar
  Hadamard门矩阵形式为
\begin{equation*}
\begin{split}H=\frac{1}{\sqrt{2}}\left[\begin{array}{cc} 1 & 1 \\ 1 & -1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  其在线路上显示如图2.2.2所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.2}.png}\hspace*{\fill}}

\begin{center}图2.2.2 Hadamard 门
\end{center}
\sphinxAtStartPar
 假设， \(H\) 门作用在任意量子态 \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=\mathrm{H}|\psi\rangle=\frac{1}{\sqrt{2}}\left[\begin{array}{cc} 1 & 1 \\ 1 & -1 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\frac{1}{\sqrt{2}}\left[\begin{array}{c} \alpha+\beta \\ \alpha-\beta \end{array}\right]=\frac{\alpha+\beta}{\sqrt{2}}|0\rangle+\frac{\alpha-\beta}{\sqrt{2}}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{2）Pauli\sphinxhyphen{}X门}

\sphinxAtStartPar
  Pauli\sphinxhyphen{}X门作用在单量子比特上，它是经典计算机 \(NOT\) 门的量子等价，将量子态进行翻转，量子态变化方式为：
\begin{equation*}
\begin{split}\begin{aligned} &|0\rangle \rightarrow|1\rangle \\ &|1\rangle \rightarrow|0\rangle \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  Pauli\sphinxhyphen{}X门矩阵形式为泡利矩阵 \(\sigma_{x}\) ​，即：
\begin{equation*}
\begin{split}\mathrm{X}=\sigma_{\mathrm{x}}=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  Pauli\sphinxhyphen{}X门矩阵又称 \(NOT\) 门；其在线路上显示如图2.2.3所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.3}.png}\hspace*{\fill}}

\begin{center}图2.2.3 Pauli\sphinxhyphen{}X门
\end{center}
\sphinxAtStartPar
  假设，NOT门作用在任意量子态 \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=\mathrm{X}|\psi\rangle=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\left[\begin{array}{l} \beta \\ \alpha \end{array}\right]=\beta|0\rangle+\alpha|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{3）Pauli\sphinxhyphen{}Y门}

\sphinxAtStartPar
  Pauli\sphinxhyphen{}Y门作用在单量子比特上，作用效果为绕Bloch球 \(Y\) 轴旋转角度 \(\pi\) ，Pauli\sphinxhyphen{}Y门的矩阵形式为泡利矩阵 \(\sigma_{y}\) ，即：
\begin{equation*}
\begin{split}\mathrm{Y}=\sigma_{\mathrm{y}}=\left[\begin{array}{cc} 0 & -\ i \\ \ i & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  其在线路上显示如图2.2.4所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.4}.png}\hspace*{\fill}}

\begin{center}图2.2.4 Pauli\sphinxhyphen{}Y门
\end{center}
\sphinxAtStartPar
  假设，Pauli\sphinxhyphen{}Y门作用在任意量子态 \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为:
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=\mathrm{Y}|\psi\rangle=\left[\begin{array}{cc} 0 & -i \\ \ i & 0 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\left[\begin{array}{c} -i \beta \\ i \alpha \end{array}\right]=-i \beta|0\rangle+i \alpha|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{4）Pauli\sphinxhyphen{}Z门}

\sphinxAtStartPar
  Pauli\sphinxhyphen{}Z 门作用在单量子比特上，作用效果是绕Bloch球 \(Z\) 轴旋转角度 \(\pi\) ，Pauli\sphinxhyphen{}Z门矩阵形式为泡利矩阵  \(\sigma_{z}\)  ，即：
\begin{equation*}
\begin{split}Z=\sigma_{z}=\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  其在线路上显示如图2.2.5所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.5}.png}\hspace*{\fill}}

\begin{center}图2.2.5 Pauli\sphinxhyphen{}Z 门
\end{center}
\sphinxAtStartPar
  假设，Pauli\sphinxhyphen{}Z门作用在任意量子态 \(|\psi\rangle=\alpha|0\rangle + \beta|1\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=\mathrm{Z}|\psi\rangle=\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\left[\begin{array}{c} \alpha \\ -\beta \end{array}\right]=\alpha|0\rangle-\beta|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{5）旋转门（rotation operators）}

\sphinxAtStartPar
  分别用不同的泡利矩阵作为生成元是构成 \(RX\) , \(RY\) , \(RZ\) 的方法。

\sphinxAtStartPar
\sphinxstylestrong{（1）RX(θ) 门}

\sphinxAtStartPar
  RX门由Pauli\sphinxhyphen{}X矩阵作为生成元生成，其矩阵形式为
\begin{equation*}
\begin{split}RX(\theta) \equiv e^{-i \theta X / 2}=\cos \left(\frac{\theta}{2}\right) I-i \sin \left(\frac{\theta}{2}\right) X=\left[\begin{array}{cc} \cos \left(\frac{\theta}{2}\right) & -i \sin \left(\frac{\theta}{2}\right) \\ -i \sin \left(\frac{\theta}{2}\right) & \cos \left(\frac{\theta}{2}\right) \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  其在线路上显示如图2.2.6所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.6}.png}\hspace*{\fill}}

\begin{center}图2.2.6 RX(θ) 门
\end{center}
\sphinxAtStartPar
  假设,  \(\mathrm{RX}(\pi / 2)\) 门作用在任意量子态  \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=\mathrm{RX}(\pi / 2)|\psi\rangle=\frac{\sqrt{2}}{2}\left[\begin{array}{rr} 1 & -\mathrm{i} \\ -\mathrm{i} & 1 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\frac{\sqrt{2}}{2}\left[\begin{array}{l} \alpha-i \beta \\ \beta-i \alpha \end{array}\right]=\frac{\sqrt{2}(\alpha-i \beta)}{2}|0\rangle+\frac{\sqrt{2}(\beta-i \alpha)}{2}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{（2）RY(θ) 门}

\sphinxAtStartPar
  RY门由Pauli\sphinxhyphen{}Y矩阵作为生成元生成，其矩阵形式为
\begin{equation*}
\begin{split}RY(\theta) \equiv e^{-i \theta Y / 2}=\cos \left(\frac{\theta}{2}\right) I-i \sin \left(\frac{\theta}{2}\right) Y=\left[\begin{array}{cc} \cos \left(\frac{\theta}{2}\right) & -\sin \left(\frac{\theta}{2}\right) \\ \sin \left(\frac{\theta}{2}\right) & \cos \left(\frac{\theta}{2}\right) \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
其在线路上显示如图2.2.7所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.7}.png}\hspace*{\fill}}

\begin{center}图2.2.7 RY(θ) 门
\end{center}
\sphinxAtStartPar
  假设， \(RY(\pi / 2)\) 门作用在任意量子态  \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\begin{aligned} &\left|\psi^{\prime}\right\rangle=\text{RY}\left(\frac{\pi}{2}\right)|\psi\rangle=\frac{\sqrt{2}}{2}\left[\begin{array}{cc} 1 & -1 \\ 1 & 1 \end{array}\right]\left[\begin{array}{l} \alpha \\ \beta \end{array}\right]=\frac{\sqrt{2}}{2}\left[\begin{array}{l} \alpha-\beta \\ \alpha+\beta \end{array}\right]=\frac{\sqrt{2}(\alpha-\beta)}{2}|0\rangle+\frac{\sqrt{2}(\alpha+\beta)}{2}|1\rangle \\ \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{（3）RZ(θ) 门}

\sphinxAtStartPar
  RZ又称相位转化门（phase\sphinxhyphen{}shift gate），由Pauli\sphinxhyphen{}Z矩阵作为生成元生成，其矩阵形式为
\begin{equation*}
\begin{split}RZ(\theta) \equiv e^{-i \theta Z / 2}=\cos \left(\frac{\theta}{2}\right) I-i \sin \left(\frac{\theta}{2}\right) Z=\left[\begin{array}{cc} e^{-i \theta / 2} & 0 \\ 0 & e^{i \theta / 2} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  上式还可以写为
\begin{equation*}
\begin{split}RZ(\theta)=\left[\begin{array}{cc} e^{-i \theta / 2} & \\ & e^{i \theta / 2} \end{array}\right]=e^{-i \theta / 2}\left[\begin{array}{ll} 1 & \\ & e^{i \theta} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  由于矩阵
\begin{equation*}
\begin{split}\left[\begin{array}{ll} e^{-i \theta / 2} & \\ & e^{i \theta / 2} \end{array}\right] \text { 和 }\left[\begin{array}{ll} 1 & \\ & e^{i \theta} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  只差一个整体相位 (global phases)  \(e^{-i \theta / 2}\) ，只考虑单门的话，两个矩阵做成的量子逻辑门是等价的，即有时 \(RZ\) 门的矩阵形式写作
\begin{equation*}
\begin{split}RZ(\theta)=\left[\begin{array}{ll} 1 & 0 \\ 0 & e^{i \theta} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
   \(RZ\) 量子逻辑门作用在基态上的效果为
\begin{equation*}
\begin{split}RZ|0\rangle=\left[\begin{array}{cc} 1 & 0 \\ 0 & e^{i \theta} \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \end{array}\right]=\left[\begin{array}{c} 1 \\ 0 \end{array}\right]=|0\rangle\end{split}
\end{equation*}\begin{equation*}
\begin{split}RZ|1\rangle=\left[\begin{array}{cc} 1 & 0 \\ 0 & e^{i \theta} \end{array}\right]\left[\begin{array}{l} 0 \\ 1 \end{array}\right]=\left[\begin{array}{c} 0 \\ e^{i \theta} \end{array}\right]=e^{i \theta}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  由于全局相位没有物理意义，并没有对计算基  \(|0\rangle\) 和  \(|1\rangle\) 做任何的改变，而是在原来的态上绕Z轴逆时针旋转 \(\theta\) 角。

\sphinxAtStartPar
  其在线路上显示如图2.2.8所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.8}.png}\hspace*{\fill}}

\begin{center}图2.2.8 RZ(θ) 门
\end{center}
\sphinxAtStartPar
  假设,  \(\mathrm{RZ}(\pi / 2)\) 门作用在任意量子态  \(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\) 上面, 得到新的量子态为:
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=R Z\left(\frac{\pi}{2}\right)|\psi\rangle=\left[\begin{array}{cc} 1 & 0 \\ 0 & \frac{\sqrt{2}(1+i)}{2} \end{array}\right]\left[\begin{array}{c} \alpha \\ \beta \end{array}\right]=\left[\begin{array}{c} \alpha \\ \frac{\sqrt{2}(1+\mathrm{i})}{2} \beta \end{array}\right]=\alpha|0\rangle+\frac{\sqrt{2}(1+\mathrm{i})}{2} \beta|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
   \(RX\) , \(RY\) , \(RZ\) 意味着将量子态在布洛赫球上分别绕着 \(X\) , \(Y\) , \(Z\) 轴旋转 \(\theta\) 角度，所以 \(RX\) ， \(RY\) 能带来概率幅的变化，而 \(RZ\) 只有相位的变化。那么，共同使用这三种操作能使量子态在整个布洛赫球上自由移动。

\sphinxAtStartPar
\sphinxstylestrong{多量子比特逻辑门}

\sphinxAtStartPar
  不论是在经典计算还是量子计算中，两量子比特门无疑是建立量子比特之间联系的最重要桥梁。不同于经典计算中的与或非门及它们的组合，量子逻辑门要求所有的逻辑操作必须是酉变换，所以输入和输出的比特数量是相等的。

\sphinxAtStartPar
  在描述两量子比特门之前，必须要将之前对于单量子比特的表示方式扩展一下。联立两个量子比特或者两个以上的量子比特时，就用到复合系统中量子态演化的假设。

\sphinxAtStartPar
  对于一个 \(n\) 量子比特 \(\left|x_{n-1} \cdots x_{0}\right\rangle\) , \(n\) 量子比特系统的计算基就有 \(2^{n}\) 单位正交矢量组成，借助于经典比特的进位方式对量子比特进行标记，从左到右依次是二进制中的从高位到低位，也就是说 \(\left|x_{n-1} \cdots x_{0}\right\rangle\) 中  \(x_{n-1}\) 为高位， \(x_{0}\) 为低位。

\sphinxAtStartPar
  比如对于一个2量子比特的系统，其计算基分别记做
\begin{equation*}
\begin{split}\begin{array}{ll} |00\rangle=\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right], & |01\rangle=\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right], \\ |10\rangle=\left[\begin{array}{l} 0 \\ 0 \\ 1 \\ 0 \end{array}\right], & |11\rangle=\left[\begin{array}{l} 0 \\ 0 \\ 0 \\ 1 \end{array}\right] \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  在基态 \(|01 \rangle\) 中，左侧的0对应的位为高位，1对应的位为低位。

\sphinxAtStartPar
  在介绍2比特量子逻辑门时，会使用如图2.2.9的图标：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{2.2.9}.png}\hspace*{\fill}}

\begin{center}图2.2.9 2比特量子逻辑门
\end{center}
\sphinxAtStartPar
  每根线表示一个量子比特演化的路线，这和单比特门中的横线是类似的，不一样的是这两根线有位次之分，从上到下依次分别表示从低位到高位的量子比特演化的路线。这个图标横跨两个量子比特，它代表将一个两比特门作用在这两个量子比特上，这个图标代表的是 \(CNOT\) 门。

\sphinxAtStartPar
\sphinxstylestrong{CNOT 门}

\sphinxAtStartPar
  控制非门(Control\sphinxhyphen{}NOT)，通常用 \(CNOT\) 进行表示，是一种普遍使用的两量子比特门。

\sphinxAtStartPar
  若低位为控制比特，那么它具有如下的矩阵形式:
\begin{equation*}
\begin{split}C N O T=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  对应的 \(CNOT\) 门在线路中显示如图2.2.10：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{2.2.10}.png}\hspace*{\fill}}

\begin{center}图2.2.10 CNOT门
\end{center}
\sphinxAtStartPar
  含实点的路线对应的量子比特称为控制比特（control qubit），含+号的路线对应的量子比特为目标比特（target qubit）。

\sphinxAtStartPar
  假设， \(CNOT\) 门作用分别作用在基态 \(|\psi\rangle=|00\rangle\) , \(|01\rangle\) , \(|10\rangle\) , \(|11\rangle\) 上面, 得到新的量子态为：
\begin{equation*}
\begin{split}\begin{aligned} &\left|\psi^{\prime}\right\rangle=\mathrm{CNOT}|00\rangle=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right]=\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right]=|00\rangle \\ &\left|\psi^{\prime}\right\rangle=\mathrm{CNOT}|01\rangle=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right]=\left[\begin{array}{l} 0 \\ 0 \\ 0 \\ 1 \end{array}\right]=|11\rangle \\ &\left|\psi^{\prime}\right\rangle=\mathrm{CNOT}|10\rangle=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\left[\begin{array}{l} 0 \\ 0 \\ 1 \\ 0 \end{array}\right]=\left[\begin{array}{l} 0 \\ 0 \\ 1 \\ 0 \end{array}\right]=|10\rangle \\ &\left|\psi^{\prime}\right\rangle=\text {CNOT}|11\rangle=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\left[\begin{array}{l} 0 \\ 0 \\ 0 \\ 1 \end{array}\right]=\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right]=|01\rangle \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  由于低位比特为控制比特，高位比特为目标比特，所以当低位比特位置对应为1时，高位比特就会被取反；当低位比特位置为0时，不对高位比特做任何操作。

\sphinxAtStartPar
  若高位比特为控制比特，那么它具有如下的矩阵形式:
\begin{equation*}
\begin{split}\mathrm{CNOT}=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\(CNOT\) 门在线路中显示如图2.2.11：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{2.2.11}.png}\hspace*{\fill}}

\begin{center}图2.2.11 CNOT门
\end{center}
\sphinxAtStartPar
  假设，高位为控制比特， \(CNOT\) 门分别作用在基态  \(|\psi\rangle=|00\rangle\) , \(|01\rangle\) , \(|10\rangle\) , \(|11\rangle\) 上，那么，可以计算四个两量子比特的计算基经 \(CNOT\) 门的演化结果如图2.2.12所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{2.2.12}.png}\hspace*{\fill}}

\begin{center}图2.2.12 演化结果
\end{center}
\sphinxAtStartPar
  从上例可以看出 \(CNOT\) 门的含义是当控制比特为 \(|0 \rangle\) 态时，目标比特不发生改变；当控制比特为 \(|1 \rangle\) 态时，对目标比特执行 \(X\) 门(量子非门)操作。要注意的是控制比特和目标比特的地位是不能交换的。

\sphinxAtStartPar
\sphinxstylestrong{CR 门}

\sphinxAtStartPar
  控制相位门（Controlled phase gate）和控制非门类似，通常记为 \(CR\) (CPhase)，其矩阵形式如下
\begin{equation*}
\begin{split}\text{CR}(\theta)=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & \mathrm{e}^{\mathrm{i} \theta} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\(CR\) 门在线路中显示如图2.2.13：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.13}.png}\hspace*{\fill}}

\begin{center}图2.2.13 CR门
\end{center}
\sphinxAtStartPar
  在 \(CR\) 门的图标中，含实点的路线对应的量子比特称为控制比特（control qubit），含CR字母的路线对应量子比特为目标比特（target qubit）。

\sphinxAtStartPar
  当控制比特为 \(|0 \rangle\) 态时，目标比特不发生改变；当控制比特为 \(|1 \rangle\) 态时，对目标比特执行相转变门（phase\sphinxhyphen{}shift gate），其特殊的是，控制相位门里交换控制比特和目标比特的角色，矩阵形式不会发生任何改变。

\sphinxAtStartPar
\sphinxstylestrong{iSWAP 门}

\sphinxAtStartPar
  \(\text{iSWAP}\) 门的主要作用是交换两个比特的状态，并且赋予其 \(\pi /2\) 相位；经典电路中也有SWAP门，但是 \(\text{iSWAP}\) 是量子计算中特有的。 \(\text{iSWAP}\) 门在某些体系中是较容易实现的两比特逻辑门，它是由  \(\sigma_{x} \otimes \sigma_{x}+\sigma_{y} \otimes \sigma_{y}\) 作为生成元生成，需要将矩阵 \(\sigma_{x} \otimes \sigma_{x}+\sigma_{y} \otimes \sigma_{y}\) 对角化， \(\text{iSWAP}\) 门的矩阵表示如下：
\begin{equation*}
\begin{split}\text{iSWAP}(\theta)=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & \cos (\theta) & -i \sin (\theta) & 0 \\ 0 & -i \sin (\theta) & \cos (\theta) & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\(\text{iSWAP}\) 门在线路中显示如图2.2.14：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.14}.png}\hspace*{\fill}}

\begin{center}图2.2.14 iSWAP门
\end{center}
\sphinxAtStartPar
  通常会用一个完整的翻转，即 \(\theta=\pi/2\) 的情况来指代 \(\text{iSWAP}\) 。当角度为 \(\text{iSWAP}\) 的一半时，即 \(\theta=\pi/4\) ，称之为 \(\sqrt{i}SWAP\) 。对于  \(\text{iSWAP}\) 门而言，两个比特之间地位是对等的，不存在控制和受控的关系。

\sphinxAtStartPar
\sphinxstylestrong{量子线路与测量操作}

\sphinxAtStartPar
  量子线路是由代表量子比特演化的路线和作用在量子比特上的量子逻辑门组成的。量子线路产生的效果，等同于每一个量子逻辑门依次作用在量子比特上。在真实的量子计算机上，最后要对量子系统末态进行测量操作，才能得到末态的信息，因此也把测量操作作为量子线路的一部分，测量操作有时也称为测量门。测量背后的原理就是之前讲到的投影测量。

\sphinxAtStartPar
  测量操作在线路上的显示如图2.2.15：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.15}.png}\hspace*{\fill}}

\begin{center}图2.2.15 测量操作
\end{center}
\sphinxAtStartPar
它表示对该量子路线代表的量子比特进行测量操作。

\sphinxAtStartPar
  在计算 \(|0\rangle\) , \(|1\rangle\) 下，测量操作对应的矩阵形式为
\begin{equation*}
\begin{split}M_{0}=|0\rangle \langle 0|=\left[\begin{array}{ll} 1 & 0 \\ 0 & 0 \end{array}\right] \quad M_{1}=| 1\ \rangle\langle 1|=\left[\begin{array}{ll} 0 & 0 \\ 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  如图2.2.16所示，是一个简单的单量子比特的量子线路。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.16}.png}\hspace*{\fill}}

\begin{center}图2.2.16 一个简单的单量子比特的量子线路
\end{center}
\sphinxAtStartPar
  初始态为 \(|0\rangle\) , 首先经过一个 \(H\) 门，演化得到末态
\begin{equation*}
\begin{split}\left|\psi^{\prime}\right\rangle=H|0\rangle=\frac{\sqrt{2}}{2}\left[\begin{array}{cc} 1 & 1 \\ 1 & -1 \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \end{array}\right]=\frac{\sqrt{2}}{2}\left[\begin{array}{l} 1 \\ 1 \end{array}\right]=\frac{\sqrt{2}}{2}|0\rangle+\frac{\sqrt{2}}{2}|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  接着就对其进行测量操作，得到投影到计算基 \(|0\rangle\) 下的概率为
\begin{equation*}
\begin{split}\begin{aligned} &\quad P(0)=\left\langle\psi^{\prime}\left|M_{0}^{\dagger} M_{0}\right| \psi^{\prime}\right\rangle \\ &=\left\langle\psi^{\prime}\left|M_{0}\right| \psi^{\prime}\right\rangle \\ &=\left[\begin{array}{ll} \sqrt{2} / 2 & \sqrt{2} / 2 \end{array}\right]\left[\begin{array}{ll} 1 & 0 \\ 0 & 0 \end{array}\right]\left[\begin{array}{l} \sqrt{2} / 2 \\ \sqrt{2} / 2 \end{array}\right] \\ &=\frac{1}{2} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  根据测量假设，测量过后末态  \(\left|\psi^{\prime}\right\rangle\) 变为新的量子态
\begin{equation*}
\begin{split}\left|\psi^{\prime \prime}\right\rangle=\frac{M_{0}\left|\psi^{\prime}\right\rangle}{\sqrt{P(0)}}=\left[\begin{array}{l} 1 \\ 0 \end{array}\right]=|0\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  投影到计算基 \(|1\rangle\) 下的概率为
\begin{equation*}
\begin{split}\begin{aligned} & P(1)=\left\langle\psi^{\prime}\left|M_{1}^{\dagger} M_{1}\right| \psi^{\prime}\right\rangle. \\ &=\left\langle\psi^{\prime}\left|M_{1}\right| \psi^{\prime}\right\rangle \\ &=[\sqrt{2} / 2 \quad \sqrt{2} / 2]\left[\begin{array}{ll} 0 & 0 \\ 0 & 1 \end{array}\right]\left[\begin{array}{c} \sqrt{2} / 2 \\ \sqrt{2} / 2 \end{array}\right] \\ &=\frac{1}{2} . \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  测量过后末态 \(\left|\psi^{\prime}\right\rangle\) 变为新的量子态
\begin{equation*}
\begin{split}\left|\psi^{\prime \prime}\right\rangle=\frac{M_{1}\left|\psi^{\prime}\right\rangle}{\sqrt{P(1)}}=\left[\begin{array}{l} 0 \\ 1 \end{array}\right]=|1\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  由于在真实的量子计算机上面, 测量会对量子态有影响，所以只能够通过新制备初始量子态，让它重新演化，再进行测量，从而得到末量子态在计算基下的频率, 用频率来近似概率，并且每次测量只能够用测量操作  \(M_{0}\) 与   \(M_{1}\) 中的一个进行测量。

\sphinxAtStartPar
​  图2.2.17，表示的是两量子比特的量子线路：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.17}.png}\hspace*{\fill}}

\begin{center}图2.2.17 两量子比特的量子线路
\end{center}
\sphinxAtStartPar
  在该量子线路中，初始态q{[}1{]}、q{[}0{]}代表量子比特的初始态均为  \(|0\rangle\) ，因此该系统的复合量子态为  \(|00\rangle\) , 这里复合量子态 \(|00\rangle\) 的从左到右依次对应高位比特到低位比特。首先该复合的量子比特在时刻 \(1\) 同时经过 \(H\) 门 和 \(X\) 门，接着在时刻 \(2\) 经过 \(CNOT\) 门，最后在时刻 \(3\) 进行整体测量操作。下面用数学的语言进行描述，在初始时刻系统处在初始态  \(\left|\psi_{0}\right\rangle=|00\rangle\) ，其中左边的 0 为高位 \(q[1]\) , 右边的 0 为低位 \(q[0]\) , 经过时刻 \(1\) 的门以后量子态变为
\begin{equation*}
\begin{split}\left|\psi_{1}\right\rangle=[H \otimes X]|00\rangle=\frac{\sqrt{2}}{2}\left[\begin{array}{cc} X & X \\ X & -X \end{array}\right]|00\rangle=\frac{\sqrt{2}}{2}\left[\begin{array}{cccc} 0 & 1 & 0 & 1 \\ 1 & 0 & 1 & 0 \\ 0 & 1 & 0 & -1 \\ 1 & 0 & -1 & 0 \end{array}\right]\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right]=\frac{\sqrt{2}}{2}\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  接着在时刻 \(2\) 经历 \(CNOT\) 门后，演化为
\begin{equation*}
\begin{split}\left|\psi_{2}\right\rangle=\mathrm{CNOT}\left|\psi_{1}\right\rangle=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \end{array}\right]\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=\frac{\sqrt{2}}{2}|01\rangle+\frac{\sqrt{2}}{2}|11\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  最后，到时刻 \(3\) 进行测量操作，若用测量操作 \(M_{00} \equiv|00\rangle\langle 00|\) ，则得到投影到计算基 \(|00\rangle\) 下的概率为
\begin{equation*}
\begin{split}\begin{aligned}&P(00)=\left\langle\psi_{2}\left|M_{00}^{\dagger} M_{00}\right| \psi_{2}\right\rangle \\&=\left\langle\psi_{2}\left|M_{00}\right| \psi_{2}\right\rangle \\&=\left\langle\psi_{2}|[|00\rangle\langle 00|]| \psi_{2}\right\rangle\\&=\left[\begin{array}{llll}0 & \frac{\sqrt{2}}{2} & 0 & \frac{\sqrt{2}}{2}\end{array}\right]\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0\end{array}\right]\left[\begin{array}{c}0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2\end{array}\right]\\&=0\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  根据测量假设，由于 \(P(00)=0\) ，因此测量过后，量子态  \(\left|\psi_{2}\right\rangle\) 不可能坍缩在基态 \(|00\rangle\) 上面。

\sphinxAtStartPar
  若用测量操作 \(M_{01} \equiv|01\rangle\langle 01|\) ，则得到投影到计算基 \(|01\rangle\) 下的概率为
\begin{equation*}
\begin{split}P(01)=\left\langle\psi_{2}\left|M_{01}^{\dagger} M_{01}\right| \psi_{2}\right\rangle=\left\langle\psi_{2}\left|M_{01}\right| \psi_{2}\right\rangle=\frac{1}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  对量子态 \(\left|\psi_{2}\right\rangle\) 测量后, 得到新的量子态为
\begin{equation*}
\begin{split}\left|\psi_{3}\right\rangle=\frac{M_{01}\left|\psi_{2}\right\rangle}{\sqrt{P(01)}}=\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right]=|01\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  若用测量操作 \(M_{10} \equiv|10\rangle\langle 10|\) ，则得到投影到计算基 \(|10\rangle\) 下的概率为
\begin{equation*}
\begin{split}P(10)=\left\langle\psi_{2}\left|M_{10}^{\dagger} M_{10}\right| \psi_{2}\right\rangle=\left\langle\psi_{2}\left|M_{10}\right| \psi_{2}\right\rangle=0\end{split}
\end{equation*}
\sphinxAtStartPar
  所以测量过后, 量子态 \(\left|\psi_{2}\right\rangle\) 不可能坍缩在基态 \(|10\rangle\) 上面。

\sphinxAtStartPar
  若用测量操作 \(M_{11} \equiv|11\rangle\langle 11|\) ，则得到投影到计算基 \(|11\rangle\) 下的概率为
\begin{equation*}
\begin{split}P(11)=\left\langle\psi_{2}\left|M_{11}^{\dagger} M_{11}\right| \psi_{2}\right\rangle=\left\langle\psi_{2}\left|M_{11}\right| \psi_{2}\right\rangle=\frac{1}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  对量子态 \(\left|\psi_{2}\right\rangle\) 测量后, 得到新的量子态为
\begin{equation*}
\begin{split}\left|\psi_{3}\right\rangle=\frac{M_{11}\left|\psi_{2}\right\rangle}{\sqrt{P(11)}}=\left[\begin{array}{l} 0 \\ 0 \\ 0 \\ 1 \end{array}\right]=|11\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  有时可能关心线路中某些位量子比特的演化结果，那么就把测量放在某些量子比特对应的路线上面。如图2.2.18所示，将测量操作放在高位比特所对应路线上面。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.18}.png}\hspace*{\fill}}

\begin{center}图2.2.18 测量操作放在高位比特所对应路线上面
\end{center}
\sphinxAtStartPar
此时测量对应的矩阵形式为
\begin{equation*}
\begin{split}M_{0}^{1}=\sum_{i \in\{0,1\}}|0 i\rangle\langle 0 i| \text { 和 } M_{1}^{1}=\sum_{i \in\{0,1\}}|1 i\rangle\langle 1 i|\end{split}
\end{equation*}
\sphinxAtStartPar
  因此通过测量，得到测量结果0和1发生的概率分别为
\begin{equation*}
\begin{split}\begin{aligned} &P_{1}(0)=\left\langle\psi_{2}\left|M_{1}^{0}\right| \psi_{2}\right\rangle=\left[\begin{array}{cccc} 0 & \frac{\sqrt{2}}{2} & 0 & \frac{\sqrt{2}}{2} \end{array}\right]\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=\frac{1}{2} \\ &P_{1}(1)=\left\langle\psi_{2}\left|M_{1}^{1}\right| \psi_{2}\right\rangle=\left[\begin{array}{cccc} 0 & \frac{\sqrt{2}}{2} & 0 & \frac{\sqrt{2}}{2} \end{array}\right]\left[\begin{array}{cccc} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=\frac{1}{2} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  测量后，量子系统的状态分别变为
\begin{equation*}
\begin{split}\begin{aligned} &\left|\psi_{3}\right\rangle=\frac{M_{1}^{0}\left|\psi_{2}\right\rangle}{\sqrt{P_{1}(0)}}=|01\rangle \\ &\left|\psi_{3}\right\rangle=\frac{M_{1}^{1}\left|\psi_{2}\right\rangle}{\sqrt{P_{1}(1)}}=|11\rangle \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  同理，对低位比特q{[}0{]}进行单独测量时,线路图如图2.2.19所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{2.2.19}.png}\hspace*{\fill}}

\begin{center}图2.2.19 对低位比特q{[}0{]}进行单独测量时的线路图
\end{center}
\sphinxAtStartPar
此时测量操作对应的矩阵形式为
\begin{equation*}
\begin{split}M_{0}^{0}=\sum_{i \in\{0,1\}}|i 0\rangle\langle i 0| \text { 和 } M_{1}^{0}=\sum_{i \in\{0,1\}}|i 1\rangle\langle i 1|\end{split}
\end{equation*}
\sphinxAtStartPar
  通过测量，得到测量结果0发生的概率为
\begin{equation*}
\begin{split}P_{0}(0)=\left\langle\psi_{2}\left|M_{0}^{0}\right| \psi_{2}\right\rangle=\left[\begin{array}{llll} 0 & \frac{\sqrt{2}}{2} & 0 & \frac{\sqrt{2}}{2} \end{array}\right]\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=0\end{split}
\end{equation*}
\sphinxAtStartPar
  得到测量结果1发生的概率为
\begin{equation*}
\begin{split}P_{0}(1)=\left\langle\psi_{2}\left|M_{0}^{1}\right| \psi_{2}\right\rangle=\left[\begin{array}{llll} 0 & \frac{\sqrt{2}}{2} & 0 & \frac{\sqrt{2}}{2} \end{array}\right]\left[\begin{array}{cccc} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\left[\begin{array}{c} 0 \\ \sqrt{2} / 2 \\ 0 \\ \sqrt{2} / 2 \end{array}\right]=1\end{split}
\end{equation*}
\sphinxAtStartPar
  测量后，系统由原来的量子态 \(\left|\psi_{2}\right\rangle\) 演化为量子状态
\begin{equation*}
\begin{split}\left|\psi_{3}\right\rangle=\frac{M_{0}^{1}\left|\psi_{2}\right\rangle}{\sqrt{P_{0}(1)}}=\frac{\sqrt{2}}{2}|01\rangle+\frac{\sqrt{2}}{2}|11\rangle\end{split}
\end{equation*}

\subsection{2.2.2 量子计算的 if 和 while}
\label{\detokenize{rst/2.2_u91cf_u5b50_u7a0b_u5e8f:if-while}}
\sphinxAtStartPar
  所谓量子线路，从本质上是一个量子逻辑门的执行序列，它是从左至右依次执行的。即使介绍了函数调用的思想，也可以理解为这是一种简单地内联展开，即把函数中的所有逻辑门插入到调用处，自然地，可能会考虑在量子计算机的层面是否存在类似于经典计算机中的循环和分支语句。因此，就有了QIF和QWHILE。

\sphinxAtStartPar
\sphinxstylestrong{l 基于测量的跳转}

\sphinxAtStartPar
  作为QIF和QWHILE的判断条件的对象，并不是量子比特，而是一个经典的信息，往往，这个经典的信息是基于测量的。在量子程序执行时，测量语句会对量子比特施加一个测量操作，之后将这个比特的测量结果保存到经典寄存器中，最后，可以根据这个经典寄存器的值，选择接下来要进行的操作。例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}  \PYG{n}{H} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{q}
\PYG{l+m+mf}{2.}  \PYG{n}{Meas} \PYG{n}{q} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}
\PYG{l+m+mf}{3.}  \PYG{n}{Qif} \PYG{p}{(}\PYG{n}{c} \PYG{o}{==} \PYG{n}{Zero}\PYG{p}{)} \PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{q}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这样的量子程序表示的是对q进行Hadamard门操作之后，测量它；如果测量的结果是0，则再做一个Hadamard门。从这个例子可以继续延伸到Qif可以包裹的一系列语句，而不仅仅是一个，比如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.  Qif (c == Zero)
2.  \PYGZob{}
3.          H\PYGZhy{}\PYGZgt{}q
4.          CNOT(q0, q1)
5.          ……
6.  \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  或者也可以设置Qelse语句，它表示如果判断条件为非，则要执行的语句。例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}  \PYG{n}{Qif} \PYG{p}{(}\PYG{n}{c} \PYG{o}{==} \PYG{n}{Zero}\PYG{p}{)} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{q0}\PYG{p}{,} \PYG{n}{q1}\PYG{p}{)}
\PYG{l+m+mf}{2.}  \PYG{n}{Qelse} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{q1}\PYG{p}{,}\PYG{n}{q0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  再或许可以综合两个、多个量子比特的测量结果，对它们进行布尔代数运算，进行判断。另一种情况是将N个量子比特的测量结果理解为一个N\sphinxhyphen{}bit整数，之后再与其他整数进行比较。

\sphinxAtStartPar
  例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.  Qif (c1 == Zero \PYGZam{}\PYGZam{} c2 == One)
2.  \PYGZob{}
3.          H\PYGZhy{}\PYGZgt{}q
4.          CNOT(q0, q1)
5.          ……
6.  \PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  上述规则对于QWhile来说也是一样，比如一个随机计数的代码：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}  \PYG{n}{c} \PYG{o}{=} \PYG{n}{One}
\PYG{l+m+mf}{2.}  \PYG{n}{n} \PYG{o}{=} \PYG{n}{Zero}
\PYG{l+m+mf}{3.}  \PYG{n}{QWhile}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{l+m+mf}{4.}  \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}          \PYG{n}{H} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{q}
\PYG{l+m+mf}{6.}          \PYG{n}{Meas} \PYG{n}{q}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{c}
\PYG{l+m+mf}{7.}      \PYG{n}{n} \PYG{o}{+}\PYG{o}{+}
\PYG{l+m+mf}{8.}  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这个程序的含义是每次对qubit执行Hadamard门并测量，如果测量结果为1则继续该过程，测量结果为0则退出循环。这表明测量得到1的次数，每次都有1/2的概率，给定计数器n+1，最终可以取得n的值。重复这个实验，可以拟合出一个负指数分布。

\sphinxAtStartPar
  另外，QIf和QWhile是可以相互嵌套的，形成多层的控制流。

\sphinxAtStartPar
\sphinxstylestrong{l 基于量子信息的IF和WHILE}

\sphinxAtStartPar
  上述的是“量子信息，经典控制”，那么有没有“量子信息，量子控制”呢？对于IF而言，答案是有的。

\sphinxAtStartPar
  定义“量子信息，量子控制”过程是一组量子比特的操作，是由另一组比特的值决定的。一个最简单的例子就是 \(CNOT\) 门，对于 \(CNOT(q0,q1)\) 而言，q1是否执行NOT门是由q0的值决定的。基于量子信息的IF的性质如下：

\sphinxAtStartPar
  第一，这种控制可以叠加。如果判断变量本身处于叠加态，那么操作的比特也会出现执行/不执行逻辑门的两种分支，由此，判断变量和操作比特之间会形成纠缠态。例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}  \PYG{n}{H} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{q1}
\PYG{l+m+mf}{2.}  \PYG{n}{CNOT} \PYG{n}{q1} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{q2}
\end{sphinxVerbatim}

\sphinxAtStartPar
  此时得到的量子态是 \(|00\rangle+|11\rangle\) ，这样在 \(CNOT\) 后，就把q1这个判断变量和q2这个操作比特纠缠了起来。

\sphinxAtStartPar
  第二，控制变量和操作比特之间不能共享比特。即， \(CNOT(q0,q1)\) 中控制位和目标位一定不能为相同的量子比特。

\sphinxAtStartPar
  基于量子信息的IF在实际的量子算法中使用得比较少，因此大部分量子软件开发包都没有加入这个功能。在Shor算法和其他基于布尔运算的线路中会使用这个思想，比如对是否求模的判断，但实际中，一般是利用 \(CNOT\) 门的组合来实现的。

\sphinxAtStartPar
  对于WHILE而言，目前还没有找到一个合适的定义，因为量子信息不确定，那么很有可能会在WHILE中产生无法停机的分支。以经典控制的QWhile作为例子，如果控制变量c是一个量子比特，那么每次都会有一个概率使得这个循环继续下去。因此，为了执行这个序列，就需要无限长的操作序列，这导致从物理上无法定义这种操作。

\sphinxstepscope


\section{3.1 量子芯片}
\label{\detokenize{rst/3.1_u91cf_u5b50_u82af_u7247:id1}}\label{\detokenize{rst/3.1_u91cf_u5b50_u82af_u7247::doc}}

\subsection{3.1.1 超导量子芯片}
\label{\detokenize{rst/3.1_u91cf_u5b50_u82af_u7247:id2}}
\sphinxAtStartPar
  超导量子计算是基于超导电路的量子计算方案，其核心器件是超导约瑟夫森结。超导量子电路在设计、制备和测量等方面，与现有的集成电路技术具有较高的兼容性，对量子比特的能级与耦合可以实现非常灵活的设计与控制，极具规模化的潜力。

\sphinxAtStartPar
  由于近年来的迅速发展，超导量子计算已成为目前最有希望实现通用量子计算的候选方案之一。超导量子计算实验点致力于构建一个多比特超导量子计算架构平台，解决超导量子计算规模化量产中遇到的难题。

\sphinxAtStartPar
  如图3.1.1（a），超导电路类似于传统的电子谐振电路，这种谐振电路产生了谐振子的能级。超导约瑟夫森效应使得超导电路在不发生损耗和退相干的情况下产生非线性，非线性导致谐振子的能级间隔不再等同，其中最低的两个能级可以用来实现量子比特的操控，如图3.1.1（b）所示。与经典谐振电路不同的是，超导电路还含有由约瑟夫森结带来的电感Lj这一项，改变这一项和电感L、电容C的比值，物理学家提出了多种基于超导线路的比特形式，如图3.1.1（c）{[}6{]}。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.1}.png}\hspace*{\fill}}

\begin{center}图3.1.1超导电路构成量子比特{[}2{]}（a）超导量子比特的等效电路模型（b）超导量子比特的能级（c）不同种类的超导量子比特（Cooper pair box\sphinxhyphen{}库珀对盒，Quantronium/fluxonium/transmon\sphinxhyphen{}一种量子比特装置，不需要翻译，Flux qubit\sphinxhyphen{}磁通量子比特，Phase qubit\sphinxhyphen{}相位量子比特，Hybrid qubit\sphinxhyphen{}混合量子比特）
\end{center}
\sphinxAtStartPar
  超导量子计算的研究始于2000年前后，后来在美国耶鲁大学Schoelkopf和Devoret研究组的推动下，将超导比特和微波腔进行耦合，实现了量子比特高保真度的读出和纠缠，加速了超导量子比特的研究。微波腔是一种容纳微波光子的谐振腔，比特的两个能级会对微波腔的光子产生扰动，这一信号的扰动就可以用来实现比特信号的读出。比特和比特之间还可以通过微波腔相连，当两个比特和腔是强耦合状态的时候，两个比特就会通过腔发生相互作用，物理学家通过这一相互作用实现了两比特操作。在2009年，基于超导比特和腔的耦合，实现了两比特的高保真度量子算法，使得超导量子计算得到了世界的广泛关注{[}3{]}。

\sphinxAtStartPar
  从2014年开始，美国企业界开始关注超导量子比特的研究，并加入了研究的大潮中。2014年9月，美国Google公司与美国加州大学圣芭芭拉分校合作研究超导量子比特，使用X\sphinxhyphen{}mon形式的超导量子比特，如图3.1.2（a）所示为一个9比特芯片，这个超导芯片的单比特和两比特保真度均可以超过99\%，在X\sphinxhyphen{}mon结构中，近邻的两个比特（两个十字）可以直接发生相互作用{[}4{]}。2016年基于这个芯片实现了对氢分子能量的模拟，表明了其对于量子计算商用化的决心{[}5{]}。

\sphinxAtStartPar
  2017年，Google发布了实现量子计算机对经典计算机的超越——“量子霸权”的发展蓝图{[}6{]}。2018年年初，其设计了72比特的量子芯片，并着手进行制备和测量，这是向实现量子霸权迈出的第一步。在Google公司加入量子计算大战的同时，美国国际商用机器有限公司（IBM）于2016年5月在云平台上发布了他们的五比特量子芯片，如图3.1.2（b）所示，这种比特形式叫做Transmon，Transmon的单比特保真度可以超过99\%，两比特保真度可以超过95\%，在Transmon的结构中，比特和比特之间仍然用腔连接，使得其布线方式和X\sphinxhyphen{}mon相比更加自由。

\sphinxAtStartPar
  2017年，IBM制备了20比特的芯片，并展示了用于50比特芯片的测量设备，同时也公布了对BeH2分子能量的模拟，表明了在量子计算的研究上紧随Google的步伐{[}7{]}，不仅如此，IBM还发布了QISKit的量子软件包，促进了人们通过经典编程语言实现对量子计算机的操控。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.2}.png}\hspace*{\fill}}

\begin{center}图3.1.2不同公司的超导量子芯片（a）Google的九比特芯片（b）IBM的五比特芯片 （c）Rigetti公司的19比特芯片（d）本源量子公司的6比特芯片{[}4,7,8{]}（measurement\sphinxhyphen{}测量，Qubits\sphinxhyphen{}量子比特，control\sphinxhyphen{}控制）
\end{center}
\sphinxAtStartPar
  除了美国Google公司和IBM公司外，美国Intel公司和荷兰代尔夫特理工大学也合作设计了17比特和49比特超导量子芯片，并在2018年的CES大会上发布，不过具体的性能参数还有待测试；美国初创公司Rigetti发布了19比特超导量子芯片，并演示了无人监督的机器学习算法，使人们见到了利用量子计算机加速机器学习的曙光{[}8{]}，如图3.1.2（c）所示。美国微软公司开发了Quantum Development Kit量子计算软件包，通过传统的软件产品Visual Studio就可以进行量子程序的编写。

\sphinxAtStartPar
  在国内，2017年，中国科学技术大学潘建伟研究组实现了多达十个超导比特的纠缠{[}9{]}，2018年年初，中科院和阿里云联合发布了11位量子比特芯片，保真度和Google的芯片不相上下，表明了我国在超导量子计算方面也不甘落后，并迎头赶上，同时，合肥本源量子公司也正在开发6比特高保真度量子芯片，如图3.1.2（d）所示。南京大学和浙江大学也对超导量子比特进行了卓有成效的研究{[}10, 11{]}。在超导量子计算方面，可谓是国内国外百花齐放，百家争鸣。


\subsection{3.1.2 半导体量子芯片}
\label{\detokenize{rst/3.1_u91cf_u5b50_u82af_u7247:id3}}
\sphinxAtStartPar
  由于经典计算机主要基于半导体技术，基于半导体开发量子计算也是物理学家研究的重点领域。相比超导量子计算微米级别的比特大小，量子点量子比特所占的空间是纳米级别，类似于大规模集成电路一样，更有希望实现大规模的量子芯片。现在的主要方法是在硅或者砷化镓等半导体材料上制备门控量子点来编码量子比特。编码量子比特的方案多种多样，在半导体系统中主要是通过对电子的电荷或者自旋量子态的控制实现。

\sphinxAtStartPar
  基于电荷位置的量子比特如图3.1.3所示，这是中国科学技术大学郭国平研究组利用GaAs/AlGaAs异质结制备的三电荷量子比特的样品，图中Q1、Q2和Q3作为探测器可以探测由U、L电极形成的量子点中电荷的状态，六个圆圈代表六个量子点，每种颜色代表一个电荷量子比特。以两个黄圈为例，当电子处于右边量子点中时，它处于量子比特的基态，代表0；当电子处于左边量子点时，它处于量子比特的激发态，代表1。这三个比特的相互作用可以通过量子点之间的电极调节，因而可以用来形成三比特控制操作{[}12{]}，不过这种三比特操作的保真度较低，提高保真度需要进一步抑制电荷噪声。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.3}.png}\hspace*{\fill}}

\begin{center}图3.1.3 中国科学技术大学郭国平研究组研制的三电荷量子比特半导体芯片{[}12{]}
\end{center}
\sphinxAtStartPar
  基于自旋的量子比特如图3.1.4（a）所示，这是美国普林斯顿大学Petta研究组基于Si/SiGe异质结制备的两自旋量子比特芯片，图3.1.4(a)中带箭头的圆圈代表不同自旋方向的电子，自旋在磁场下劈裂产生的两个能级可以用于编码量子比特。这两个量子比特之间的耦合可以通过中间的电极M进行控制，实现两比特操作{[}13{]}。由于对电荷噪声有较高的免疫效果，自旋量子比特的退相干时间非常长，2014年，澳大利亚新南威尔士大学Morello研究组的实验结果显示自旋的退相干时间可以长达30秒，可以用来制备超高保真度的量子比特{[}14{]}。截止到2018年年初，已经有包括澳大利亚新南威尔士大学Dzurak组、美国普林斯顿大学Petta组和荷兰代尔夫特大学Vandersypen组实现了半导体自旋量子比特的两比特操控{[}13, 15\sphinxhyphen{}16{]}，其单量子比特操控保真度已经可以超过99\%，两比特操控保真度可以达到80\%左右。2017年，日本Tarucha研究组报道了保真度达到99.9\%的单量子比特，证明了自旋量子比特的超高保真度{[}17{]}。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.4}.png}\hspace*{\fill}}

\begin{center}图3.1.4 不同研究组的两自旋量子比特半导体芯片（a）美国普林斯顿大学Petta研究组（b）澳大利亚新南威尔士大学Dzurak组（c）荷兰代尔夫特理工大学Vandersypen组{[}13, 15\sphinxhyphen{}16{]}（Bext\sphinxhyphen{}外磁场，Qubits\sphinxhyphen{}量子比特，Charge sensor\sphinxhyphen{}电荷探测器，Al203\sphinxhyphen{}氧化铝，Si\sphinxhyphen{}硅，SiGe\sphinxhyphen{}硅锗，Bz\sphinxhyphen{}垂直磁场，Co micromagnet\sphinxhyphen{}钴微磁体，Depletion gate\sphinxhyphen{}耗尽电极，Accumulation gate\sphinxhyphen{}汇聚电极）
\end{center}
\sphinxAtStartPar
  与超导量子计算类似，半导体量子计算也正在从科研界转向工业界，2016年，美国芯片巨头Intel公司开始投资代尔夫特理工大学的硅基量子计算研究，目标是在五年内制备出第一个二维表面码结构下的逻辑量子比特；2017年，澳大利亚也组建了硅量子计算公司，目标是五年内制备出第一台10比特硅基量子计算机。

\sphinxAtStartPar
  在国内，中国科学技术大学的郭国平研究组在传统的GaAs基量子比特方面积累了成熟的技术，实现了多达3个电荷量子比特的操控和读出，并基于电荷量子比特制备了品质因子更高的杂化量子比特{[}12, 18\sphinxhyphen{}20{]}，同时，该组从2016年开启了硅基量子比特计划，计划五年内制备出硅基高保真度的两比特量子逻辑门，实现对国际水平的追赶，并为进一步的超越做准备。


\subsection{3.1.3 其他类型体系的量子计算体系}
\label{\detokenize{rst/3.1_u91cf_u5b50_u82af_u7247:id4}}
\sphinxAtStartPar
\sphinxstylestrong{1. 离子阱量子计算}

\sphinxAtStartPar
  离子阱量子计算在影响范围方面仅次于超导量子计算。早在2003年，基于离子阱就可以演示两比特量子算法{[}21{]}。离子阱编码量子比特主要是利用真空腔中的电场囚禁少数离子，并通过激光冷却这些囚禁的离子{[}22{]}。以囚禁Yb+为例，图3.1.5（a）是离子阱装置图，20个Yb+连成一排，每一个离子在超精细相互作用下产生的两个能级作为量子比特的两个能级，标记为|↑>和|↓>。图3.1.5（b）表示通过合适的激光可以将离子调节到基态，然后图3.1.5（c）表示可以通过观察荧光来探测比特是否处于|↑>。离子阱的读出和初始化效率可以接近100\%，这是它超过前两种比特形式的优势。单比特的操控可以通过加入满足比特两个能级差的频率的激光实现，两比特操控可以通过调节离子之间的库伦相互作用实现。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.5}.png}\hspace*{\fill}}

\begin{center}图3.1.5 （a）离子阱装置（b）比特初始化（c）通过荧光探测测量比特状态{[}19{]}
\end{center}
\sphinxAtStartPar
  2016年，美国马里兰大学C. Monroe组基于离子阱制备了五比特可编程量子计算机，其单比特和两比特的操作保真度平均可以达到98\%，运行Deutsch–Jozsa算法的保真度可以达到95\%{[}23{]}。他们还进一步将离子阱的五比特量子芯片和IBM的五比特超导芯片在性能方面进行了比较，发现离子阱量子计算的保真度和比特的相干时间更长，而超导芯片的速度更快。在比特扩展方面，两者都有一定的难度，不过在20\sphinxhyphen{}100个比特这个数目内，两者现在可能都有一定的突破{[}24{]}。除了量子计算，离子阱还能用来进行量子模拟，如图3.1.6所示。2017年，C. Monroe组使用了53个离子实现了多体相互作用相位跃迁的观测，读出效率高达99\%，是迄今为止比特数目最多的高读出效率量子模拟器{[}25{]}。虽然不能单独控制单个比特的操作，但是这也证明了离子阱量子计算的巨大潜力。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.6}.png}\hspace*{\fill}}

\begin{center}图3.1.6利用53个离子实现多体相互作用观测的量子模拟器示意图{[}25{]}（Initialize spins\sphinxhyphen{}初始自旋状态，measurement\sphinxhyphen{}测量，magnetization\sphinxhyphen{}磁化，time\sphinxhyphen{}时间，Quantum quench\sphinxhyphen{}量子退火， Camera\sphinxhyphen{}相机）
\end{center}
\sphinxAtStartPar
  对于两比特操控速度问题，这一直是限制离子阱量子计算发展的主要因素。两比特门操作速度最快也需要100 us，远远高于超导量子比特和半导体量子比特的200 ns。2018年，牛津大学的Lucas组通过改进激光脉冲，达到了最快480 ns的操作速度，展现了离子阱量子计算的丰富前景{[}26{]}。

\sphinxAtStartPar
  2015年，马里兰大学和杜克大学联合成立了IonQ量子计算公司，2017年7月，该公司获得两千万美元的融资，计划在2018年将自己的量子计算机推向市场，这是继超导量子计算之后第二个能够面向公众的商用量子计算体系。

\sphinxAtStartPar
  国内的离子阱量子计算也于近几年发展起来。清华大学的金奇奂研究组和中国科学技术大学的李传锋、黄运峰研究组已经实现了对一个离子的操控，做了一些量子模拟方面的工作{[}27, 28{]}。清华大学计划在五年内实现单个离子阱中15\sphinxhyphen{}20个离子的相干操控，演示量子算法，说明中国也已经加入到了离子阱量子计算的竞赛中。

\sphinxAtStartPar
\sphinxstylestrong{2. 原子量子计算}

\sphinxAtStartPar
  除了利用离子，较早的方法还包括直接利用原子来进行量子计算。不同于离子，原子不带电，原子之间没有库伦相互作用，因此可以非常紧密地连在一起而不相互影响。原子可以通过磁场或者光场来囚禁，用后者可以形成一维、二维甚至三维的原子阵列，如图3.1.7所示{[}29{]}。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps496}.jpg}\hspace*{\fill}}

\begin{center}图3.1.7用光场囚禁的多原子阵列（a）一维阵列（b）二维阵列（c）三维阵列{[}29{]}
\end{center}
\sphinxAtStartPar
  原子可以通过边带冷却的方式冷却到基态，然后同样可以通过激光对比特进行操控，比特的读出也类似于离子阱的方法。由于没有库伦相互作用，两比特操控在原子中较难实现，它们必须首先被激发到里德堡态，原子的能量升高，波函数展宽，再通过里德堡阻塞机制实现两比特操控。尽管迄今为止，原子量子比特的两比特纠缠的保真度只有75\%，还远远落后于离子阱和超导比特，但是2016年一篇论文中，通过理论计算，经过波形修饰的两个原子量子比特的纠缠保真度可以达到99.99\%{[}30{]}。

\sphinxAtStartPar
  除了传统的基于量子逻辑门进行量子计算的方法，还有一种实现量子计算的方式是对不同拓扑结构的量子纠缠态进行测量，这两种方法在解决问题的范围上是等价的。在这方面，中国科学技术大学的潘建伟研究组进行了卓有成果的研究，2016年实现了600对量子比特的纠缠，纠缠保真度在79\%左右{[}31{]}，根据下一步计划，将基于成对的量子比特纠缠实现约百个量子比特集体的纠缠，开展基于测量的量子计算方法。

\sphinxAtStartPar
  基于原子的量子模拟可能比量子计算更加受到科研界的关注。利用光晶格中的原子，可以研究强关联多体系统中的诸多物理问题，比如玻色子的超流态到Mott绝缘体的相变和费米子的Fermi\sphinxhyphen{}Hubbard模型，经典磁性（铁磁、反铁磁和自旋阻挫），拓扑结构或者自旋依赖的能带结构以及BCS\sphinxhyphen{}BEC交叉等问题。现在聚焦的主要是量子磁性问题、量子力学中的非平衡演化问题和无序问题{[}32{]}。在基于原子的量子模拟方面，2017年哈佛大学Lukin组甚至利用51个原子对多体相互作用的动态相变进行了模拟{[}33{]}。我国在2016年，中国科学技术大学的潘建伟研究组对玻色\sphinxhyphen{}爱因斯坦凝聚态的二维自旋\sphinxhyphen{}轨道耦合进行了模拟，为研究新奇的量子相打开了大门{[}34{]}。

\sphinxAtStartPar
\sphinxstylestrong{3. 核自旋量子计算}

\sphinxAtStartPar
  1997年，斯坦福大学的Chuang等人提出利用核磁共振来进行量子计算的实验{[}35{]}，之后，基于核自旋的量子计算迅速发展，Grover搜索算法{[}36{]}和七比特Shor算法{[}37{]}相继在核自旋上实现。迄今为止，它的单比特和两比特保真度可以分别达到99.97\%和99.5\%{[}38{]}。

\sphinxAtStartPar
  这种方法一般是利用液体中分子的核自旋进行实验，由于分子内部电子间复杂的排斥作用，不同的核自旋具有不同的共振频率，因而可以被单独操控；不同的核自旋通过电子间接发生相互作用，可以进行两比特操作。下图是一种用于核磁共振实验的分子，里面的两个C原子用13C标记，加上外面5个F原子，它们7个构成实验用的7个比特，表中是比特频率、相干时间和相互作用能。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.8}.png}\hspace*{\fill}}

\begin{center}图3.1.8用于Shor算法的核磁共振实验的分子结构及相关参数{[}37{]}
\end{center}
\sphinxAtStartPar
  不过这种量子计算方式依赖于分子结构，难以扩展；而且是利用多个分子的集体效应进行操控，初始化比较有难度，该方向还有待进一步的突破。国内从事核自旋量子计算实验的主要有清华大学的龙桂鲁课题组，2017年，该课题组将核自旋量子计算连接到云端，向公众开放使用，该云服务包含四个量子比特，比特保真度超过98\%。

\sphinxAtStartPar
\sphinxstylestrong{4. 拓扑量子计算}

\sphinxAtStartPar
  拓扑量子计算是一种被认为对噪声有极大免疫的量子计算形式，它利用的是一种叫做非阿贝尔任意子的准粒子{[}39{]}。为了实现量子计算，首先要在某种系统中创造出一系列任意子\sphinxhyphen{}反任意子，然后将这些任意子的两种熔接（fusion）结果作为量子比特的两个能级，再利用编织（braiding）进行量子比特的操控，最后通过测量任意子的熔接结果得到比特的末态。这一系列操作对噪声和退相干都有极大地免疫，因为唯一改变量子态的机制就是随机产生的任意子\sphinxhyphen{}反任意子对干扰了比特的编织过程，但这种情况在低温下是非常罕见的，噪声和其他量子比特系统常见的电荷等相比，影响是非常小的。

\sphinxAtStartPar
  现在国际上进行拓扑量子计算研究的实验组主要是荷兰代尔夫特理工大学的Kouwenhoven研究组和丹麦哥本哈根大学的Marcus研究组。研究组在实验中获得任意子的方法就是得到马约拉纳费米子，当s波超导体和一条具有强烈自旋\sphinxhyphen{}轨道耦合效应的半导体纳米线耦合在一起时，在纳米线的两端就可以产生马约拉纳费米子，实验中可以观察到马约拉纳费米子引起的电导尖峰，当这些纳米线可以很好地外延生长成阵列时，就可以进行比特实验。从2012年首次在半导体\sphinxhyphen{}超导体异质结中观察到马约拉纳零模的特征开始{[}40{]}，到2018年观察到量子化的电导平台{[}41{]}，Kouwenhoven研究组的实验已经让大多数科学家认同了可以在这种体系中产生马约拉纳费米子，不仅如此，进行拓扑量子计算的Al\sphinxhyphen{}InSb和Al\sphinxhyphen{}InP两种半导体\sphinxhyphen{}超导体耦合的纳米线阵列已经先后在实验中实现{[}42, 43{]}。未来将尝试进行编织实验，实现世界上第一个拓扑量子比特。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.1.9}.png}\hspace*{\fill}}

\begin{center}图3.1.9（a）观察马约拉纳费米子的器件结构（b）实验观察到的量子化电导平台（c）InSb纳米线阵列（d）Al\sphinxhyphen{}InSb异质结{[}41,42{]}（Experiment\sphinxhyphen{}实验，Super\sphinxhyphen{}gate\sphinxhyphen{}超级电极，Tunnel\sphinxhyphen{}gate\sphinxhyphen{}隧穿电极，Back\sphinxhyphen{}gate\sphinxhyphen{}背栅电极，InSb\sphinxhyphen{}铟锑，Al\sphinxhyphen{}铝）
\end{center}
\sphinxAtStartPar
  除了利用半导体\sphinxhyphen{}超导体异质结可以得到马约拉纳费米子，其他获得的方式还包括量子霍尔效应、分数量子霍尔效应、二维无自旋超导体和超导体上的铁磁原子链。最近在量子反常霍尔绝缘体\sphinxhyphen{}超导结构中发现的一维马约拉纳模式也被认为可以用于拓扑量子计算{[}44{]}，但是基于马约拉纳费米子进行的拓扑量子计算仍然不能满足单比特任意的旋转，它仍然需要和其他形式的量子比特互补或者通过某种方法进行近似的量子操作，不过，对高质量量子比特的追求仍然推动着科学家研究拓扑量子比特。

\sphinxAtStartPar
  不同于其他美国巨头公司，微软公司在量子计算方面押注在拓扑量子计算，认为现在量子比特的噪声仍然太大，发明一种保真度更高的量子比特将有助于量子比特的高质量扩展，进而更容易实现量子计算。其与荷兰代尔夫特理工大学、丹麦哥本哈根大学、瑞士苏黎世理工大学、美国加州大学圣芭芭拉分校、普渡大学和马里兰大学在实验和理论上展开了广泛的合作，目标是五年内制备出世界上第一个拓扑量子比特，其拓扑保护的时间可长达一秒。中国在拓扑量子计算方面也开始发力，2017年12月1日，中国科学院拓扑量子计算卓越创新中心在中国科学院大学启动筹建，国科大卡弗里理论科学研究所所长张富春任中心负责人。未来几年可能是中国拓扑量子计算的高速发展期。

\sphinxAtStartPar
  从目前量子计算的发展脉络来看，各种体系有先有后，有的量子计算方式现在已经让其他方式望尘莫及；有的量子计算方式还有关键技术亟待突破；也有的量子计算方式正在萌芽之中。就像群雄逐鹿中原，鹿死谁手，尚未可知。有观点认为，未来量子计算机的实现可能是多种途径混合的，比如利用半导体量子比特的长相干时间做量子存储，超导量子比特的高保真操控和快速读出做计算等等；也有观点认为，根据不同的量子计算用途，可能使用不同的量子计算方法，就像CPU更适合任务多而数据少的日常处理，而GPU更适合图像处理这种单一任务但数据量大的处理。无论未来的量子计算发展情况如何，中国在各个量子计算方式上都进行了跟随式研究，这是我国现有的技术发展水平和国家实力的体现。随着国家对相关科研的进一步投入，相信未来在量子计算的实现方面，也可以领先于世界其他国家，实现弯道超车。

\sphinxstepscope


\section{3.2 量子计算机硬件}
\label{\detokenize{rst/3.2_u91cf_u5b50_u8ba1_u7b97_u786c_u4ef6:id1}}\label{\detokenize{rst/3.2_u91cf_u5b50_u8ba1_u7b97_u786c_u4ef6::doc}}
\sphinxAtStartPar
  由上一章节知道，量子计算机的核心——量子芯片，具有多种不同的呈现形式。绝大多数量子芯片，名副其实地，是一块芯片，由集成在基片表面的电路结构构建出包含各类量子比特的量子电路。但量子芯片不等同于量子计算机，它仅仅是量子计算机中的一个核心结构。

\sphinxAtStartPar
  量子计算机，是建立在量子芯片基础上的运算机器。其中最关键的两点是：如何将运算任务转化为对量子芯片中量子比特的控制指令；以及如何从量子芯片上量子比特的量子态中提取出运算结果。除此以外，更加基础地，量子计算机需要提供能维持量子芯片运行的基本环境。以上这些都需要特殊的硬件系统来实现，它们实现了量子计算机软件层到量子计算机芯片层的交互。

\sphinxAtStartPar
  量子计算机硬件，主要包含两个部分，一个是量子芯片支持系统，用于提供量子芯片所必需的运行环境；另一个是量子计算机控制系统，用于实现对量子芯片的控制，以完成运算过程并获得运算结果。鉴于目前国际主流量子计算研发团队主要聚焦超导量子芯片与半导体量子芯片这两种体系，同时它们的量子计算机硬件有相当多的共性，因此以下将具体展开介绍这两种体系适用的量子计算机硬件。


\subsection{3.2.1 量子芯片支持系统}
\label{\detokenize{rst/3.2_u91cf_u5b50_u8ba1_u7b97_u786c_u4ef6:id2}}
\sphinxAtStartPar
  超导量子芯片和半导体量子芯片对运行环境的需求类似，最基本的需求均为接近绝对零度的极低温环境。其主要原因在于两种体系的量子比特的能级接近，基本上都在GHz频段。该频段内的热噪声对应的噪声温度约在300 mK以上。为了抑制环境噪声，必须使量子芯片工作在远低于其能级对应的热噪声温度。稀释制冷机能够提供量子芯片所需的工作温度和环境。利用3He/4He混合气实现稀释致冷，稀释制冷机能够将量子芯片冷却到10 mK以下的极低温。在2018年IBM’s inaugural Index 开发者大会上，IBM展示的“50位量子计算机原型机”，实际上就是维持50位量子芯片运行的稀释制冷机以及其内部的线路构造。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps499}.png}\hspace*{\fill}}

\begin{center}图3.2.1 IBM的稀释制冷机，用于容纳50位量子芯片
\end{center}
\sphinxAtStartPar
  图3.2.1展示了IBM的稀释制冷机。除了稀释制冷机本身以外，量子计算研究人员需要花费大量精力设计、改造、优化稀释制冷机内部的控制线路与屏蔽装置，以全面地抑制可能造成量子芯片性能下降的噪声因素。其中最主要的三点是热噪声、环境电磁辐射噪声以及控制线路带来的噪声。

\sphinxAtStartPar
  抑制热噪声的主要方式，是在稀释制冷机的基础上，为量子芯片设计能迅速带走热量的热沉装置，该装置需要兼容量子芯片的封装。图3.2.2是包含多种热沉结构的量子芯片封装照片，包含半导体量子芯片以及超导量子芯片，其中热沉主要使用了无氧紫铜材料。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps500}.jpg}\hspace*{\fill}}

\begin{center}图3.2.2 量子芯片的热沉与封装{[}45{]}
\end{center}
\sphinxAtStartPar
  环境电磁辐射噪声是较难控制的环境干扰，其中又可以分为电场辐射以及磁场辐射。电场辐射主要产生来源是稀释制冷机中更高温层的红外辐射，其频段和量子比特的能级相仿，因此会加速量子比特的弛豫过程，从而降低量子芯片的性能。磁场辐射来源复杂，诸如地磁场、带磁元件的剩磁、控制电流引发的磁场等，它们会干扰量子比特的能级，破坏量子芯片的相干时间。可工作于极低温环境的电磁屏蔽技术，一直是伴着量子计算研究人员的需求发展的。图3.2.3展示了伯克利大学Sidiqqi研究组使用的一种红外辐射屏蔽技术。他们设计了用于包裹量子芯片的屏蔽桶，并在桶的内壁使用了一种黑色的特殊涂层，用于增强对红外辐射的吸收。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps501}.jpg}\hspace*{\fill}}

\begin{center}图3.2.3 红外辐射屏蔽装置
\end{center}
\sphinxAtStartPar
  控制线路携带的噪声，主要也是由热效应引起的。由于量子芯片工作环境的特殊性，从量子计算机控制系统发出的控制信号，要从稀释制冷机接入，经过漫长的低温线路，最后到达量子芯片。而热噪声近似和温度成正比，可想而知，从室温（约300 K）传入的噪声，相比前面所说的量子比特能级对应的噪声温度（月300 mK）相差了近1000倍。这么大的噪声如果直接到达维持在10 mK温度的量子芯片，则会直接破坏量子比特的量子相干性。解决办法是尽可能地抑制从室温传入的信号，使从室温传入的噪声降至和量子芯片的工作温度一个级别。同时，我们还要设法将除了控制信号以外的其他所有频段的无关信号一并滤除，而这，则是通过各类特种低温滤波器实现的。图3.2.4是适用于超导量子芯片的量子芯片支持系统中极低温控制线路的设置。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.2.4}.png}\hspace*{\fill}}

\begin{center}图 3.2.4 量子芯片支持系统中极低温控制线路的设置{[}46{]} （Flux offset source\sphinxhyphen{}磁通偏置源，Flux pulse source\sphinxhyphen{}磁通脉冲源，Qubit drive source\sphinxhyphen{}量子比特驱动源，Readout source\sphinxhyphen{}测量源，Readout detection\sphinxhyphen{}测量探测RC filter\sphinxhyphen{}RC滤波器，Cu powder\sphinxhyphen{}铜粉滤波器，LPF\sphinxhyphen{}低通滤波器，Bias\sphinxhyphen{}tee\sphinxhyphen{}一种电阻器件，XY\sphinxhyphen{}control\sphinxhyphen{}XY控制线，Z\sphinxhyphen{}control\sphinxhyphen{}Z控制线，Readout in\sphinxhyphen{}测量输入，Readout out\sphinxhyphen{}测量输出，Circulator\sphinxhyphen{}环形器，J\sphinxhyphen{}Amp\sphinxhyphen{}约瑟夫森量子参量放大器，HEMT\sphinxhyphen{}高电子迁移率放大器，Package\sphinxhyphen{}封装，Shield\sphinxhyphen{}屏蔽，Superconducting quantum chip\sphinxhyphen{}超导量子芯片）
\end{center}

\subsection{3.2.2 量子计算机控制系统}
\label{\detokenize{rst/3.2_u91cf_u5b50_u8ba1_u7b97_u786c_u4ef6:id3}}
\sphinxAtStartPar
  量子计算机控制系统提供的是以下两个关键问题的解决方案：如何将运算任务转化为对量子芯片中量子比特的控制指令；以及如何从量子芯片上量子比特的量子态中提取出运算结果。其背后的基础是，如何实施量子逻辑门操作，以及如何实施量子比特读取。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.2.5}.png}\hspace*{\fill}}

\begin{center}图3.2.5 量子计算机控制系统工作原理
\end{center}
\sphinxAtStartPar
  量子逻辑门操作的本质是使一组量子比特经过指定的受控量子演化过程。例如，使得量子比特从基态（或者称 \(|0 \rangle\) 态）到激发态（或者称 \(|1 \rangle\) 态），可以借助一个单量子比特π门来实现。实施这样的受控量子演化过程，需要借助精密的脉冲信号，通常可以使用高速任意波形发生器、商用微波源、混频线路等的组合来实现。当然，通过对光场、磁场甚至机械声波的调控，也可以在某些量子芯片体系中实现量子逻辑门操作。商用设备的性能越高，越容易实现高保真度的量子逻辑门操作，当然，前提是量子比特的质量可靠。图3.2.6显示了商用仪器的相噪指标对操作保真度的影响。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.2.6}.png}\hspace*{\fill}}

\begin{center}图3.2.6 微波源相位噪声对操作保真度的影响{[}47{]}
\end{center}
\sphinxAtStartPar
  量子态的读取有多种方式，但考虑到需要读取量子芯片中某个或者某组量子比特的量子态，必须要使用一种称之为非破坏性测量的方式，以消除因测量导致的反作用。通常的方法是在量子比特结构旁边额外设计一个对量子态敏感的探测器，间接地通过探测探测器的响应来推测量子比特的量子态。图3.2.7是一个半导体量子芯片以及其探测器结构，该探测器为一个RF探测器，通过该探测器的指定频率的微波信号会随着半导体量子芯片中电子状态变化，进而能从RF探测器的信号中计算出量子比特的量子态变化。捕获RF探测器的信号的装置通常为网络分析仪或者高速数字采集卡。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.2.7}.png}\hspace*{\fill}}

\begin{center}图3.2.7 半导体量子芯片以及RF探测器（QPC\sphinxhyphen{}量子点接触，量子比特的电学测量通道，Nb\sphinxhyphen{}铌，Sapphire\sphinxhyphen{}蓝宝石，Bias\sphinxhyphen{}tee\sphinxhyphen{}一种名为bias\sphinxhyphen{}tee的电学器件，L/LP/C/RP/R/N\sphinxhyphen{}图中各个电极的编号，不需要翻译，Dc\sphinxhyphen{}直流，L\sphinxhyphen{}电感，Cp\sphinxhyphen{}下标为p的电容）
\end{center}
\sphinxAtStartPar
  随着量子芯片集成度的提高，纯粹采用商用仪器搭建量子芯片的控制与读取系统的方法的弊端越来越大。商用仪器成本昂贵，功能冗余，兼容性差，难以集成，并不满足未来量子计算机的发展需要。为量子计算机专门设计并研制适用的量子计算机控制系统，是明智的选择。目前，量子计算机控制系统的研究刚刚起步不久。2016年，苏黎世仪器公司与代尔夫特理工大学研究团队成立的QuTech公司合作，研制了一套可用于7位超导量子芯片工作的集成量子芯片测控系统，包含最高可扩展至64通道的AWG以及同步的高速ADC采集通道。2017年底，是德科技自主研发了一套100通道的量子芯片测控系统，具备百ps级系统同步性能与百ns级量子芯片信号实时处理能力，最高可用于20位超导量子芯片完整运行。2018年，合肥本源量子计算科技有限责任公司也研制出40通道的量子芯片测控系统，可以应用于8位超导量子芯片或者2位半导体量子芯片，这是国内第一套完整的量子计算机控制系统。除此之外，加州大学\sphinxhyphen{}圣塔芭芭拉分校、苏黎世理工学院、中国科学技术大学合肥微尺度物质科学国家实验室、Raytheon BBN Technologies公司等都有自主研发的量子计算机控制系统或者模块。为了降低功耗，提高信号质量，代尔夫特理工大学和悉尼大学的研究团队开展了4K到100mK温度的极低温量子计算机控制系统的研究。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps508}.jpg}\hspace*{\fill}}

\begin{center}图3.2.8 本源量子研制的量子计算机控制系统
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.2.9}.png}\hspace*{\fill}}

\begin{center}图3.2.9 极低温量子计算机控制系统设计概念图{[}48{]}（Prime waveform\sphinxhyphen{}模拟信号波形，Readout carrier\sphinxhyphen{}读取载波，Digital\sphinxhyphen{}数字信号，Dc\sphinxhyphen{}直流，Waveform generator\sphinxhyphen{}波形发生器，Prime\sphinxhyphen{}line bus\sphinxhyphen{}模拟信号总线，Address\sphinxhyphen{}line bus\sphinxhyphen{}地址信号总线，ADC\sphinxhyphen{}模数转换器，Amplifier\sphinxhyphen{}放大器，Coupler\sphinxhyphen{}耦合器，Multiplexing\sphinxhyphen{}混合器，Switch matrix\sphinxhyphen{}开关阵列，Qubits\sphinxhyphen{}量子比特，Pulsing\sphinxhyphen{}实施脉冲，Biasing\sphinxhyphen{}实施偏置，Multi\sphinxhyphen{}channel DAC\sphinxhyphen{}多通道数模转换器，Dilution fridgerator\sphinxhyphen{}稀释制冷机，Programming\sphinxhyphen{}编程，300K/4K/20mK\sphinxhyphen{}开尔文制温度，Clock\sphinxhyphen{}时钟信号，Logic\sphinxhyphen{}逻辑处理器）
\end{center}
\sphinxstepscope


\section{3.3 量子计算机}
\label{\detokenize{rst/3.3_u91cf_u5b50_u8ba1_u7b97_u673a:id1}}\label{\detokenize{rst/3.3_u91cf_u5b50_u8ba1_u7b97_u673a::doc}}

\subsection{3.3.1 量子计算机整体架构}
\label{\detokenize{rst/3.3_u91cf_u5b50_u8ba1_u7b97_u673a:id2}}
\sphinxAtStartPar
\sphinxstylestrong{量子计算的定位：异构计算}

\sphinxAtStartPar
  量子计算领域属于一个新兴高速发展的领域，在近二十年间，不论是量子算法的研究，还是量子芯片的研发均取得了巨大的进展。由于量子计算的理论研究有限，目前所说的量子计算机并非是一个可独立完成计算任务的设备，而是一个可以对特定问题有指数级别加速的协处理器。相应的，目前所说的量子计算，如图3.3.1所示，本质上来说是一种异构运算，即在经典计算机执行计算任务的同时，将需要加速的程序在量子芯片上执行。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.3.1}.png}\hspace*{\fill}}

\begin{center}图3.3.1 量子计算流程图（complexity\sphinxhyphen{}复杂性，result\sphinxhyphen{}结果）
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子程序代码构成：宿主代码+设备代码}

\sphinxAtStartPar
  因此，量子计算的程序代码实际执行中分为两种，一种是运行在CPU上的宿主代码（Host code），主要用于执行不需要加速的任务，并为需要加速的任务提供需要的数据；一种是运行在量子芯片上的设备代码（Device code），主要用于描述量子线路，控制量子程序在量子芯片上的执行顺序，以及数据的传输。不同类型的代码由于其运行的物理位置不同，编译方式和访问的资源均不同，这跟英伟达公司推出的用GPU解决复杂的计算问题的并行计算架构CUDA非常类似。如表3.3.1所示，以下所提及的量子程序，指的是Device code。

\begin{center}表3.3.1 CUDA与量子计算架构的对比
\end{center}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{区别}
&
\sphinxAtStartPar
\sphinxstylestrong{量子计算架构}
&
\sphinxAtStartPar
\sphinxstylestrong{CUDA并行运算架构}
\\
\sphinxhline
\sphinxAtStartPar
加速的问题
&
\sphinxAtStartPar
QAOA，质数分解
&
\sphinxAtStartPar
大规模并行计算
\\
\sphinxhline
\sphinxAtStartPar
描述语言
&
\sphinxAtStartPar
C + 量子高级语言
&
\sphinxAtStartPar
C/MATLAB + CUDA
\\
\sphinxhline
\sphinxAtStartPar
执行设备
&
\sphinxAtStartPar
量子芯片
&
\sphinxAtStartPar
GPU
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{3.3.2 量子程序架构（设备代码的架构）}
\label{\detokenize{rst/3.3_u91cf_u5b50_u8ba1_u7b97_u673a:id3}}
\sphinxAtStartPar
\sphinxstylestrong{量子高级语言}

\sphinxAtStartPar
  与经典计算机语言类似，描述量子程序的语言也有高级语言与低级语言之分。量子高级语言，类似于经典计算机语言中C++。在描述量子线路时，不需要考虑量子芯片的底层物理实现，包括可执行量子逻辑门的种类，量子比特的连通性等，这就像一个经典的程序设计师并不需要考虑底层的执行芯片是x86架构，还是RISC架构一样。QPanda,QRunes均属于量子高级语言。量子高级语言主要用于描述量子线路的逻辑门构成，量子程序段之间的执行顺序，如Qif,QWhile等，以及内存之间的通信。

\sphinxAtStartPar
\sphinxstylestrong{量子汇编语言的编译原则}

\sphinxAtStartPar
  量子高级语言会根据底层芯片的特点，通过量子程序编译器，编译为量子汇编语言。量子程序编译器一般会考虑两个方面：量子芯片可执行的量子逻辑门种类和量子比特的连通性。

\sphinxAtStartPar
\sphinxstylestrong{不可直接执行的量子比特逻辑门拆分}

\sphinxAtStartPar
  根据量子计算的原理，任意的单量子比特逻辑门可以拆分为绕X轴旋转的量子逻辑门和绕Y轴旋转量子逻辑门的序列；任意的两量子比特逻辑门可以拆分为由CNOT/CZ门和单量子比特逻辑门的序列。量子芯片提供的可直接执行的逻辑门是完备的，即可以表征所有的量子比特逻辑门，因此，如果量子高级语言描述的量子程序中包含了量子芯片不可直接执行的量子逻辑门，量子程序编译器会根据量子芯片提供的量子逻辑门将其转化为可执行量子逻辑门构成的序列。

\sphinxAtStartPar
\sphinxstylestrong{量子比特连通性与不连通门的转换}

\sphinxAtStartPar
  相同数量的量子比特对于不同的量子芯片结构，可执行两量子比特逻辑门的量子比特对可能完全不同。目前常见的量子芯片结构有链式结构，十字结构，以及全连通结构。对于链式结构，量子比特成链状排布，每个量子比特只能与其相邻的两个量子比特执行两量子比特逻辑门；对于十字结构，量子比特成方阵装排布，每个量子比特能与其相邻的四个量子比特执行两量子比特逻辑门；对于全连通结构，每个量子比特可以与其他所有量子比特执行两量子比特逻辑门。如果量子高级语言描述的量子程序中包含量子芯片不可直接执行的两量子比特逻辑门，量子程序编译器会根据量子芯片的连通性，利用交换门和可执行的两比特门的序列，取代量子程序中的两量子比特逻辑门。

\sphinxAtStartPar
  例如图3.3.2，一个三量子比特的链式结构量子芯片，可执行两量子比特逻辑门的量子比特对有\{ \{1,2\},\{2,3\} \}，CNOT 1,3 对于此量子芯片是不可执行的逻辑门，可以用SWAP1,2、CNOT2,3、SWAP1,2构成的量子逻辑门序列取代CNOT1,3。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{3.3.2}.png}\hspace*{\fill}}

\begin{center}图3.3.2 三量子比特的链式结构量子芯片
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子程序的可执行文件}

\sphinxAtStartPar
  对于经典程序来说，汇编语言转化为计算机可直接执行二进制文件，即可被经典计算机执行；而量子芯片可直接执行的文件并非一串01组合的二进制文件，而是由测控设备产生的精密的脉冲模拟信号，因此对于量子汇编语言，应该转化成测控设备所能执行文件。此文件中不仅包含着每个量子比特逻辑门的脉冲波形，还需要包含波形的执行顺序，根据波形执行顺序的表征形式不同，量子计算硬件架构可细分为两类。

\sphinxAtStartPar
\sphinxstylestrong{传统量子体系结构}

\sphinxAtStartPar
  顺序执行的传统量子体系结构的可执行文件：量子程序的整段波形文件

\sphinxAtStartPar
  在传统的量子体系结构中，波形执行顺序体现在波形文件中，即编译器将量子汇编程序中的量子比特逻辑门的波形，按照执行顺序拼接为一个整体的波形，并将此波形以二进制文件的形式存放至测控设备的内存中。波形文件本身包含着量子逻辑门的执行顺序，测控设备通过执行波形文件，输出测控波形。此量子体系结构对应的硬件架构为上位机\sphinxhyphen{}测控设备\sphinxhyphen{}量子芯片架构。

\sphinxAtStartPar
\sphinxstylestrong{顺序执行的传统量子体系结构优缺点}

\sphinxAtStartPar
  这种架构的优势在于，测控设备可以从内存中直接读取波形，并施加到量子芯片上，延时极短，执行效率很高，但由于上位机与测控设备之间的通信时间很长，远大于量子比特的退相干时间，即在量子比特完成测量发送至上位机，以及上位机根据测量结果将后续要执行的波形文件发送至测控设备内存的期间，量子比特已经退相干，无法继续执行量子比特逻辑门。因此，这种架构只能运行顺序执行的上位机发送的波形文件，在执行期间不可改变波形的执行顺序，进而无法执行包含基于测量结果的跳转量子程序。

\sphinxAtStartPar
\sphinxstylestrong{顺序执行的传统量子体系结构的改进}

\sphinxAtStartPar
  改进方案是将量子程序中可能执行的量子程序段的波形，全部上传至测控设备的内存中，当测量设备得到量子比特的测量结果时，根据测量结果决定接下来输出的波形在内存中的地址，且整个反馈过程的延时远小于量子比特的退相干时间。因此，此方案可以实现基于量子比特测量结果的反馈控制，但此方法需要将可能执行的量子程序段的波形全部存储在测控设备的内存中，随着量子比特数量和量子程序波形长度的增长，该架构对内存的开销极大，可扩展性较低。

\sphinxAtStartPar
\sphinxstylestrong{增强扩展性的新量子体系结构}

\sphinxAtStartPar
  增强扩展性的新量子体系结构的可执行文件构成：所有逻辑门的波形文件+微处理器程序

\sphinxAtStartPar
  为了降低任意波形发生器的内存开销，增加系统的可扩展性，目前已有科研团队提出另一种量子计算机架构：上位机\sphinxhyphen{}微处理器\sphinxhyphen{}测控设备\sphinxhyphen{}量子芯片架构：该架构下，波形执行顺序通过微处理器发送的指令控制，虽然上位机与测控设备之间的通信速度很慢，但FPGA可以与测控设备高速通信，因此采用FPGA搭建的微处理器控制测控设备按顺序执行波形。编译器将量子汇编程序中的每个量子比特逻辑门的波形以二进制文件的形式存放至测控设备的内存中，并生成微处理器可执行的微处理器程序，微处理器通过执行该程序，在特定的时间向测控设备发送控制指令触发对应的测控波形，同时，该微处理器可以接收测控设备发送的量子比特的测量结果，并通过执行微处理器程序，决定测控设备执行的波形。

\sphinxAtStartPar
\sphinxstylestrong{增强扩展性的新量子体系结构的优缺点}

\sphinxAtStartPar
  优点是：测控设备无需存放量子程序对应的所有波形，大大减少了内存开销；但缺点在于，通过执行微处理器程序控制测控设备，对微处理器的执行速度要求较高。如果微处理器将微处理器程序转化为测控设备的控制指令的时间大于量子芯片执行波形的时间，则会导致量子芯片在退相干时间内执行的有效的量子比特逻辑门数量降低；另一方面，微处理器向测控设备发送控制指令存在延时，如果顺序执行量子程序，则该延迟无任何影响，但如果要执行基于测量结果跳转的量子程序，则每次反馈控制都会产生两倍延时时间的空泡，影响量子芯片的执行效率。

\sphinxAtStartPar
\sphinxstylestrong{参考文献}

\sphinxAtStartPar
{[}1{]} Loss, Daniel, and David P. DiVincenzo. “Quantum computation with quantum dots.” Physical Review A 57.1 (1998): 120.

\sphinxAtStartPar
{[}2{]} Devoret, Michel H., and Robert J. Schoelkopf. “Superconducting circuits for quantum information: an outlook.” Science 339.6124 (2013): 1169\sphinxhyphen{}1174.

\sphinxAtStartPar
{[}3{]} DiCarlo, L., et al. “Demonstration of two\sphinxhyphen{}qubit algorithms with a superconducting quantum processor.” Nature 460.7252 (2009): 240.

\sphinxAtStartPar
{[}4{]}Kelly, Julian, et al. “State preservation by repetitive error detection in a superconducting quantum circuit.” Nature 519.7541 (2015): 66.

\sphinxAtStartPar
{[}5{]}O’Malley, P. J. J., et al. “Scalable quantum simulation of molecular energies.” Physical Review X 6.3 (2016): 031007.

\sphinxAtStartPar
{[}6{]}Neill, C., et al. “A blueprint for demonstrating quantum supremacy with superconducting qubits.” Science 360.6385 (2018): 195\sphinxhyphen{}199.

\sphinxAtStartPar
{[}7{]}Kandala, Abhinav, et al. “Hardware\sphinxhyphen{}efficient variational quantum eigensolver for small molecules and quantum magnets.” Nature 549.7671 (2017): 242.

\sphinxAtStartPar
{[}8{]} Otterbach, J. S., et al. “Unsupervised Machine Learning on a Hybrid Quantum Computer.” arXiv preprint arXiv:1712.05771(2017).

\sphinxAtStartPar
{[}9{]} Song, Chao, et al. “10\sphinxhyphen{}qubit entanglement and parallel logic operations with a superconducting circuit.” Physical review letters 119.18 (2017): 180511.

\sphinxAtStartPar
{[}10{]}Zhao, Peng, et al. “Circuit QED with qutrits: Coupling three or more atoms via virtual\sphinxhyphen{}photon exchange.” Physical Review A 96.4 (2017): 043833.

\sphinxAtStartPar
{[}11{]}Wang, Tenghui, et al. “The experimental realization of high\sphinxhyphen{}fidelityshortcut\sphinxhyphen{}to\sphinxhyphen{}adiabaticity’quantum gates in a superconducting Xmon qubit.” arXiv preprint arXiv:1804.08247 (2018).

\sphinxAtStartPar
{[}12{]}Li, Hai\sphinxhyphen{}Ou, et al. “Controlled Quantum Operations of a Semiconductor Three\sphinxhyphen{}Qubit System.” Physical Review Applied 9.2 (2018): 024015.

\sphinxAtStartPar
{[}13{]} Zajac, David M., et al. “Resonantly driven CNOT gate for electron spins.” Science 359.6374 (2018): 439\sphinxhyphen{}442.

\sphinxAtStartPar
{[}14{]} Muhonen, Juha T., et al. “Storing quantum information for 30 seconds in a nanoelectronic device.” Nature nanotechnology9.12 (2014): 986.

\sphinxAtStartPar
{[}15{]} Veldhorst, Menno, et al. “A two\sphinxhyphen{}qubit logic gate in silicon.” Nature 526.7573 (2015): 410.

\sphinxAtStartPar
{[}16{]} Watson, T. F., et al. “A programmable two\sphinxhyphen{}qubit quantum processor in silicon.” Nature (2018).

\sphinxAtStartPar
{[}17{]} Yoneda, Jun, et al. “A quantum\sphinxhyphen{}dot spin qubit with coherence limited by charge noise and fidelity higher than 99.9\%.” Nature nanotechnology 13.2 (2018): 102.

\sphinxAtStartPar
{[}18{]} Cao, Gang, et al. “Ultrafast universal quantum control of a quantum\sphinxhyphen{}dot charge qubit using Landau–Zener–Stückelberg interference.” Nature communications 4 (2013): 1401.

\sphinxAtStartPar
{[}19{]} Li, Hai\sphinxhyphen{}Ou, et al. “Conditional rotation of two strongly coupled semiconductor charge qubits.” Nature communications 6 (2015): 7681.

\sphinxAtStartPar
{[}20{]} Cao, Gang, et al. “Tunable hybrid qubit in a GaAs double quantum dot.” Physical review letters 116.8 (2016): 086801.

\sphinxAtStartPar
{[}21{]} Gulde, Stephan, et al. “Implementation of the Deutsch–Jozsa algorithm on an ion\sphinxhyphen{}trap quantum computer.” Nature 421.6918 (2003): 48.

\sphinxAtStartPar
{[}22{]} Monroe, Christopher, and Jungsang Kim. “Scaling the ion trap quantum processor.” Science 339.6124 (2013): 1164\sphinxhyphen{}1169.

\sphinxAtStartPar
{[}23{]} Debnath, Shantanu, et al. “Demonstration of a small programmable quantum computer with atomic qubits.” Nature 536.7614 (2016): 63.

\sphinxAtStartPar
{[}24{]}Linke, Norbert M., et al. “Experimental comparison of two quantum computing architectures.” Proceedings of the National Academy of Sciences (2017): 201618020.

\sphinxAtStartPar
{[}25{]}Zhang, Jiehang, et al. “Observation of a many\sphinxhyphen{}body dynamical phase transition with a 53\sphinxhyphen{}qubit quantum simulator.” Nature 551.7682 (2017): 601.

\sphinxAtStartPar
{[}26{]} Schäfer, V. M., et al. “Fast quantum logic gates with trapped\sphinxhyphen{}ion qubits.” Nature 555.7694 (2018): 75

\sphinxAtStartPar
{[}27{]} Zhang, Xiang, et al. “Experimental quantum simulation of fermion\sphinxhyphen{}antifermion scattering via boson exchange in a trapped ion.” Nature communications 9.1 (2018): 195.

\sphinxAtStartPar
{[}28{]} Cui, Jin\sphinxhyphen{}Ming, et al. “Experimental Trapped\sphinxhyphen{}ion Quantum Simulation of the Kibble\sphinxhyphen{}Zurek dynamics in momentum space.” Scientific reports 6 (2016): 33381.

\sphinxAtStartPar
{[}29{]}Weiss, David S., and Mark Saffman. “Quantum computing with neutral atoms.” Physics Today 70.7 (2017): 44.

\sphinxAtStartPar
{[}30{]}Theis, L. S., et al. “High\sphinxhyphen{}fidelity Rydberg\sphinxhyphen{}blockade entangling gate using shaped, analytic pulses.” Physical Review A 94.3 (2016): 032306.

\sphinxAtStartPar
{[}31{]}Dai, Han\sphinxhyphen{}Ning, et al. “Generation and detection of atomic spin entanglement in optical lattices.” Nature Physics 12.8 (2016): 783.

\sphinxAtStartPar
{[}32{]} Bloch, Immanuel, Jean Dalibard, and Wilhelm Zwerger. “Many\sphinxhyphen{}body physics with ultracold gases.” Reviews of modern physics 80.3 (2008): 885.

\sphinxAtStartPar
{[}33{]}Bernien, Hannes, et al. “Probing many\sphinxhyphen{}body dynamics on a 51\sphinxhyphen{}atom quantum simulator.” Nature 551.7682 (2017): 579.

\sphinxAtStartPar
{[}34{]} Wu, Zhan, et al. “Realization of two\sphinxhyphen{}dimensional spin\sphinxhyphen{}orbit coupling for Bose\sphinxhyphen{}Einstein condensates.” Science 354.6308 (2016): 83\sphinxhyphen{}88.

\sphinxAtStartPar
{[}35{]} Gershenfeld, Neil A., and Isaac L. Chuang. “Bulk spin\sphinxhyphen{}resonance quantum computation.” science 275.5298 (1997): 350\sphinxhyphen{}356.

\sphinxAtStartPar
{[}36{]} Jones, Jonathan A., Michele Mosca, and Rasmus H. Hansen. “Implementation of a quantum search algorithm on a quantum computer.” Nature 393.6683 (1998): 344.

\sphinxAtStartPar
{[}37{]} Vandersypen, Lieven MK, et al. “Experimental realization of Shor’s quantum factoring algorithm using nuclear magnetic resonance.” Nature 414.6866 (2001): 883.

\sphinxAtStartPar
{[}38{]} Ryan, C. A., Martin Laforest, and Raymond Laflamme. “Randomized benchmarking of single\sphinxhyphen{}and multi\sphinxhyphen{}qubit control in liquid\sphinxhyphen{}state NMR quantum information processing.” New Journal of Physics 11.1 (2009): 013034.

\sphinxAtStartPar
{[}39{]} Stern, Ady, and Netanel H. Lindner. “Topological quantum computation—from basic concepts to first experiments.” Science 339.6124 (2013): 1179\sphinxhyphen{}1184.

\sphinxAtStartPar
{[}40{]}Mourik, Vincent, et al. “Signatures of Majorana fermions in hybrid superconductor\sphinxhyphen{}semiconductor nanowire devices.” Science 336.6084 (2012): 1003\sphinxhyphen{}1007.

\sphinxAtStartPar
{[}41{]} Zhang, Hao, et al. “Quantized majorana conductance.” Nature 556.7699 (2018): 74.

\sphinxAtStartPar
{[}42{]} Gazibegovic, Sasa, et al. “Epitaxy of advanced nanowire quantum devices.” Nature 548.7668 (2017): 434.

\sphinxAtStartPar
{[}43{]} Vaitiekėnas, S., et al. “Selective area grown semiconductor\sphinxhyphen{}superconductor hybrids: a basis for topological networks.” arXiv preprint arXiv:1802.04210 (2018).

\sphinxAtStartPar
{[}44{]}He, Qing Lin, et al. “Chiral Majorana fermion modes in a quantum anomalous Hall insulator–superconductor structure.” Science 357.6348 (2017): 294\sphinxhyphen{}299.

\sphinxAtStartPar
{[}45{]} 图片引用自中国科学技术大学孔伟成博士的毕业论文。

\sphinxAtStartPar
{[}46{]} 图片引用自中国科学技术大学孔伟成博士的毕业论文。

\sphinxAtStartPar
{[}47{]} 图片引自npj Quantum Information 2, 16033 (2016)

\sphinxAtStartPar
{[}48{]} 图片引自Phys. Rev. Appl. 3, 024010 (2015).

\sphinxstepscope


\section{4.1 量子软件开发环境}
\label{\detokenize{rst/4.1_u91cf_u5b50_u8f6f_u4ef6_u5f00_u53d1_u73af_u5883:id1}}\label{\detokenize{rst/4.1_u91cf_u5b50_u8f6f_u4ef6_u5f00_u53d1_u73af_u5883::doc}}

\subsection{4.1.1 QPanda}
\label{\detokenize{rst/4.1_u91cf_u5b50_u8f6f_u4ef6_u5f00_u53d1_u73af_u5883:qpanda}}
\sphinxAtStartPar
  QPanda (Quantum Programming Architecture for NISQ Device Applications)是一个高效、便捷的量子计算开发工具库，为了让用户更容易的使用QPanda，更便捷的进行量子编程，它屏蔽了复杂的C++语法结构，甚至用户不需要了解所谓的面向对象，只需要学会如何把量子编程中用到的接口调用一遍就可以进行量子计算。

\sphinxAtStartPar
  例：如何构造一个量子程序，并在量子虚拟机中运行它。

\sphinxAtStartPar
  首先假设有一台量子计算机，它有2个量子比特： \(Q_1\) 、 \(Q_2\) ，接着对其中一个量子比特（ \(Q_1\) ）进行 \(H\) 门操作，构造了一个量子叠加态；并对 \(Q_1\) 和 \(Q_2\) 做 \(CNOT\) 门操作， \(Q_1\) 为控制量子比特， \(Q_2\) 为目标量子比特，最后对所有的量子比特进行测量操作。此时，将有50\%的概率得到00或者11的测量结果。代码示例如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}
2.using namespace QPanda;
3.int main()
4.\PYGZob{}
5.    auto qvm = CPUQVM();              /* 创建一个类型CPU计算的量子虚拟机*/
6.    qvm.init();                       /* 为该虚拟机进行初始化*/
7.    auto prog = QProg();              /* 构造一个量子程序*/
8.    auto q = qvm.qAllocMany(2);       /* 申请两个量子比特*/
9.    auto c = qvm.cAllocMany(2);       /* 申请两个经典比特*/
10.
11.    /* 向量子程序中插入H门、CNOT门和Measure*/
12.    prog \PYGZlt{}\PYGZlt{} H(q[0])
13.          \PYGZlt{}\PYGZlt{} CNOT(q[0],q[1])
14.          \PYGZlt{}\PYGZlt{} MeasureAll(q, c);
15.
16.    /* 让量子程序在量子虚拟机中跑1000次*/
17.    auto results = qvm.runWithConfiguration(prog, c, 1000);
18.    for (auto result : results)
19.    \PYGZob{}
20.       /* 循环输出结果*/
21.       std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}result.first\PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}result.second\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;
22.    \PYGZcb{}
23.    return 0;
24.\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这是个简单却能体现出量子计算特点的例子，它即体现了量子态叠加，又体现量子比特纠缠。从上例可以看到，用户实质上只需要关注如何使用QPanda构建量子程序，其他的细节操作完全不需要用户操心。

\sphinxAtStartPar
  再例如，在很多量子算法如QAOA算法中，都需要构造一组量子比特的叠加态，那么完全可以把这种操作抽象成一种生成量子线路的函数，输入是一组量子比特，输出是一个量子线路。代码示例如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}\PYG{n}{QCircuit} \PYG{n}{HadamardCircuit}\PYG{p}{(}\PYG{n}{QVec} \PYG{o}{\PYGZam{}} \PYG{n}{qvec}\PYG{p}{)}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{qcircuit} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}           \PYG{o}{/}\PYG{o}{*} \PYG{n}{构造一个量子线路}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n+nb}{aiter} \PYG{p}{:} \PYG{n}{qvec}\PYG{p}{)}               \PYG{o}{/}\PYG{o}{*} \PYG{n}{对传入的量子比特做H门操作}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{9.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{10.}        \PYG{n}{qcircuit}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{H}\PYG{p}{(}\PYG{n+nb}{aiter}\PYG{p}{)}\PYG{p}{;}               \PYG{o}{/}\PYG{o}{*} \PYG{n}{把H门插入的量子线路中}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{11.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{k}{return} \PYG{n}{qcircuit}\PYG{p}{;}                      \PYG{o}{/}\PYG{o}{*} \PYG{n}{返回量子线路}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{14.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{17.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{18.}    \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}         \PYG{o}{/}\PYG{o}{*} \PYG{n}{创建一个类型未CPU计算的量子虚拟机}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{19.}    \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                  \PYG{o}{/}\PYG{o}{*} \PYG{n}{为该虚拟机进行初始化}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{20.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}         \PYG{o}{/}\PYG{o}{*} \PYG{n}{构造一个量子程序}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{21.}    \PYG{n}{auto} \PYG{n}{q} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{*} \PYG{n}{申请两个量子比特}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{22.}    \PYG{n}{auto} \PYG{n}{c} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{*} \PYG{n}{申请两个经典比特}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{23.}
\PYG{l+m+mf}{24.}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{调用HadamardCircuit函数}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{25.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{HandmadeCircuit}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{让量子程序在量子虚拟机中跑1000次}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{28.}    \PYG{n}{auto} \PYG{n}{results} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{29.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{result} \PYG{p}{:} \PYG{n}{results}\PYG{p}{)}
\PYG{l+m+mf}{30.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{31.}        \PYG{o}{/}\PYG{o}{*} \PYG{n}{循环输出结果}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{32.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result.first}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result.second}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{33.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{34.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{35.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  也可使用新的接口来一次性插入多个逻辑门：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}             \PYG{o}{/}\PYG{o}{*} \PYG{n}{创建一个CPU计算的量子虚拟机}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{6.}    \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                      \PYG{o}{/}\PYG{o}{*} \PYG{n}{为该虚拟机进行初始化}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{7.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}             \PYG{o}{/}\PYG{o}{*} \PYG{n}{构造一个量子程序}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{q} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}      \PYG{o}{/}\PYG{o}{*} \PYG{n}{申请两个量子比特}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{c} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}      \PYG{o}{/}\PYG{o}{*} \PYG{n}{申请两个经典比特}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{10.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}  \PYG{o}{/}\PYG{o}{*} \PYG{n}{将2个H门插入到每个比特上}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{让量子程序在量子虚拟机中跑1000次}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{13.}    \PYG{n}{auto} \PYG{n}{results} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{14.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{result} \PYG{p}{:} \PYG{n}{results}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{16.}        \PYG{o}{/}\PYG{o}{*} \PYG{n}{循环输出结果}\PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{17.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result.first}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result.second}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{18.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{19.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{20.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  从上述三例可以知道，用户只需要关注量子程序的构建，其他的部分，如量子虚拟机的构建、初始化、申请量子比特、执行量子程序和获取结果，都是一个固定的流程，只需要调用函数接口即可。

\sphinxAtStartPar
  深入了解QPanda的使用，就必须要了解一下QPanda中与量子计算相关的数据类型：QGate（量子逻辑门），Measure（测量）、ClassicalProg（经典程序）、QCircuit（量子线路）、Qif（量子条件判断程序）、QWhile（量子循环程序）、QProg（量子程序）；

\sphinxAtStartPar
  QGate：量子逻辑门是量子计算的基本单位，任何一个量子程序都是由QGate组合而成，如果说量子程序或量子算法是一套拳法，那么QGate就是一个个被拆解出来的动作，几个QGate的固定组合就是一个招式，它们的最终目的就是把这套拳法打出来。目前QPanda的量子逻辑门大致分为单门、双门、三门、自定义门，其中每个类又分为带角度和不带角度两类。

\sphinxAtStartPar
  常见的单门有：

\sphinxAtStartPar
​   不含角度的单门有：I、H、T、X、S、X、Y、Z、X1、Y1、Z1。

\sphinxAtStartPar
​   带有一个旋转角度的逻辑门：RX、RY、RZ、U1、P。

\sphinxAtStartPar
  此外还支持U2、U3、U4。

\sphinxAtStartPar
​   双门不含角度的逻辑门：CNOT、CZ、iSWAP、SWAP、SqiSWAP。

\sphinxAtStartPar
​   双门含旋转角度的逻辑门：CR、CU、CP。

\sphinxAtStartPar
  三量子逻辑门 ：Toffoli。

\sphinxAtStartPar
  QPanda 2把所有的量子逻辑门封装为API向用户提供使用，并可获得QGate类型的返回值。例如，如果想使用Hadamard门，就可以通过如下方式获得：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QGate} \PYG{n}{h} \PYG{o}{=} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  可以看到，H函数只接收一个qubit，qubit如何申请请参考

\sphinxAtStartPar
  \sphinxurl{https://QPanda2.readthedocs.io/zh\_CN/latest/TotalAmplitude.html\#quantummachine}

\sphinxAtStartPar
  QPanda2还支持对量子逻辑门做转置共轭操作：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.auto gate = H(qubit);
2./* setDagger有一个布尔类型参数，用来设置当前逻辑门是否需要转置共轭操作*/
3.gate.setDagger(true);
4.
5./* dagger的作用是复制一份当前的量子逻辑门，并更新复制的量子逻辑门的dagger标记*/
6.QGate H\PYGZus{}dagger = H(qubit).dagger();
\end{sphinxVerbatim}

\sphinxAtStartPar
  setDagger有一个布尔类型参数，用来设置当前逻辑门是否需要转置共轭操作。

\sphinxAtStartPar
  除了转置共轭操作，也可以为量子逻辑门添加控制比特：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.auto gate = H(qubit)
2./* setControl的作用是给当前的量子逻辑门添加控制比特*/
3.gate.setControl(qvec);
4.
5./* control的作用是复制当前的量子逻辑门，并给复制的量子逻辑门添加控制比特*/
6.QGate H\PYGZus{}control = H(qubit).control(qvec);
\end{sphinxVerbatim}

\sphinxAtStartPar
  setControl、control都需要接收一个参数，参数类型为QVec，QVec是qubit的vector

\sphinxAtStartPar
  再例如，想要使用RX门，可以通过如下方式获得：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.QGate rx = RX(qubit，PI);
\end{sphinxVerbatim}

\sphinxAtStartPar
  如上所示，RX门接收两个参数，第一个是目标量子比特，第二个偏转角度，也可以通过相同的方式使用RY，RZ门。

\sphinxAtStartPar
  两比特量子逻辑门的使用和单比特量子逻辑门的用法相似，只不过是输入的参数不同，举个使用CNOT的例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.QGate cnot = CNOT(control\PYGZus{}qubit，target\PYGZus{}qubit);
\end{sphinxVerbatim}

\sphinxAtStartPar
  CNOT门接收两个参数，第一个是控制比特，第二个是目标比特。

\sphinxAtStartPar
  此外我们还有一个可以自行填充矩阵和比特的QOracle门，具体使用方法请看下面的例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{3.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{new} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{q} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{c} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{n}{QStat} \PYG{n}{source\PYGZus{}matrix} \PYG{o}{=}
\PYG{l+m+mf}{13.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{14.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{l+m+mf}{0.6477054522122977}\PYG{p}{,} \PYG{l+m+mf}{0.1195417767870219}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{15.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.16162176706189357}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4020495632468249}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{16.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.19991615329121998}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3764618308248643}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{17.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2599957197928922}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.35935248873007863}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{18.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.16162176706189363}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.40204956324682495}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{19.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{l+m+mf}{0.7303014482204584}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4215172444390785}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{20.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.15199187936216693}\PYG{p}{,} \PYG{l+m+mf}{0.09733585496768032}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{21.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.22248203136345918}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1383600597660744}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{22.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.19991615329122003} \PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3764618308248644}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{23.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.15199187936216688}\PYG{p}{,} \PYG{l+m+mf}{0.09733585496768032}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{24.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{l+m+mf}{0.6826630277354306}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.37517063774206166}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{25.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3078966462928956}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2900897445133085}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{26.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2599957197928923}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3593524887300787}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{27.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.22248203136345912}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1383600597660744}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{28.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.30789664629289554}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2900897445133085}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{29.}        \PYG{n}{qcomplex\PYGZus{}t}\PYG{p}{(}\PYG{l+m+mf}{0.6640994547408099}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.338593803336005}\PYG{p}{)}
\PYG{l+m+mf}{30.}    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{l+m+mf}{31.}
\PYG{l+m+mf}{32.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{QOracle}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{source\PYGZus{}matrix}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{33.}    \PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{34.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{res} \PYG{p}{:} \PYG{n}{result}\PYG{p}{)}
\PYG{l+m+mf}{35.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{36.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{37.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{38.}
\PYG{l+m+mf}{39.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{40.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  运行结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.00} \PYG{p}{:} \PYG{l+m+mi}{433}
\PYG{l+m+mf}{2.01} \PYG{p}{:} \PYG{l+m+mi}{182}
\PYG{l+m+mf}{3.10} \PYG{p}{:} \PYG{l+m+mi}{180}
\PYG{l+m+mf}{4.11} \PYG{p}{:} \PYG{l+m+mi}{205}
\end{sphinxVerbatim}

\sphinxAtStartPar
  Measure：它的的作用是对量子比特进行测量操作。

\sphinxAtStartPar
  在量子程序中需要对某个量子比特做测量操作，并把测量结果存储到经典寄存器上，可以通过下面的方式获得一个测量对象：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{measure} \PYG{o}{=} \PYG{n}{Measure}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{,} \PYG{n}{cbit}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  可以看到Measure接两个参数， 第一个是测量比特，第二个是经典寄存器。

\sphinxAtStartPar
  如果想测量所有的量子比特并将其存储到对应的经典寄存器上，可以如下操作：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{} MeasureAll 的返回值类型是 QProg
2.auto measure\PYGZus{}all = MeasureAll(qubits， cbits);
\end{sphinxVerbatim}

\sphinxAtStartPar
  其中qubits的类型是 QVec ， cbits的类型是 vector。

\sphinxAtStartPar
  在得到含有量子测量的程序后，可以调用 directlyRun 或 runWithConfiguration 来得到量子程序的测量结果。

\sphinxAtStartPar
  directlyRun 的功能是运行量子程序并返回运行的结果， 使用方法如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{Measure}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{/} \PYG{n}{测量单个量子比特}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}\PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  runWithConfiguration 的功能是末态目标量子比特序列在量子程序多次运行结果中出现的次数， 使用方法如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{测量所有的量子比特}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}\PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  其中第一个参数是量子程序，第二个参数是经典寄存器， 第三个参数是运行的次数。

\sphinxAtStartPar
  getCircuitMatrix 的功能是获取线路中的矩阵，方法如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{auto} \PYG{n}{qubits} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{auto} \PYG{n}{cbits}  \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{6.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{7.}     \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{n}{auto} \PYG{n}{matrix} \PYG{o}{=} \PYG{n}{getCircuitMatrix}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{matrix} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}   \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}   \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{2.} \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{3.} \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}   \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{4.} \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{p}{(}\PYG{l+m+mf}{0.499999999999996}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  实例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}QPanda.h\PYGZgt{}}
\PYG{l+m+mf}{2.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{qubits} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{cbits}  \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}    \PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{12.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{13.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{14.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{15.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{18.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{:} \PYG{n}{result}\PYG{p}{)}
\PYG{l+m+mf}{19.}    \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{20.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{21.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}
\PYG{l+m+mf}{24.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{25.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  运行结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0000}\PYG{p}{,} \PYG{l+m+mi}{47}
\PYG{l+m+mf}{2.0001}\PYG{p}{,} \PYG{l+m+mi}{59}
\PYG{l+m+mf}{3.0010}\PYG{p}{,} \PYG{l+m+mi}{74}
\PYG{l+m+mf}{4.0011}\PYG{p}{,} \PYG{l+m+mi}{66}
\PYG{l+m+mf}{5.0100}\PYG{p}{,} \PYG{l+m+mi}{48}
\PYG{l+m+mf}{6.0101}\PYG{p}{,} \PYG{l+m+mi}{62}
\PYG{l+m+mf}{7.0110}\PYG{p}{,} \PYG{l+m+mi}{71}
\PYG{l+m+mf}{8.0111}\PYG{p}{,} \PYG{l+m+mi}{61}
\PYG{l+m+mf}{9.1000}\PYG{p}{,} \PYG{l+m+mi}{70}
\PYG{l+m+mf}{10.1001}\PYG{p}{,} \PYG{l+m+mi}{57}
\PYG{l+m+mf}{11.1010}\PYG{p}{,} \PYG{l+m+mi}{68}
\PYG{l+m+mf}{12.1011}\PYG{p}{,} \PYG{l+m+mi}{63}
\PYG{l+m+mf}{13.1100}\PYG{p}{,} \PYG{l+m+mi}{65}
\PYG{l+m+mf}{14.1101}\PYG{p}{,} \PYG{l+m+mi}{73}
\PYG{l+m+mf}{15.1110}\PYG{p}{,} \PYG{l+m+mi}{55}
\PYG{l+m+mf}{16.1111}\PYG{p}{,} \PYG{l+m+mi}{61}
\end{sphinxVerbatim}

\sphinxAtStartPar
  ClassicalProg：经典程序也可以被插入到量子程序中，它使得量子程序也可以进行逻辑判断和简单的经典计算，使得量子程序更灵活。打个比方，就像是向一套拳法中加入了步法，使得这套拳法可以辗转腾挪。

\sphinxAtStartPar
  QCircuit：量子线路是由多个量子逻辑门组成的，或者说量子线路是一个大型的量子逻辑门，也就是说QCircuit中可以插入QGate和ClassicalProg。如果映射到功夫中，QCircuit就是拳法中拆解出来的套路。此外QCircuit也可以设置dagger和control,请看下面的例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1./* setDagger的作用是根据输入参数更新当前量子线路的dagger标记*/
2.QCircuit cir;
3.cir.setDagger(true);
4.
5./* dagger的作用是复制一份当前的量子线路，并更新复制的量子线路的dagger标记*/
6.QCircuit cir1;
7.QCircuit cir\PYGZus{}dagger = cir1.dagger();
8.
9./* setControl的作用是给当前的量子线路添加控制比特*/
10.QCircuit cir2;
11.cir1.setControl(qvec);
12.
13./* control的作用是复制当前的量子线路，并给复制的量子线路添加控制比特*/
14.QCircuit cir3;
15.QCircuit cir\PYGZus{}control = cir.control(qvec);
\end{sphinxVerbatim}

\sphinxAtStartPar
  Qif：量子条件判断程序，顾名思义，它可以让量子程序进行逻辑判断，即针对不同的对手拳法的套路也是可变的。

\sphinxAtStartPar
  QWhile：量子循环判断程序，即根据循环判断条件把一个量子程序或量子线路多次运行。

\sphinxAtStartPar
  QProg：它是一个容器，可以容纳所有量子计算相关的数据类型，在构造量子程序时，用户可以把QGate、QCircuit、Qif、QWhile、QProg、ClassicalProg类型插入到QProg中。

\sphinxAtStartPar
  QPanda的特点不仅仅体现着它的易用性，还包括它的高效，如图4.1.1，在同等硬件配置下，QPanda的量子虚拟机运行量子程序的速度，相对其他工具有着巨大优势。

\sphinxAtStartPar
  QPanda的量子比特池，QPanda不仅可以使用qAllocMany() 来直接申请比特，还可以调用量子比特池来获取量子比特，请看示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}
2.USING\PYGZus{}QPANDA
3.using namespace std;
4.int main()
5.\PYGZob{}
6.    /*量子比特可以和虚拟机 脱离关系，获取对应池的单例 */
7.    auto qpool = OriginQubitPool::get\PYGZus{}instance();
8.    auto cmem = OriginCMem::get\PYGZus{}instance();
9.
10.    /* 获取容器大小*/
11.    cout \PYGZlt{}\PYGZlt{} \PYGZdq{}set qubit pool capacity  before: \PYGZdq{}\PYGZlt{}\PYGZlt{} qpool\PYGZhy{}\PYGZgt{}get\PYGZus{}capacity() \PYGZlt{}\PYGZlt{} endl;
12.    /* 设置最大容器*/
13.    qpool\PYGZhy{}\PYGZgt{}set\PYGZus{}capacity(20);
14.    cout \PYGZlt{}\PYGZlt{} \PYGZdq{}set qubit pool capacity  after: \PYGZdq{} \PYGZlt{}\PYGZlt{} qpool\PYGZhy{}\PYGZgt{}get\PYGZus{}capacity() \PYGZlt{}\PYGZlt{} endl;
15.
16.    /* 通过比特池申请比特，由于是单例模式，要保证申请的比特数量不超过最大容量*/
17.    auto qv = qpool\PYGZhy{}\PYGZgt{}qAllocMany(6);
18.    auto cv = cmem\PYGZhy{}\PYGZgt{}cAllocMany(6);
19.
20.    /* 获取被申请的量子比特*/
21.    QVec used\PYGZus{}qv;
22.    auto used\PYGZus{}qv\PYGZus{}size = qpool\PYGZhy{}\PYGZgt{}get\PYGZus{}allocate\PYGZus{}qubits(used\PYGZus{}qv);
23.    cout \PYGZlt{}\PYGZlt{} \PYGZdq{}allocate qubits number: \PYGZdq{} \PYGZlt{}\PYGZlt{} used\PYGZus{}qv\PYGZus{}size \PYGZlt{}\PYGZlt{} endl;
24.
25.    /* 构建虚拟机*/
26.    auto qvm = new CPUQVM();
27.    qvm\PYGZhy{}\PYGZgt{}init();
28.    auto prog = QProg();
29.    /*直接使用物理地址作为量子比特信息入参 */
30.    prog \PYGZlt{}\PYGZlt{} H(0) \PYGZlt{}\PYGZlt{} H(1)
31.        \PYGZlt{}\PYGZlt{} H(2)
32.        \PYGZlt{}\PYGZlt{} H(4)
33.        \PYGZlt{}\PYGZlt{} X(5)
34.        \PYGZlt{}\PYGZlt{} X1(2)
35.        \PYGZlt{}\PYGZlt{} CZ(2, 3)
36.        \PYGZlt{}\PYGZlt{} RX(3, PI / 4)
37.        \PYGZlt{}\PYGZlt{} CR(4, 5, PI / 2)
38.        \PYGZlt{}\PYGZlt{} SWAP(3, 5)
39.        \PYGZlt{}\PYGZlt{} CU(1, 3, PI / 2, PI / 3, PI / 4, PI / 5)
40.        \PYGZlt{}\PYGZlt{} U4(4, 2.1, 2.2, 2.3, 2.4)
41.        \PYGZlt{}\PYGZlt{} BARRIER(\PYGZob{}0, 1,2,3,4,5\PYGZcb{});
42.
43.    /* 测量方法也可以使用比特物理地址*/
44.    auto res\PYGZus{}0 = qvm\PYGZhy{}\PYGZgt{}probRunDict(prog, \PYGZob{} 0,1,2,3,4,5 \PYGZcb{});
45.
46.    /* 同样经典比特地址也可以作为经典比特信息入参*/
47.    prog \PYGZlt{}\PYGZlt{} Measure(0, 0)
48.        \PYGZlt{}\PYGZlt{} Measure(1, 1)
49.        \PYGZlt{}\PYGZlt{} Measure(2, 2)
50.        \PYGZlt{}\PYGZlt{} Measure(3, 3)
51.        \PYGZlt{}\PYGZlt{} Measure(4, 4)
52.        \PYGZlt{}\PYGZlt{} Measure(5, 5);
53.
54.    /* 使用经典比特地址入参*/
55.    vector\PYGZlt{}int\PYGZgt{} cbit\PYGZus{}addrs = \PYGZob{} 0,1,2,3,4,5 \PYGZcb{};
56.    auto res\PYGZus{}2 = qvm\PYGZhy{}\PYGZgt{}runWithConfiguration(prog, cbit\PYGZus{}addrs, 5000);
57.    delete(qvm);
58.    /* 同时我们还可以再次利用这里申请的qv，避免多次使用虚拟机多次申请比特的问题发生*/
59.    auto qvm\PYGZus{}noise = new NoiseQVM();
60.    qvm\PYGZus{}noise\PYGZhy{}\PYGZgt{}init();
61.    auto res\PYGZus{}4 = qvm\PYGZus{}noise\PYGZhy{}\PYGZgt{}runWithConfiguration(prog, cbit\PYGZus{}addrs, 5000);
62.    delete(qvm\PYGZus{}noise);
63.
64.    return 0;
65.\PYGZcb{}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.1.1}.png}\hspace*{\fill}}

\begin{center}图4.1.1 量子虚拟机性能图
\end{center}
\sphinxAtStartPar
  除此之外，QPanda还集成了量子程序优化器、量子程序调试工具，量子程序编译器。

\sphinxAtStartPar
  1、 量子程序优化器：QPanda的优化器通过特有的算法对量子程序的优化，可最大限度的减少计算时间。

\sphinxAtStartPar
  2、 量子程序调试工具：QPanda的调试工具解决的量子算法工程师长期以来的困扰，里程碑的实现类量子程序的调试功能。

\sphinxAtStartPar
  3、 量子程序编译器：不仅把量子程序转换为多种量子汇编语言，更可以生成量子程序可执行文件。


\subsection{4.1.2 QRunes}
\label{\detokenize{rst/4.1_u91cf_u5b50_u8f6f_u4ef6_u5f00_u53d1_u73af_u5883:qrunes}}
\sphinxAtStartPar
  QRunes是一种基于语句的量子编程式语言，它的出现是为了实现量子计算和经典计算的混合，从而让量子计算有更好的应用场景。QRunes根据量子计算的经典与量子混合(Quantum\sphinxhyphen{}Classical Hybrid)特性，在程序编译之后可以操作经典计算机与量子芯片来实现量子计算。

\sphinxAtStartPar
  QRunes通过提供高级语言的形式来实现量子算法和程序的逻辑控制。其丰富的类型系统(Quatum Type, Classical Type)可以实现量子计算中数据对象的绑定和行为控制，可以满足开发人员的各类量子算法的实现需求。

\sphinxAtStartPar
  QRunes由量子程序和量子线路组成的量子部分和经典函数组成的经典部分构成。量子部分定义了对量子比特的操作和行为控制。经典部分用于主程序的实现和控制量子程序的运行。


\subsection{4.1.3 本源量子云平台}
\label{\detokenize{rst/4.1_u91cf_u5b50_u8f6f_u4ef6_u5f00_u53d1_u73af_u5883:id2}}
\sphinxAtStartPar
  本源量子云平台是国内首家基于模拟器研发且能在传统计算机上模拟32位量子芯片进行量子计算和量子算法编程的系统，目前该系统主要服务于各大科研院所、高校及相关企业，旨在为专业人员提供基于量子模拟器的开发平台。

\sphinxAtStartPar
  本源量子云平台提供了两种虚拟机供用户选择，其中32位量子虚拟机免费使用、64位需付费申请，虚拟机采用可视化编程模式图例+量子语言，用户可轻松拖动、放置图例进行量子算法模拟，并可将设计的运算转化为量子语言模式深入学习。量子云平台是连接用户和量子计算设备之间的桥梁，当前量子系统运作结构通常是经典计算向量子系统发起计算任务请求，待量子系统完成计算任务后再以经典信息的方式返回给用户，整个过程都需要量子云平台在中间协调。

\sphinxAtStartPar
  本源量子计算云平台的工作结构可以划分为四个部分：后端系统、控制指令、量子云端、以及用户端；其中后端系统包括了量子虚拟机，以及不同组织机构开发的量子芯片；控制指令则是通过其他编程语言或底层语言构建的能被量子系统识别的指令；量子云即是可视化编程、数据中转、用户数据存储交流等云服务；用户端，包括问题的设计、算法规则构造、可视化结果等。

\sphinxAtStartPar
  目前，本源量子计算系统包括了三种构造控制指令的方法，如图4.1.2所示，分别为可视化线路的设计、量子语言和量子软件开发套件QPanda，其中可视化编程和量子语言依托在量子云平台上，用户在进行量子程序设计的时候可以相互转化；对于功能完整的QPanda，则使用c++为宿主语言开发的SDK，用户可以使用c++直接开发量子程序。当然QPanda也开发了支持Python的库，也就是说可以使用Python来开发量子程序。使用QPadna编写的量子程序，可以很方便地转化为量子语言或者可视化的量子线路，在量子云平台上可以可视化的进行基础的算法设计、云平台的操作，通过拖动量子逻辑门来构建控制序列，添加测量指令，即可运行得出结果。通常用户会通过云平台构建简单的量子算法，之后待量子线路图转化为虚拟机或量子系统识别的指令，并将数据送入虚拟机或者量子系统，完成计算之后，回传结果，此时用户就能收到最终的计算结果。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.1.2}.png}\hspace*{\fill}}

\begin{center}图4.1.2 本源量子云平台工作原理
\end{center}
\sphinxstepscope


\section{4.2 量子算法简介}
\label{\detokenize{rst/4.2_u91cf_u5b50_u7b97_u6cd5_u7b80_u4ecb:id1}}\label{\detokenize{rst/4.2_u91cf_u5b50_u7b97_u6cd5_u7b80_u4ecb::doc}}

\subsection{4.2.1 概述}
\label{\detokenize{rst/4.2_u91cf_u5b50_u7b97_u6cd5_u7b80_u4ecb:id2}}
\sphinxAtStartPar
  量子算法是在现实的量子计算模型上运行的算法，最常用的模型是计算的量子电路模型。经典(或非量子)算法是一种有限的指令序列，或一步地解决问题的过程，或每一步指令都可以在经典计算机上执行。

\sphinxAtStartPar
  量子算法是一个逐步的过程，每个步骤都可以在量子计算机上执行。虽然所有经典算法都可以在量子计算机上实现，但量子算法这个术语通常用于那些看起来是量子的算法，或者使用量子计算的一些基本特性，如量子叠加或量子纠缠。

\sphinxAtStartPar
  使用经典计算机无法判定的问题，使用量子计算机仍然无法来确定。量子算法有趣的是，它们可能能够比经典算法更快地解决一些问题，因为量子算法所利用的量子叠加和量子纠缠可能不可以在经典计算机上有效地模拟。

\sphinxAtStartPar
  最著名的算法是Shor分解算法和Grover的搜索非结构化数据库或无序列表的算法。Shor算法运行速度比最著名的经典因式分解算法(一般的数域筛选算法)快得多(几乎是指数级)，对于同样的任务，Grover算法运行速度比最好的经典算法(线性搜索)要快得多。


\subsection{4.2.2 量子—经典混合算法}
\label{\detokenize{rst/4.2_u91cf_u5b50_u7b97_u6cd5_u7b80_u4ecb:id3}}
\sphinxAtStartPar
  量子计算机究竟什么时候能够真正实现？没有人能给出确切的答案，不过在这条路上探索的人们非常明白，建立一个容错的、具有足够多的逻辑比特的系统，是一个非常漫长的任务。

\sphinxAtStartPar
  然而，一个具有50个比特的量子系统，或者一个50个比特能模拟的量子系统，已经难以被传统计算机所模拟，它具有非常巨大的计算潜力。为了解决这个问题，John Preskill教授提出了一个全新的概念：含噪声的中等规模的量子计算机（Noise Intermediate\sphinxhyphen{}Scale Quantum），它被定义为未经纠错的，具有50个到数百个量子比特的量子计算机，简称为NISQ量子计算机。在NISQ上设计的算法可能和以往假设的容错量子计算机上设计的算法完全不同，NISQ算法本身需要能容忍噪声所造成的影响。

\sphinxAtStartPar
  量子霸权在最初提出的时候，代表超过50个量子比特的量子计算机在生成特定分布（distribution）上超过了传统计算机，但是研究表明，在这些问题上可以巧妙地选取模拟算法，使得经典计算机也可以产生相同的分布。取代“量子霸权”（Quantum Supremacy）这个称呼的，是“量子优势”（Quantum Advantage）。量子优势意味着量子计算机在处理某些领域问题上，超过了传统计算机的表现，相对于霸权而言，量子优势更注重量子算法，以及实际的领域应用。可以说，量子优势是NISQ量子计算机领域的皇冠，谁夺取了皇冠，谁就证明了量子计算机可以投入到现实应用中。相比为了制造出一个逻辑比特可能需要数万个物理比特的容错量子计算机而言，NISQ计算机被认为可以在短期的未来中被实现。因此，这个领域成为了量子计算研究的热门。

\sphinxAtStartPar
  量子\sphinxhyphen{}经典混合算法是一类近期提出的，适用于NISQ量子计算机上的算法。它的特点是量子计算机只处理整个算法中的一个部分，经典计算机负责处理其他部分。绝大多数量子\sphinxhyphen{}经典混合算法中都会存在一个类似于机器学习中的参数优化过程，其中，量子计算机处理一个包含多个参数的量子线路，并且对这些参数进行随机的初始化，量子计算机执行的结果会进一步被计算成一个损失函数，这个损失函数被输入到经典计算机的优化器中，从而修改这些参数，之后再通过量子计算机进行计算，如此循环，直到达到优化终止条件。例如损失函数收敛，达到最大优化步数等。

\sphinxAtStartPar
  第一个提出的量子\sphinxhyphen{}经典混合算法是变分本征求解器（Variational Quantum Eigensolver），即VQE算法，它可以被用于求解化学分子的基态，因此，这个算法可以被用于解决各类涉及化学计算的相关问题。对于经典计算机而言，要表示N个分子轨道的占据状态，需要用\$\$2\textasciicircum{}n\$\$维的线性空间去计算，因此，在计算具有超过50个轨道的分子时，就无法进行精确计算；而量子计算机的N个轨道正好需要N个量子比特完成模拟过程，所以这个问题可以在量子计算机上被有效的求解。现在，针对组合优化问题、机器学习问题，都有各种各样的量子\sphinxhyphen{}经典混合算法被提出，它们被认为是有希望在NISQ计算机上实现。

\sphinxAtStartPar
  由于量子经典混合算法的框架类似于在经典计算机上执行的机器学习算法，因此，可以利用类似于机器学习框架的系统去进行编程。本源量子所开发的VQNet框架，XanaduAI公司开发的PennyLane框架，都是在原有机器学习框架上扩展支持量子计算的部分。VQNet是基于符号运算的机器学习框架，它设置了“含参量子线路”（Variational Quantum Circuit），可以通过变量生成一个量子线路。通过含参量子线路可以进一步构建成量子算符（Quantum Operator），量子算符相当于对变量的运算，这种运算等价于一个普通的算符，支持求值和偏微分操作，因此，量子算符就可以容纳到机器学习这个框架中。利用VQNet可以实现目前绝大多数的量子\sphinxhyphen{}经典混合算法，包括VQE，QAOA，QCL……

\sphinxstepscope


\section{4.3 Deutsch\sphinxhyphen{}Josza算法}
\label{\detokenize{rst/4.3Deutsch-Josza_u7b97_u6cd5:deutsch-josza}}\label{\detokenize{rst/4.3Deutsch-Josza_u7b97_u6cd5::doc}}
\sphinxAtStartPar
  量子算法是量子计算落地实用的最大驱动力，好的量子算法设计将更快速推动量子计算的发展。

\sphinxAtStartPar
  Deutsch\sphinxhyphen{}Jozsa 量子算法，简称 D\sphinxhyphen{}J 算法， David Deutsch 和 Richard Jozsa 早在 1992 年提出了该算法，这是第一个展示了量子计算和经典计算在解决具体问题时所具有明显差异性的算法。

\sphinxAtStartPar
  D\sphinxhyphen{}J 算法是这样描述的：给定两个不同类型的函数，通过计算，判断该函数是属于哪一类型的函数，其可用来演示说明量子计算如何在计算能力上远超经典计算。

\sphinxAtStartPar
  D\sphinxhyphen{}J 算法所阐述的问题是：考虑一个函数 \(f(x)\) , 它将  \(n\)  个字符串  \(x\) 作为输入并返回  \(0\) 或  \(1\) 。注意， \(n\) 个字符串也是由 \(0\) 和 \(1\) 组成，函数形式如图4.3.1所示：

\sphinxAtStartPar
  考虑 \(n=1\) 的情况：
\begin{equation*}
\begin{split}f:\{0,1\} \rightarrow\{0,1\}\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.1}.png}\hspace*{\fill}}

\begin{center}图4.3.1 函数形式
\end{center}\begin{equation*}
\begin{split}f:\{0,1\}^{n} \rightarrow\{0,1\}\end{split}
\end{equation*}
\sphinxAtStartPar
  这个函数称为常数函数。如果对任意 \(f(x)\) 都等于 \(0\) 或者 \(f(x)\) 都等于 \(1\) ​：
\begin{equation*}
\begin{split}f(x) =0 \ or \ f(x) = 1\end{split}
\end{equation*}
\sphinxAtStartPar
  而如果 \(f(x) = 0\) 的个数等于 \(f(x) = 1\) 的个数，则称这个函数为平衡函数：
\begin{quote}

\sphinxAtStartPar
\(f(x) =0\) 的个数等于 \(f(x) = 1\) 的个数
\end{quote}

\sphinxAtStartPar
  考虑一下最简单的情况：当 \(n=1\) 的时候，常数函数的类型是这样的： \(f(0)\) ， \(f(1)\) 都指向 \(0\) ；或者 \(f(0)\) ， \(f(1)\) 都指向 \(1\) ，而平衡函数则是各占一半。回顾问题，要解决的是：给定输入和输出，如何快捷地判断 \(f(x)\) 是属于常数函数，或是平衡函数。

\sphinxAtStartPar
  如图4.3.2，在经典算法中，给定了输入之后，第一步是需要判断 \(f(0)\) ， \(f(0)\) 有两种情况， \(f(0) = 0\) 或者 \(f(0) = 1\) ；当确定  \(f(0)\) 之后，再判断 \(f(1)\) ，确定了 \(f(1)\) 的值之后，就可以确定该函数的类型；整个过程需要两次，才可以判断函数的类型。按照这样的方式，对于经典算法 \(n\) 个输入，在最糟糕的情况下 \(f\) 必须要 \(2^{n-1}+1\) 次才能判断出函数属于哪一类，即，最糟糕情形需要验证一半多一个数据；而如果使用量子算法，仅需  \(1\) 次就可以判断出结果。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.2}.png}\hspace*{\fill}}

\begin{center}图4.3.2  经典算法
\end{center}
\sphinxAtStartPar
  通过图4.3.3所示的量子线路图来理解该算法是如何解决问题的。首先，对所有的比特都执行Hadamard 门操作，然后经过黑盒子 \(U_f\) ，再对工作比特添加 Hadamard 门，然后测量。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.3}.png}\hspace*{\fill}}

\begin{center}图4.3.3 量子线路图
\end{center}
\sphinxAtStartPar
  按照实施步骤，表达形式：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
初始化

\end{enumerate}
\begin{equation*}
\begin{split}|0\rangle^{\otimes n}|1\rangle\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
使用 Hadamard 门来构建叠加态

\end{enumerate}
\begin{equation*}
\begin{split}\rightarrow \frac{1}{\sqrt{2}} \sum_{x=0}^{2^{n}-1}|x\rangle\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
使用  \(U_f\) 来计算函数  \(f\)

\end{enumerate}
\begin{equation*}
\begin{split}\rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{x}|x\rangle\left[\frac{|0\oplus f(x)\rangle-|1\oplus f(x)\rangle}{\sqrt{2}}\right] \\= \frac{1}{\sqrt{2^{n}}} \sum_{x}(-1)^{f(x)}|x\rangle\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
此处 \(\oplus\) 运算表示求和后整除 \(2\) 。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
在工作位上添加 Hadamard 门

\end{enumerate}
\begin{equation*}
\begin{split}\rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{z} \sum_{x}(-1)^{x \cdot z+f(x)}|z\rangle\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
测量工作位，输出结果，一次性就可以判断出结果

\end{enumerate}
\begin{equation*}
\begin{split}\rightarrow \mathrm{Z}\end{split}
\end{equation*}

\subsection{4.3.1 在本源量子云计算服务平台上实现D\sphinxhyphen{}J算法}
\label{\detokenize{rst/4.3Deutsch-Josza_u7b97_u6cd5:d-j}}
\sphinxAtStartPar
  访问本源量子云平台：\sphinxurl{https://qcloud.originqc.com.cn/} ，选择仿真开发训练云进入量子线路编程页面。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.4}.png}\hspace*{\fill}}

\begin{center}图4.3.4 本源量子云平台量子线路编程
\end{center}
\sphinxAtStartPar
  首先新建项目“D\sphinxhyphen{}J算法”，点击保存。本源量子云平台提供包括“本源悟源1号”、“本源悟源2号”等在内的多种计算后端，本例选择“全振幅量子虚拟机”为计算后端。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.5}.png}\hspace*{\fill}}

\begin{center}图4.3.5 创建项目
\end{center}
\sphinxAtStartPar
  点击设置按钮（“”），可以设置实验参数。在模拟类型上，可以选择两种：Monte\sphinxhyphen{}Carlo方法和概率方法。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.6}.png}\hspace*{\fill}}

\begin{center}图4.3.6 参数设置
\end{center}
\sphinxAtStartPar
  Monte\sphinxhyphen{}Carlo方法：通过多次数值模拟，对测量结果进行仿真。

\sphinxAtStartPar
  概率方法：直接计算出需要的比特概率分布，而不需要真正的去计算测量过程。

\sphinxAtStartPar
  其中概率方法比Monte\sphinxhyphen{}Carlo方法运行会快一些；由于是多次随机，Monte\sphinxhyphen{}Carlo方法每次运行的结果可能会不一样。这里选择Monte\sphinxhyphen{}Carlo方法。

\sphinxAtStartPar
  以两个量子比特的D\sphinxhyphen{}J算法为例，它需要使用2个量子比特和1个经典寄存器去保存一次测量的值，输入好之后，点击保存。将线路上方的逻辑门通过鼠标拖拽到线路上，即可构建量子线路。

\sphinxAtStartPar
  根据D\sphinxhyphen{}J算法的内容，首先需要在第一条线上添加一个Hadamard门。拖拽 \(H\) 就可以在线路上插入一个Hadamard门。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.7}.png}\hspace*{\fill}}

\begin{center}图4.3.7 拖入H门
\end{center}
\sphinxAtStartPar
  插入逻辑门之后，双击这个逻辑门可以删除，也可以通过鼠标拖动这个门的位置；同样在其他地方点击，可以插入更多的量子逻辑门。根据DJ算法，将除了Oracle的部分添加上：

\sphinxAtStartPar
  中间空出来的部分，就是Oracle可以插入的部分了。

\sphinxAtStartPar
  有很多量子算法，Oracle是作为输入给出的，比如DJ算法和Grover算法等。所以，两比特DJ算法的量子程序就已经写好了。

\sphinxAtStartPar
  这里，可以插入不同的Oracle试验一下；定义Oracle的输入输出是：
\begin{equation*}
\begin{split}|x\rangle|y\rangle \rightarrow|x\rangle|f(x)+y \bmod 2\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  这里 \(f(x)\) 会根据Oracle不同而编码到量子线路中，例如一个 \(CNOT\) 门就可以做一个Oracle。

\sphinxAtStartPar
  一个 \(CNOT\) 门的效果是 \(|\mathrm{x}\rangle|\mathrm{y}\rangle \rightarrow|x\rangle|(x+y) \mathrm{mod} 2\rangle\) ，对比上面的Oracle公式，相当于 \(f(x)=x\) 。由此，可以看出 \(f(0)=0, f(1)=1\) ，因此是一个平衡函数。

\sphinxAtStartPar
  这个门能产生的效果是 \(|x\rangle|y\rangle \rightarrow|x\rangle|(1+y) \bmod 2\rangle\) ，对比上面的Oracle公式，相当于 \(f(x)=1\) ，这是一个常数函数。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.8}.png}\hspace*{\fill}}

\begin{center}图4.3.8 CNOT与 Pauli\sphinxhyphen{}X 组合门
\end{center}
\sphinxAtStartPar
  这个相当于把两种情况组合起来了，效果是  \(|\mathrm{x}\rangle|\mathrm{y}\rangle \rightarrow|x\rangle|(x+y+1) \mathrm{mod} 2\rangle\) ，因此对应了 \(f(x)=x+1\) ，同理，这是一个平衡函数。

\sphinxAtStartPar
  依次来检验这三种Oracle，DJ算法是否能输出正确的结果。

\sphinxAtStartPar
第一种： \(CNOT\)

\sphinxAtStartPar
  构建如图4.3.9所示的量子线路图，并设置如图4.3.10所示参数。设置重复实验次数为为默认次数100次；点击运行，就可以运行这个量子程序了。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.9}.png}\hspace*{\fill}}

\begin{center}图4.3.9 量子线路图
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.10}.png}\hspace*{\fill}}

\begin{center}图4.3.10 设置实验参数
\end{center}
\sphinxAtStartPar
  点击查看任务结果，如图4.3.11。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.11}.png}\hspace*{\fill}}

\begin{center}图4.3.11 查看任务结果
\end{center}
\sphinxAtStartPar
  查看“概率统计图”，可以看到在第一个量子比特上得到100\%的1的测量值，如图4.3.12；这个柱状图的横轴表示不同的测量值，纵轴表示这个测量值对应的概率。这里只测到了1，概率为100\%，符合预期。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.12}.png}\hspace*{\fill}}

\begin{center}图4.3.12 任务结果—概率统计图
\end{center}
\sphinxAtStartPar
  依次测试另外两种Oracle：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.13}.png}\hspace*{\fill}}

\begin{center}图4.3.13 量子线路图
\end{center}
\sphinxAtStartPar
  对于这种情况，可以看到测量值100\%为0。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.14}.png}\hspace*{\fill}}

\begin{center}图4.3.14 任务结果—概率统计图
\end{center}
\sphinxAtStartPar
第三种情况：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.15}.png}\hspace*{\fill}}

\begin{center}图4.3.15 量子线路图
\end{center}
\sphinxAtStartPar
  由此，可以得到100\%的1，说明这个Oracle代表一个平衡函数。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.3.16}.png}\hspace*{\fill}}

\begin{center}图4.3.16 任务结果—概率统计图
\end{center}

\subsection{4.3.2 在QPanda上实现DJ算法}
\label{\detokenize{rst/4.3Deutsch-Josza_u7b97_u6cd5:qpandadj}}
\sphinxAtStartPar
  下面的代码可以在github的QPanda仓库中的Applications/DJ\_Algorithm/DJ\_Algorithm.cpp中找到。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Core/Utilities/Tools/Utils.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QAlg/DJ\PYGZus{}Algorithm/DJ\PYGZus{}Algorithm.h\PYGZdq{}}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPandaNamespace.h\PYGZdq{}}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Core/Core.h\PYGZdq{}}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}vector\PYGZgt{}}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}\PYG{n}{DJ\PYGZus{}Oracle} \PYG{n}{generate\PYGZus{}two\PYGZus{}qubit\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{oracle\PYGZus{}function}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{p}{[}\PYG{n}{oracle\PYGZus{}function}\PYG{p}{]}\PYG{p}{(}\PYG{n}{QVec} \PYG{n}{qubit1}\PYG{p}{,} \PYG{n}{Qubit}\PYG{o}{*} \PYG{n}{qubit2}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{12.}        \PYG{n}{QCircuit} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{13.}        \PYG{k}{if} \PYG{p}{(}\PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n}{false} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
\PYG{l+m+mf}{14.}            \PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{l+m+mf}{15.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{16.}            \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{17.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{18.}        \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n}{true} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
\PYG{l+m+mf}{19.}            \PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{false}\PYG{p}{)}
\PYG{l+m+mf}{20.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{21.}            \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubit2}\PYG{p}{)}
\PYG{l+m+mf}{22.}                \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{X}\PYG{p}{(}\PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{23.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{24.}        \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n}{true} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
\PYG{l+m+mf}{25.}            \PYG{n}{oracle\PYGZus{}function}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{l+m+mf}{26.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{27.}            \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{X}\PYG{p}{(}\PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{28.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{29.}        \PYG{k}{else}
\PYG{l+m+mf}{30.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{31.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{32.}        \PYG{k}{return} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{33.}    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{l+m+mf}{34.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}\PYG{n}{void} \PYG{n}{two\PYGZus{}qubit\PYGZus{}deutsch\PYGZus{}jozsa\PYGZus{}algorithm}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{boolean\PYGZus{}function}\PYG{p}{)}
\PYG{l+m+mf}{37.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{38.} \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{39.} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{40.}    \PYG{n}{auto} \PYG{n}{oracle} \PYG{o}{=} \PYG{n}{generate\PYGZus{}two\PYGZus{}qubit\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{boolean\PYGZus{}function}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{41.}
\PYG{l+m+mf}{42.} \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{deutschJozsaAlgorithm}\PYG{p}{(}\PYG{n}{boolean\PYGZus{}function}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{qvm}\PYG{p}{,} \PYG{n}{oracle}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{43.} \PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{44.} \PYG{k}{if} \PYG{p}{(}\PYG{n}{result}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{false}\PYG{p}{)}
\PYG{l+m+mf}{45.} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{46.}         \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Constant function!}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{47.} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{48.} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{result}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{l+m+mf}{49.} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{50.}         \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Balanced function!}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{51.} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{52.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{53.}
\PYG{l+m+mf}{54.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{55.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{56.} \PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{57.}         \PYG{n+nb}{bool} \PYG{n}{fx0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fx1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{58.}         \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{input the input function}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}
\PYG{l+m+mf}{59.}                 \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The function has a boolean input}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}
\PYG{l+m+mf}{60.}                 \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{and has a boolean output}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}
\PYG{l+m+mf}{61.}                 \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f(0)= (0/1)?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{l+m+mf}{62.}         \PYG{n}{cin} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{fx0}\PYG{p}{;}
\PYG{l+m+mf}{63.}         \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f(1)=(0/1)?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{l+m+mf}{64.}         \PYG{n}{cin} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{fx1}\PYG{p}{;}
\PYG{l+m+mf}{65.}         \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{oracle\PYGZus{}function}\PYG{p}{(}\PYG{p}{\PYGZob{}} \PYG{n}{fx0}\PYG{p}{,}\PYG{n}{fx1} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{66.}         \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Programming the circuit...}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{67.}         \PYG{n}{two\PYGZus{}qubit\PYGZus{}deutsch\PYGZus{}jozsa\PYGZus{}algorithm}\PYG{p}{(}\PYG{n}{oracle\PYGZus{}function}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{68.} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{69.} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{70.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  整个文件利用QPanda的组件实现了一个Deutsch\sphinxhyphen{}Jozsa算法，并且提供了一个2 Qubit的示例。各个模块的介绍：

\sphinxAtStartPar
\sphinxstylestrong{1. Deutsch\_Jozsa\_algorithm函数}

\sphinxAtStartPar
  在实现这个函数的时候，并不是仅仅考虑了2 qubit的情况，而是对更一般的情况，即所有qubit的情况进行处理。

\sphinxAtStartPar
  QPanda的核心逻辑在于对申请的量子比特进行量子线路构建，因此，这个函数会返回一个QProg类型，这个QProg类型会被放到量子机器中进行执行。

\sphinxAtStartPar
  Deutsch\_Jozsa\_algorithm的参数有4个：

\sphinxAtStartPar
​  vector<Qubit*> qubit1：一组qubit，它对应了上面所述的工作比特；

\sphinxAtStartPar
​  Qubit* qubit2：一个qubit，它对应的是算法中的辅助比特；

\sphinxAtStartPar
​  vector cbit：一组cbit，它对应的是qubit 1的测量值；

\sphinxAtStartPar
​  DJ\_Oracle oracle：输入的，待计算的Oracle

\sphinxAtStartPar
  因此，这个算法的逻辑就可以表述为：通过输入的qubit1, qubit2构建量子线路；并且将oracle作用在qubit1和qubit2上；最后，对qubit1测量到cbit上。这个函数将量子算法的流程通过QPanda的组件编写出来，整个流程会被写入到一个QProg类型的对象中，最终，这个函数会返回这个对象。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  在函数中，首先可以通过QProg函数去创建一个空的量子程序。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{X}\PYG{p}{(}\PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{apply\PYGZus{}QGate}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  将逻辑门插入到这个量子程序的后面，依次是X门作用在qubit2上（将qubit2初始化为|1⟩），对qubit1和qubit2执行Hadamard门。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{oracle}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{,} \PYG{n}{qubit2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  制备完纠缠态之后，就可以进行oracle计算。这里同样将oracle插入到量子程序中。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{apply\PYGZus{}QGate}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{qubit1}\PYG{p}{,} \PYG{n}{cbit}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  最后同样是一组Hadamard门，并且通过MeasureAll将qubit1整个测量到cbit上。

\sphinxAtStartPar
\sphinxstylestrong{2. two\_qubit\_deutsch\_jozsa\_algorithm函数}

\sphinxAtStartPar
  这个函数对两个比特的情况提供了一个演示。在这种情况下，需要对不同情况构建oracle，并且输入到这个算法中。构建oracle的方式就是通过这个函数的参数——一个vector类型来代表一个函数。这个函数相当于一个真值表，例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{fx} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这表示fx{[}0{]} = 0，fx{[}1{]} = 1这种情况。

\sphinxAtStartPar
  通过真值表构建对应oracle的方法：即generate\_two\_qubit\_oracle，它恰好返回一个oracle类型，感兴趣的读者可以自行对这个oracle中的不同情况进行验证。

\sphinxAtStartPar
  这个函数中最重要的步骤就是初始化量子机器，申请量子比特和经典寄存器，取得量子程序，执行并且获得最终结果。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这个语句定义一个CPU执行的模拟器。可以指定为不同类型，例如GPU、单线程CPU、或者云量子计算机。并调用init()函数来初始化qvm。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{qvec} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{auto} \PYG{n}{c} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAlloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过qAlloc和cAlloc可以从量子机器中申请一定量的量子比特。Many表示很多，所以qAllocMany和cAllocMany可以一次性申请多个量子比特。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{oracle} \PYG{o}{=} \PYG{n}{generate\PYGZus{}two\PYGZus{}qubit\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{boolean\PYGZus{}function}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这个函数就是用于生成Oracle的。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{Deutsch\PYGZus{}Jozsa\PYGZus{}algorithm}\PYG{p}{(}\PYG{p}{\PYGZob{}} \PYG{n}{qvec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{qvec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{\PYGZob{}} \PYG{n}{c} \PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{oracle}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  这一段程序可以将上述量子程序打印出来。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{qvm}\PYG{o}{.}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{false}\PYG{p}{)}
\PYG{l+m+mf}{3.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{4.}          \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Constant function!}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{5.}  \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{6.}  \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{l+m+mf}{7.}  \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{8.}          \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Balanced function!}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{9.}  \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{10.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  函数directlyRun顾名思义是直接运行这个量子程序。QPanda提供很多运行量子程序的方式，而directlyRun表示这个量子程序在默认模式下运行1次。由于DJ算法是一个确定性算法，就只运行一次，运行结束后，可以从之前申请的经典寄存器中取得值：c.eval。这里false表示测量到|0⟩，true表示测量到|1⟩。通过测量的结果可以得到这个函数属于平衡函数还是常数函数。

\sphinxstepscope


\section{4.4 Grover算法}
\label{\detokenize{rst/4.4Grover_u7b97_u6cd5:grover}}\label{\detokenize{rst/4.4Grover_u7b97_u6cd5::doc}}
\sphinxAtStartPar
  什么是搜索算法呢？举一个简单的例子，在下班的高峰期，要从公司回到家里，开车走怎样的路线才能够耗时最短呢？最简单的想法，当然是把所有可能的路线一次一次的计算，根据路况计算每条路线所消耗的时间，最终可以得到用时最短的路线，即为最快路线，这样依次的将每一种路线计算出来，最终对比得到最短路线。搜索的速度与总路线数 \(N\) 相关，记为  \(O(N)\) ，而采用量子搜索算法，则可以以  \(O(sqrt(N))\) 的速度进行搜索，要远快于传统的搜索算法。

\sphinxAtStartPar
  那么怎么实现Grover搜索算法呢？

\sphinxAtStartPar
  首先，先化简一下搜索模型，将所有数据存在数据库中，假设有 \(n\) 个量子比特，用来记录数据库中的每一个数据的索引，一共可以表示 \(2^n\) 个数据，记为 \(N\) 个；希望搜索得到的数据有 \(M\) 个，为了表示一个数据是否是搜索的结果，建立一个函数：
\begin{equation*}
\begin{split}f(x)\left\{\begin{array}{l} 0\left(x \neq x_{0}\right) \\ 1\left(x=x_{0}\right) \end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(x_0\) 为搜索目标的索引值，也即是说，当搜索到目标时，函数值 \(f(x)\) 值为 \(1\) ，如果搜索的结果不是目标时， \(f(x)\) 值为 \(0\) 。假设有一个量子Oracle可以识别搜索问题的解，是别的结果通过Oracle的一个量子比特给出。可以将Oracle定义为:
\begin{equation*}
\begin{split}|x\rangle|q\rangle \stackrel{\text { Oracle }}{\longrightarrow}|x\rangle|q\oplus f(x)\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(|q \rangle\) 是一个结果寄存器, ⨁ 是二进制加法。通过Oracle可以实现，当搜索的索引为目标结果时，结果寄存器翻转；反之，结果寄存器值不变；从而可以通过判断结果寄存器的值，来确定搜索的对象是否为目标值。

\sphinxAtStartPar
  Oracle对量子态的具体操作是什么样的呢？同D\sphinxhyphen{}J算法相似，先将初态制备在 \(|0\rangle^{\otimes n}\)  \(|1\rangle\) 态上， \(|0\rangle^{\otimes n}\) 为查询寄存器， \(|1\rangle\) 为结果寄存器。 经过 Hardmard 门操作后，可以将查询寄存器的量子态，变为所有结果的叠加态；也即是说，经过了 Hardmard 门，就可以得到所有结果的索引，而结果寄存器则变为 \(\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)\) ，再使其通过Oracle，可以对每一个索引都进行一次检验，如果是目标结果，则将结果寄存器的量子态进行  \({0}\) 、 \({1}\) 翻转，即结果寄存器变为：
\begin{equation*}
\begin{split}\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)\stackrel{\text { Oracle }}{\longrightarrow}-\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)\end{split}
\end{equation*}
\sphinxAtStartPar
  而查询寄存器不变；但当检验的索引不是结果时，寄存器均不发生改变。因此，Oracle可以换一种表示方式：
\begin{equation*}
\begin{split}\left.\left.\right|\mathbf{x}\right\rangle\left(\frac{|0\rangle-|\mathbf{1}\rangle}{\sqrt{2}}\right) \stackrel{\text { Oracle }}{\longrightarrow}(-1)^{f(x)} |\mathbf{x}\rangle\left(\frac{(0)-|\mathbf{1}\rangle}{\sqrt{2}}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  其中， \(|x\rangle\) 是查询寄存器的等额叠加态中的一种情况。

\sphinxAtStartPar
  如上述所知，Oracle的作用，是通过改变了解的相位，标记了搜索问题的解。

\sphinxAtStartPar
  现在，将搜索问题的解通过相位标记区分出来，那么如何能够将量子态的末态变为已标记出的态呢？

\sphinxAtStartPar
  将问题换一种思路进行考虑，当查询寄存器由初态经过 Hardmard 门后，会变为所有可能情况的等额叠加态；也就是说，它包含着所有搜索问题的解与非搜索问题的解。可以将这个态记为:
\begin{equation*}
\begin{split}|\psi\rangle=\frac{1}{\sqrt{N}} \sum_{x}|\mathrm{x}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  将所有非搜索问题的解定义为一个量子态  \(|\alpha\rangle\) ,其中 \(\Sigma_{x_{1}}\) 代表着  \(x\) 上所有非搜索问题的解的和，记为:
\begin{equation*}
\begin{split}\left.\left.\right| \alpha\right\rangle=\frac{1}{\sqrt{N-M}} \sum_{x_1}|\mathrm{x}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  显然， \(|\beta\rangle\) 为最终的量子态，而且  \(|\alpha\rangle\) 和  \(|\beta\rangle\) 相互正交。利用简单的代数运算，就可以将初态  \(|\psi\rangle\) 重新表示为:
\begin{equation*}
\begin{split}\left.\left.\right| \psi \right\rangle=\sqrt{\frac{N-M}{N}}|\alpha\rangle^{+} \sqrt{\frac{M}{N}}|\beta\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  初始态被搜索问题的解的集合和非搜索问题的解的集合重新定义，也即是说，初态属于  \(|\alpha\rangle\) 与  \(|\beta\rangle\) 张成的空间。因此，可以用平面向量来表示这三个量子态，如图4.4.1所示:

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps577}.jpg}\hspace*{\fill}}

\begin{center}图4.4.1
\end{center}
\sphinxAtStartPar
  那么，Oracle作用在新的表示方法下的初态会产生怎样的影响呢？Oracle的作用是用负号标记搜索问题的解，所以，相当于将  \(|\beta\rangle\) 内每一个态前均增加一个负号，将所有的负号提取出来，可以得到：
\begin{equation*}
\begin{split}|\psi\rangle\stackrel{\text { Oracle }}{\longrightarrow} \ \sqrt{\frac{N-M}{N}}|\alpha\rangle^{-} \sqrt{\frac{\mathrm{M}}{N}}|\beta\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  对应在平面向量中，相当于将  \(|\psi\rangle\) 做关于  \(|\alpha\rangle\) 轴的对称，但仅有这一种操作是无法将量子态从  \(|\psi\rangle\) 变为 \(|\beta\rangle\) ，还需要另一种对称操作。

\sphinxAtStartPar
  第二种对称操作，是将量子态关于 \(|\psi\rangle\) 对称的操作，这个操作由三个部分构成：

\sphinxAtStartPar
  1. 将量子态经过一个 Hardmard 门；

\sphinxAtStartPar
  2. 对量子态进行一个相位变换，将 \(|0\rangle^{\otimes n}\) 态的系数保持不变，将其他的量子态的系数增加一个负号，相当于 \(2|0\rangle\langle 0|-\mathrm{I}\) 酉变换算子；

\sphinxAtStartPar
  3. 再经过一个 Hardmard 门。

\sphinxAtStartPar
  这三步操作的数学表述为:
\begin{equation*}
\begin{split}\mathrm{H}^{\otimes n}\left(2|0\rangle\langle 0|-\mathrm{I}) \mathrm{H} ^{\otimes n}=2|\psi\rangle\langle\psi|-\mathrm{1}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
  上述过程涉及到复杂的量子力学知识，这三部分的操作，只是为了实现将量子态关于 \(|\psi\rangle\) 对称。如果想了解为什么这三步操作可以实现，可以阅读关于量子计算相关书籍进一步理解。

\sphinxAtStartPar
  前面介绍的两种对称操作，合在一起称为一次Grover迭代。假设初态 \(|\psi\rangle\) 与  \(|\alpha\rangle\) 可以表示为：
\begin{equation*}
\begin{split}|\psi\rangle=\cos \frac{\theta}{2}|\alpha\rangle+\sin \frac{\theta}{2}|\beta\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  很容易得到：
\begin{equation*}
\begin{split}\cos \frac{\theta}{2}=\sqrt{\frac{N-M}{N}}\end{split}
\end{equation*}
\sphinxAtStartPar
  可以从几何图像上看到，每一次Grover迭代，可以使量子态逆时针旋转 \(\theta\) ，经历了k次Grover迭代，末态的量子态为：
\begin{equation*}
\begin{split}G^{k}|\psi\rangle=\cos \left(\frac{2 k+1}{2} \theta\right)|\alpha\rangle+\sin \left(\frac{2 k+1}{2} \theta\right)|\beta\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  因此，经过多次迭代操作，总可以使末态在 \(|\beta\rangle\) 态上概率很大，满足精确度的要求。经过严格的数学推导，可证明，迭代的次数  \(R\) 满足:
\begin{equation*}
\begin{split}\mathrm{R} \leq \frac{\pi}{4} \sqrt{\frac{N}{M}}\end{split}
\end{equation*}
\sphinxAtStartPar
  参考路线图4.4.2：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.4.2}.png}\hspace*{\fill}}

\begin{center}图4.4.2 线路图
\end{center}
\sphinxAtStartPar
  QPanda实现 Grover 算法的代码示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Core/Core.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Core/Utilities/Tools/Utils.h\PYGZdq{}}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QAlg/Grover/GroverAlgorithm.h\PYGZdq{}}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QAlg/Grover/QuantumWalkGroverAlg.h\PYGZdq{}}
\PYG{l+m+mf}{5.}
\PYG{l+m+mf}{6.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{7.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}\PYG{n}{static} \PYG{n}{size\PYGZus{}t} \PYG{n}{g\PYGZus{}shot} \PYG{o}{=} \PYG{l+m+mi}{100000}\PYG{p}{;}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}\PYG{n}{static} \PYG{n}{uint32\PYGZus{}t} \PYG{n}{quantum\PYGZus{}grover\PYGZus{}search}\PYG{p}{(}\PYG{n}{const} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{search\PYGZus{}space}\PYG{p}{,} \PYG{n}{const} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{search\PYGZus{}data}\PYG{p}{,}
\PYG{l+m+mf}{12.} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{search\PYGZus{}result}\PYG{p}{)}
\PYG{l+m+mf}{13.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{14.} \PYG{n}{search\PYGZus{}result}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{15.} \PYG{n}{uint32\PYGZus{}t} \PYG{n}{search\PYGZus{}times} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{16.} \PYG{n}{uint32\PYGZus{}t} \PYG{n}{repeat\PYGZus{}times} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{17.}    \PYG{n}{auto} \PYG{n}{machine} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{18.}    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{19.} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{setConfigure}\PYG{p}{(}\PYG{p}{\PYGZob{}} \PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.} \PYG{n}{CPUQVM} \PYG{n}{\PYGZus{}tmp\PYGZus{}qvm}\PYG{p}{;}
\PYG{l+m+mf}{22.} \PYG{n}{\PYGZus{}tmp\PYGZus{}qvm}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{23.} \PYG{n}{auto} \PYG{n}{x} \PYG{o}{=} \PYG{n}{\PYGZus{}tmp\PYGZus{}qvm}\PYG{o}{.}\PYG{n}{allocateCBit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{24.}
\PYG{l+m+mf}{25.} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{search\PYGZus{}result\PYGZus{}for\PYGZus{}check}\PYG{p}{;}
\PYG{l+m+mf}{26.} \PYG{k}{for} \PYG{p}{(}\PYG{n}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{search\PYGZus{}space}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{l+m+mf}{27.} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{28.}         \PYG{k}{if} \PYG{p}{(}\PYG{n}{search\PYGZus{}space}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{search\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{29.}                 \PYG{n}{search\PYGZus{}result\PYGZus{}for\PYGZus{}check}\PYG{o}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{30.}         \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{31.} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{32.}
\PYG{l+m+mf}{33.} \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Grover will search through }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{search\PYGZus{}space}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ data.}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{34.} \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Start grover search algorithm:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.} \PYG{n}{QProg} \PYG{n}{grover\PYGZus{}Qprog}\PYG{p}{;}
\PYG{l+m+mf}{37.} \PYG{n}{QVec} \PYG{n}{measure\PYGZus{}qubits}\PYG{p}{;}
\PYG{l+m+mf}{38.} \PYG{n}{uint32\PYGZus{}t} \PYG{n}{qubit\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{39.} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{ClassicalCondition}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{;}
\PYG{l+m+mf}{40.} \PYG{n}{const} \PYG{n}{double} \PYG{n}{max\PYGZus{}repeat} \PYG{o}{=} \PYG{l+m+mf}{3.1415926} \PYG{o}{*} \PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{n}{search\PYGZus{}space}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{n}{search\PYGZus{}result\PYGZus{}for\PYGZus{}check}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{4.0}\PYG{p}{;}
\PYG{l+m+mf}{41.} \PYG{k}{while} \PYG{p}{(}\PYG{n}{true}\PYG{p}{)}
\PYG{l+m+mf}{42.} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{43.}         \PYG{n}{measure\PYGZus{}qubits}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{44.}         \PYG{n}{grover\PYGZus{}Qprog} \PYG{o}{=} \PYG{n}{build\PYGZus{}grover\PYGZus{}prog}\PYG{p}{(}\PYG{n}{search\PYGZus{}space}\PYG{p}{,} \PYG{n}{x} \PYG{o}{==} \PYG{n}{search\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{machine}\PYG{p}{,} \PYG{n}{measure\PYGZus{}qubits}\PYG{p}{,} \PYG{o}{+}\PYG{o}{+}\PYG{n}{repeat\PYGZus{}times}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{45.}         \PYG{n}{search\PYGZus{}times} \PYG{o}{+}\PYG{o}{=} \PYG{n}{repeat\PYGZus{}times}\PYG{p}{;}
\PYG{l+m+mf}{46.}
\PYG{l+m+mf}{47.}         \PYG{k}{if} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{==} \PYG{n}{qubit\PYGZus{}size}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{48.}                 \PYG{n}{QVec} \PYG{n}{\PYGZus{}qv}\PYG{p}{;}
\PYG{l+m+mf}{49.}                 \PYG{n}{qubit\PYGZus{}size} \PYG{o}{=} \PYG{n}{grover\PYGZus{}Qprog}\PYG{o}{.}\PYG{n}{get\PYGZus{}used\PYGZus{}qubits}\PYG{p}{(}\PYG{n}{\PYGZus{}qv}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{50.}                 \PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of used\PYGZhy{}qubits: }\PYG{l+s+si}{\PYGZpc{}u}\PYG{l+s+s2}{.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{51.}         \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{52.}
\PYG{l+m+mf}{53.}         \PYG{k}{if} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{==} \PYG{n}{c}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{54.}                 \PYG{n}{c} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{allocateCBits}\PYG{p}{(}\PYG{n}{measure\PYGZus{}qubits}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{55.}         \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{56.}
\PYG{l+m+mf}{57.}         \PYG{n}{grover\PYGZus{}Qprog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{measure\PYGZus{}qubits}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{58.}         \PYG{n}{write\PYGZus{}to\PYGZus{}originir\PYGZus{}file}\PYG{p}{(}\PYG{n}{grover\PYGZus{}Qprog}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{machine}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Grover\PYGZus{}prog.ir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{59.}
\PYG{l+m+mf}{60.}         \PYG{n}{auto} \PYG{n}{result} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{grover\PYGZus{}Qprog}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{g\PYGZus{}shot}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{61.}
\PYG{l+m+mf}{62.}         \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{n}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{normal\PYGZus{}result}\PYG{p}{;}
\PYG{l+m+mf}{63.}         \PYG{k}{for} \PYG{p}{(}\PYG{n}{const} \PYG{n}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}r} \PYG{p}{:} \PYG{n}{result}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{64.}                 \PYG{n}{normal\PYGZus{}result}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{\PYGZus{}r}\PYG{o}{.}\PYG{n}{first}\PYG{p}{,} \PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{n}{\PYGZus{}r}\PYG{o}{.}\PYG{n}{second}\PYG{o}{/}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{n}{g\PYGZus{}shot}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{65.}         \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{66.}         \PYG{n}{search\PYGZus{}result} \PYG{o}{=} \PYG{n}{search\PYGZus{}target\PYGZus{}from\PYGZus{}measure\PYGZus{}result}\PYG{p}{(}\PYG{n}{normal\PYGZus{}result}\PYG{p}{,} \PYG{n}{measure\PYGZus{}qubits}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{67.}         \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{search\PYGZus{}result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{68.}                 \PYG{o}{|}\PYG{o}{|} \PYG{p}{(}\PYG{p}{(}\PYG{n}{search\PYGZus{}result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{max\PYGZus{}repeat} \PYG{o}{\PYGZlt{}} \PYG{n}{repeat\PYGZus{}times}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{69.}                 \PYG{k}{break}\PYG{p}{;}
\PYG{l+m+mf}{70.}         \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{71.} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{72.} \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Draw grover\PYGZus{}Qprog:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{grover\PYGZus{}Qprog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{73.}    \PYG{k}{return} \PYG{n}{search\PYGZus{}times}\PYG{p}{;}
\PYG{l+m+mf}{74.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{75.}
\PYG{l+m+mf}{76.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{n}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{77.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{78.} \PYG{n+nb}{int} \PYG{n}{search\PYGZus{}type} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mf}{79.} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{search\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{21}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{l+m+mf}{80.} \PYG{o}{/}\PYG{o}{*} \PYG{n}{run} \PYG{n}{search} \PYG{n}{algorithm} \PYG{o}{*}\PYG{o}{/}
\PYG{l+m+mf}{81.} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{search\PYGZus{}result}\PYG{p}{;}
\PYG{l+m+mf}{82.} \PYG{n}{uint32\PYGZus{}t} \PYG{n}{search\PYGZus{}cnt} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{83.} \PYG{k}{try}
\PYG{l+m+mf}{84.} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{85.}         \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{search\PYGZus{}sapce}\PYG{p}{;}
\PYG{l+m+mf}{86.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{87.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{88.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{89.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{90.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{91.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{92.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{93.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{94.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{95.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{96.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{97.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{98.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{99.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{100.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{101.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{102.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{103.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{104.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{105.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{106.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{107.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{108.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{109.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{110.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{111.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{112.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{113.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{114.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{115.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{116.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{117.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{118.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{119.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{120.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{121.}        \PYG{n}{search\PYGZus{}sapce}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{122.}
\PYG{l+m+mf}{123.}                \PYG{n}{search\PYGZus{}cnt} \PYG{o}{=} \PYG{n}{quantum\PYGZus{}grover\PYGZus{}search}\PYG{p}{(}\PYG{n}{search\PYGZus{}sapce}\PYG{p}{,} \PYG{n}{search\PYGZus{}data}\PYG{p}{,} \PYG{n}{search\PYGZus{}result}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{124.}
\PYG{l+m+mf}{125.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{126.}        \PYG{n}{catch} \PYG{p}{(}\PYG{n}{const} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
\PYG{l+m+mf}{127.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{128.}                \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Got a exception: }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{e}\PYG{o}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{129.}                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mf}{130.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{131.}        \PYG{n}{catch} \PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{l+m+mf}{132.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{133.}                \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Got an unknow exception: }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{134.}                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{l+m+mf}{135.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{136.}
\PYG{l+m+mf}{137.}        \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Search result:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{l+m+mf}{138.}        \PYG{k}{for} \PYG{p}{(}\PYG{n}{const} \PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{result\PYGZus{}item} \PYG{p}{:} \PYG{n}{search\PYGZus{}result}\PYG{p}{)}
\PYG{l+m+mf}{139.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{140.}                \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{result\PYGZus{}item} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{l+m+mf}{141.}        \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{142.}        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{143.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstepscope


\section{4.5 QAOA算法}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:qaoa}}\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5::doc}}
\sphinxAtStartPar
  QAOA算法（Quantum Approximate Optimization Algorithm），又名量子近似优化算法，是由Edward Farhi, Jeffrey Goldstone和Sam Gutmann开发的一个多项式时间算法，用于寻找“最优化问题的一种‘好’的解决方案” 。

\sphinxAtStartPar
  Farhi, Goldstone和Gutmann都是现今量子计算领域有名的教授，其中Edward Farhi和Jeffrey Goldstone是麻省理工学院的名誉教授。他们在2000年一起发表了绝热演化量子计算算法，2014年在此基础上他们又共同发表了量子近似优化算法（QAOA）。

\sphinxAtStartPar
  这个名字是什么意思呢？对于给定的NP\sphinxhyphen{}Hard问题，近似算法是一种多项式时间算法，该算法以期望的一些质量保证来解决每个问题实例，其中品质因数是多项式时间解的质量与真实解的质量之间的比率。QAOA算法很有意思的一个原因是它具有展示量子霸权的潜力。


\subsection{4.5.1 最大切割问题}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id1}}
\sphinxAtStartPar
  最大切割问题（MAXCUT）是原始量子近似优化算法论文中描述的第一个应用。此问题类似于图形着色，对于给定节点和边的图形，并给每个边分配一个分值，接着将每个节点着色为黑色或白色，然后计算不同颜色节点边的分值之和，目的是找到一组得分最高的着色方式；更正式地表述是将图的节点划分为两组，使得连接相对组中的节点的边的数量最大化。例如图4.5.1的杠铃图:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{4.5.1}.png}\hspace*{\fill}}

\begin{center}图4.5.1 杠铃图
\end{center}
\sphinxAtStartPar
  有4种方式将节点分为两组：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.2}.png}\hspace*{\fill}}

\begin{center}图4.5.2 四个分组
\end{center}
\sphinxAtStartPar
  图4.5.2中仅对连接不同集合中的节点时才会绘制边，带有剪刀符号的线条表示需要计算的切割边。对于杠铃图，有两个相等的权重分组对应于最大切割（如上图中间两个分组），将杠铃切成两半。可以将“组0”或“组1”中的节点表示为 0 或 1，组成一个长度为N的比特串 。上图的四个分组可以表示为
\begin{equation*}
\begin{split}\{00,01,10,11\}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中最左边的比特对应节点 A，最右边的比特对应节点 B。 用比特串来表示使得表示图的特定分组变得很容易，每个比特串具有相关联的切割权重。

\sphinxAtStartPar
  对任意一个图，最大切割所使用的比特串长度是  \(N\) ，可分割的情况总数是 \(2^N\) 。例如，方形环图4.5.3：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{4.5.3}.png}\hspace*{\fill}}

\begin{center}图4.5.3 方形环图
\end{center}
\sphinxAtStartPar
  有16个可能的分组 ( \(2^4\) )。图4.5.4是四种可能的节点分组方式：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.4}.png}\hspace*{\fill}}

\begin{center}图4.5.4 四种可能的节点分布
\end{center}
\sphinxAtStartPar
  与每个分组相关联的比特串如上图所示，其中最右边的比特对应节点 A，最左边的比特对应节点 D。绘制出切割边，这样就可以很清楚的看到不同分组对应的边的切割情况。

\sphinxAtStartPar
  假设令方形图切割边的值都为1，可以将方形图中的切割方案全部枚举出来，如表4.5.1所示

\begin{center}表4.5.1 切割方案及切割值
\end{center}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
切割方案
&
\sphinxAtStartPar
切割值
&
\sphinxAtStartPar
切割方案
&
\sphinxAtStartPar
切割值
\\
\sphinxhline
\sphinxAtStartPar
\(|0000\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1000\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0001\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1001\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0010\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1010\rangle\)
&
\sphinxAtStartPar
\(4\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0011\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1011\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0100\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1100\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0101\rangle\)
&
\sphinxAtStartPar
\(4\)
&
\sphinxAtStartPar
\(|1101\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0110\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1110\rangle\)
&
\sphinxAtStartPar
\(2\)
\\
\sphinxhline
\sphinxAtStartPar
\(|0111\rangle\)
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(|1111\rangle\)
&
\sphinxAtStartPar
\(0\)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
  通过查表很容易可以找到最优的切割方案。

\sphinxAtStartPar
  从前面对杠铃图和方形图的示例介绍，知道可以通过枚举的方式找到最优的切割方案，并且枚举的数量跟节点个数有关，如果有N个节点，则枚举的数量是 \(2^N\) 。对于最大切割问题，在节点数较少的情况下，可以通过枚举的方式找到最优方案。但是，随着节点数的增加其计算时间复杂度也成指数级的增加。

\sphinxAtStartPar
  当遇到1000个，10000个或者更多的节点时，还能通过枚举的方式来解决这个问题吗？

\sphinxAtStartPar
  答案是不能的，对于10000个节点来说，就算把全球的计算资源都加起来也要计算很长的时间，那是否有其他的解决方案呢？答案是有的，QAOA其实就是最大切割的一种解决方案。


\subsection{4.5.2 布尔可满足性问题}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id2}}
\sphinxAtStartPar
  布尔可满足性问题（有时称为命题可满足性问题，缩写为SATISFIABILITY或SAT），就是确定是否存在满足给定布尔公式的解释的问题。

\sphinxAtStartPar
  布尔表达式是由布尔变量和逻辑运算符（NOT , AND ,OR）所构成的表达式。其中NOT又称逻辑非 \((\neg)\) ，AND又称逻辑与 \((\wedge)\) ，OR又称逻辑或 \((\vee)\) 。

\sphinxAtStartPar
例如：

\begin{center}\(x\) and  \(y \equiv x \wedge y\)
\end{center}
\begin{center}\(x\) or  \(y \quad \equiv \quad x \vee y\)
\end{center}
\begin{center}\(x\) and  \(y \text{or}(\text{ not } z) \equiv x \wedge y \vee(\neg z)\)
\end{center}
\sphinxAtStartPar
  布尔可满足性问题就是对于布尔表达式中的变量使用true或者false进行赋值，使得该布尔表达式的值为true，则该布尔表达式是可满足的。

\sphinxAtStartPar
例如：
\begin{equation*}
\begin{split}A=x \wedge y\end{split}
\end{equation*}
\sphinxAtStartPar
当  \(x=\) true, \(y=\) true , 则  \(A=\) true ，所以布尔表达式 \(A\) 是可满足的。
\begin{equation*}
\begin{split}B=x \vee y\end{split}
\end{equation*}
\sphinxAtStartPar
当  \(x=\) true 或  \(y=\) true, 则  \(B=\) true ，所以布尔表达式B是可满足的
\begin{equation*}
\begin{split}C=x \wedge y \vee(\neg z)\end{split}
\end{equation*}
\sphinxAtStartPar
当  \(x=\) true, \(y=\) true 或  \(z=\)  false, 则  \(C=\) true ，所以布尔表达式C也是可满足的。

\sphinxAtStartPar
  那有没有不可满足的例子呢？
\begin{equation*}
\begin{split}D=x \wedge(\neg x)\end{split}
\end{equation*}
\sphinxAtStartPar
  无论  \(x=\) true 或  \(x=\) ` false 则  \(D=\) false ，所以表达式D是不可满足的。

\sphinxAtStartPar
  已知的NP\sphinxhyphen{}完全问题有很多，但作为这些问题的“祖先”，历史上第一个被证明的NP\sphinxhyphen{}完全问题就是来自于布尔可满足性问题。

\sphinxAtStartPar
  SAT问题是逻辑学的一个基本问题，也是当今计算机科学和人工智能研究的核心问题。工程技术、军事、工商管理、交通运输及自然科学研究中的许多重要问题，如程控电话的自动交换、大型数据库的维护、大规模集成电路的自动布线、软件自动开发、机器人动作规划等，都可转化成SAT问题。因此致力于寻找求解SAT问题的快速而有效的算法，不仅在理论研究上而且在许多应用领域都具有极其重要的意义。

\sphinxAtStartPar
  SAT的问题被证明是NP难解的问题。目前解决该问题的方法主要有完备的方法和不完备的方法两大类。完备的方法优点是保证能正确地判断SAT问题的可满足性，但其计算效率很低，平均的计算时间为多项式阶，最差的情况计算时间为指数阶，不适用于求解大规模的SAT问题。不完备的方法的优点是求解的时间比完备的方法快得多，但在很少数的情况下不能正确地判断SAT问题的可满足性。

\sphinxAtStartPar
  传统的方法有：枚举法、局部搜索法和贪婪算法等，但由于搜索空间大，问题一般难以求解。对于像SAT一类的NP难解问题，采用一些现代启发式方法如演化算法往往较为有效。


\subsection{4.5.3 组合最优化问题}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id3}}
\sphinxAtStartPar
  组合最优化是指通过对数学方法的研究去寻找处理离散事件的最优编排、分组、次序或筛选等问题的优化方法。实际上就是从有限个离散状态中选取最好的状态。

\sphinxAtStartPar
  组合最优化的模型如下
\begin{equation*}
\begin{split}\begin{aligned} &\min f(x) \\ &s.t. g(x) \geq 0 \\ &x \in D \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
其中，f(x)为目标函数，g(x)为约束条件，x为决策变量，D表示有限个点组成的集合。

\sphinxAtStartPar
  从模型可看出组合最优化问题是一个规划问题（在一定条件下，求解目标函数的最大值或最小值，这类问题叫做数学规划，它是运筹学里的重要内容）。

\sphinxAtStartPar
  组合最优化的特点就是定义域集合为有限点集。由直观可知，只要将定义域D中的有限个点逐一判别是否满足约束，并比较目标函数的大小，就可以得到该问题的最优解，这就是枚举法。对于某些优化问题可以通过枚举法得到最优解，这在问题规模较小时是十分有效的，考虑的点也是非常全面的。每一个组合最优化问题都可以通过枚举的方法求得最优解，然而枚举是以时间为代价的，有的枚举时间还可以接受，有的则不可能接受。

\sphinxAtStartPar
  例如背包问题，旅行商问题，以及最大切割问题都是组合最优化问题。那么，有哪些方法解决这类问题呢？如表4.5.2所示：

\begin{center}表4.5.2 如何求解组合最优化问题
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.2}.png}\hspace*{\fill}}

\sphinxAtStartPar
  最优化问题，它一般分为两大类：一类是具有连续型的变量，另一类是具有离散型的变量，后一类被称为组合最优化问题。在应用方面，可以将连续优化问题通过设定步长转换为离散优化问题，这样就可以使用组合优化问题的方法求解了。


\subsection{4.5.4 近似优化算法}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id4}}
\sphinxAtStartPar
  很多实际应用问题都是NP\sphinxhyphen{}完全问题，这类问题很可能不存在多项式时间算法。一般而言NP\sphinxhyphen{}完全问题可采用以下三种方式处理。如果问题的输入规模较小，则可以利用搜索策略在指数时间内求解问题；如果输入规模较大，既可以利用随机算法在多项式时间内“高概率”地精确求解问题；也可以考虑在多项式时间内求得问题的一个“近似解”。

\sphinxAtStartPar
  近似优化算法就是是指这种能够在多项式时间内给出优化问题的近似优化解的算法。近似算法不仅可用于近似求解NP\sphinxhyphen{}完全问题，也可用于近似求解复杂度较高的NP问题。

\sphinxAtStartPar
  通常在生活中，有些问题没有必要找到最完美的解，常常是找到一个可以满足期望的解就可以了。比如赛车比赛，赛道上其实有很多路线可以到达终点，车手只需要找到一种可以赢得比赛的路线就可以了。


\subsection{4.5.5 泡利算符}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id5}}
\sphinxAtStartPar
  泡利算符是一组三个2×2的幺正厄米复矩阵，一般都以希腊字母  \(\sigma\) （西格玛）来表示，读作泡利  \(x\) ，泡利  \(y\) ，泡利  \(z\) 。
\begin{equation*}
\begin{split}\sigma_{\mathrm{x}}=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right] \quad \sigma_{\mathrm{y}}=\left[\begin{array}{cc} 0 & -\mathrm{i} \\ \mathrm{i} & 0 \end{array}\right] \quad \sigma_{\mathrm{z}}=\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  每个泡利矩阵有两个特征值，+1和−1，其对应的归一化特征向量为：
\begin{equation*}
\begin{split}\begin{aligned} &\Psi_{\mathrm{x}+}=\frac{1}{\sqrt{2}}\left[\begin{array}{l} 1 \\ 1 \end{array}\right] \quad \Psi_{\mathrm{y}+}=\frac{1}{\sqrt{2}}\left[\begin{array}{l} 1 \\ \mathrm{i} \end{array}\right] \quad \Psi_{\mathrm{z}+}=\left[\begin{array}{l} 1 \\ 0 \end{array}\right] \\ &\Psi_{\mathrm{x}-}=\frac{1}{\sqrt{2}}\left[\begin{array}{c} 1 \\ -1 \end{array}\right] \quad \Psi_{\mathrm{y}-}=\frac{1}{\sqrt{2}}\left[\begin{array}{c} 1 \\ \mathrm{i} \end{array}\right] \quad \Psi_{\mathrm{z}-}=\left[\begin{array}{l} 0 \\ 1 \end{array}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  通常，用  \(|+\rangle\)  表示  \(\Psi_{\mathrm{x}+}\) , 用  \(|-\rangle\) 表示  \(\Psi_{\mathrm{x}-}\) ，用  \(|0\rangle\) 表示  \(\Psi_{\mathrm{z}+}\) , 用  \(|1\rangle\) 表示  \(\Psi_{\mathrm{z}-}\) 。 泡利算符对应的运算规则如下，同一泡利算符相乘会得到单位矩阵。泡利 \(x\) 乘以泡利 \(y\) 等于  \(i\) 倍的泡利  \(z_{0}\) 泡利  \(y\) 乘以泡利  \(x\) 等于  \(-i\) 倍的泡利  \(z_{0}\)
\begin{equation*}
\begin{split}\sigma_{\mathrm{x}} \mathrm{I}=\mathrm{I} \sigma_{\mathrm{x}}=\sigma_{\mathrm{x}} \quad \sigma_{\mathrm{y}} \mathrm{I}=\mathrm{I} \sigma_{\mathrm{y}}=\sigma_{\mathrm{y}} \quad \sigma_{\mathrm{z}} \mathrm{I}=\mathrm{I} \sigma_{\mathrm{z}}=\sigma_{\mathrm{z}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sigma_{\mathrm{x}} \sigma_{\mathrm{x}}=\sigma_{\mathrm{y}} \sigma_{\mathrm{y}}=\sigma_{\mathrm{z}} \sigma_{\mathrm{z}}=\mathrm{I}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sigma_{\mathrm{x}} \sigma_{\mathrm{y}}=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]\left[\begin{array}{cc} 0 & -\mathrm{i} \\ \mathrm{i} & 0 \end{array}\right]=\mathrm{i}\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]=\mathrm{i} \sigma_{\mathrm{z}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sigma_{\mathrm{y}} \sigma_{\mathrm{x}}=\left[\begin{array}{cc} 0 & -\mathrm{i} \\ \mathrm{i} & 0 \end{array}\right]\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right]=-\mathrm{i}\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]=-\mathrm{i} \sigma_{\mathrm{z}}\end{split}
\end{equation*}
\sphinxAtStartPar
  同理，也可以得到其它泡利矩阵相乘的表达式结果：
\begin{equation*}
\begin{split}\begin{aligned} \sigma_{\mathrm{y}} \sigma_{\mathrm{z}}=\mathrm{i} \sigma_{\mathrm{x}}\qquad \sigma_{\mathrm{z}} \sigma_{\mathrm{x}}=\mathrm{i} \sigma_{\mathrm{y}} \\ \sigma_{\mathrm{z}} \sigma_{\mathrm{y}}=-\mathrm{i} \sigma_{\mathrm{x}} \quad \sigma_{\mathrm{x}} \sigma_{\mathrm{z}}=-\mathrm{i} \sigma_{\mathrm{y}} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  由此发现，顺序相乘的两个泡利矩阵跟未参与计算的泡利矩阵是 \(\mathrm{i}\) 倍关系，逆序相乘的泡利矩阵跟未参与计算的泡利矩阵是\sphinxhyphen{}i倍的关系。

\sphinxAtStartPar
  在QPanda中，实现了泡利算符类，定义了以下规则：

\sphinxAtStartPar
  用大写字母 \(X\) 表示泡利 \(x\) 算符，又称为 \(X\) 门；用大写字母 \(Y\) 表示泡利 \(y\) 算符，又称为 \(Y\) 门；用大写字母 \(Z\) 表示泡利 \(z\) 算符，又称为 \(Z\) 门。

\sphinxAtStartPar
  另外，定义形式如
\begin{equation*}
\begin{split}\left \{ ^{\prime \prime}\mathrm{X} 0^{\prime \prime}, 2\right \} \equiv 2 \sigma_{\mathrm{x}}^{0}\end{split}
\end{equation*}
\sphinxAtStartPar
  表示在0号量子比特上作用了一个 \(X\) 门，其系数为2。
\begin{equation*}
\begin{split}\{ ^{\prime \prime} \text { Z0 Z1}^{\prime \prime} \text{} ,3\} \equiv 3 \sigma_{z}^{0} \otimes \sigma_{z}^{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  表示在0号和1号量子比特上作用了 \(Z\) 门，其系数为3。
\begin{equation*}
\begin{split}\{^{\prime \prime}\mathrm{X} 0 \ \mathrm{Y} 1\ \mathrm{Z} 2\ \mathrm{Z} 3^{\prime \prime},4\} \equiv 4 \sigma_{\mathrm{x}}^{0} \otimes \sigma_{\mathrm{y}}^{1} \otimes \sigma_{\mathrm{z}}^{2} \otimes \sigma_{\mathrm{z}}^{3}\end{split}
\end{equation*}
\sphinxAtStartPar
  表示在0号量子比特作用 \(X\) 门，在1号量子比特作用 \(Y\) 门，在2号和3号量子比特上作用了 \(Z\) 门，其系数为4。
\begin{equation*}
\begin{split}\{^{\prime \prime}\ ^{\prime \prime}, 2\} \equiv 2 \mathrm{I}\end{split}
\end{equation*}
\sphinxAtStartPar
  表示的是单位矩阵，其系数为2。

\sphinxAtStartPar
  最终表示的矩阵形式是作用在不同比特上的泡利门的张乘,这里提到的系数可以是实数也可以是复数。

\sphinxAtStartPar
  在QPanda中，可以通过如下示例代码构建泡利运算符类。

\sphinxAtStartPar
  使用C++构建方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{PauliOperator} \PYG{n}{p1}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{PauliOperator} \PYG{n}{p2}\PYG{p}{(}\PYG{p}{\PYGZob{}} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1 Y2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{PauliOperator} \PYG{n}{p3}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{PauliOperator} \PYG{n}{p4}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{PauliOperator} \PYG{n}{p4}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{PauliOperator} \PYG{n}{p5}\PYG{p}{(}\PYG{n}{p2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{12.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python构建方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X1 Y2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{n}{p3} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{n}{p4} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{n}{p5} \PYG{o}{=} \PYG{n}{p2}
\end{sphinxVerbatim}

\sphinxAtStartPar
  构造一个空的泡利算符类P1，里面不包含任何泡利算符及单位矩阵；可以以字典序的形式构建多个表达式，例如P2；也可以构建单项，例如P3；还可以只构造一个单位矩阵，例如P4；也可以通过已经构造好的泡利运算符来构造它的一份副本例如P5。

\sphinxAtStartPar
  泡利算符类支持常规的加、减、乘等运算操作，计算返回结果还是一个泡利算符类。例如：定义a和b两个泡利算符类，让泡利算符类之间进行加操作，减操作和乘操作。

\sphinxAtStartPar
  C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{PauliOperator} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{PauliOperator} \PYG{n}{b}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 Y6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{auto} \PYG{n}{plus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{minus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{12.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X5 X6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{n}{plus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\PYG{l+m+mf}{7.}    \PYG{n}{minus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}
\PYG{l+m+mf}{8.}    \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\end{sphinxVerbatim}

\sphinxAtStartPar
  泡利算符类还支持打印功能，可以直接将泡利算符类打印输出到屏幕上。如示例代码示，将a+b，a\sphinxhyphen{}b和a*b的值打印输出到屏幕上来查看计算结果。

\sphinxAtStartPar
  C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{PauliOperator} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{PauliOperator} \PYG{n}{b}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 Y6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{auto} \PYG{n}{plus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{minus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{multiply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a + b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{plus} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{12.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a \PYGZhy{} b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{minus} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{13.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{multiply} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{16.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X5 X6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{plus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\PYG{l+m+mf}{6.}    \PYG{n}{minus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}
\PYG{l+m+mf}{7.}    \PYG{n}{multiply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a + b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{plus}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a \PYGZhy{} b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{minus}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{multiply}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\end{sphinxVerbatim}

\sphinxAtStartPar
  上述示例的输出结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{=}
\PYG{l+m+mf}{2.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{3.}    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 X6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{3.000000}
\PYG{l+m+mf}{4.}    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{6.}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{=}
\PYG{l+m+mf}{7.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{8.}    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 X6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.000000}
\PYG{l+m+mf}{9.}    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{10.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{11.}\PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{=}
\PYG{l+m+mf}{12.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{13.} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1 X5 X6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{6.000000}
\PYG{l+m+mf}{14.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  还可以通过getMaxIndex接口返回泡利算符类需要操作的比特个数。如果是空的泡利算符类则返回0，否则返回最大下标索引值加1的结果。

\sphinxAtStartPar
  C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{PauliOperator} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{PauliOperator} \PYG{n}{b}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 Y6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{muliply} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Index : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{muliply}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{14.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X5 X6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{l+m+mf}{6.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{muliply}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Index : }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{muliply}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  在示例代码中，a*b的结果是Z0 Z1 X5 X6，则这个泡利算符类需要使用到的比特数，通过调用getMaxIndex接口得到7。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{2.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1 X5 X6}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{6.000000}
\PYG{l+m+mf}{3.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{4.}\PYG{n}{Index} \PYG{p}{:} \PYG{l+m+mi}{7}
\end{sphinxVerbatim}

\sphinxAtStartPar
  另外一个跟泡利算符类下标有关的接口remapQubitIndex，它的功能是对泡利算符类中的索引从0比特开始分配映射，并返回新的泡利算符。

\sphinxAtStartPar
  使用C++方式构建：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{PauliOperator} \PYG{n}{a}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{PauliOperator} \PYG{n}{b}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X5 Y6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{size\PYGZus{}t}\PYG{p}{,} \PYG{n}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{index\PYGZus{}map}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{n}{auto} \PYG{n}{remap\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{muliply}\PYG{o}{.}\PYG{n}{remapQubitIndex}\PYG{p}{(}\PYG{n}{index\PYGZus{}map}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{12.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{remap\PYGZus{}pauli : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{remap\PYGZus{}pauli} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{13.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Index : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{remap\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{16.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  使用python方式构建：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z0 Z1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X5 X6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{l+m+mf}{6.}    \PYG{n}{index\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{7.}    \PYG{n}{remap\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{muliply}\PYG{o}{.}\PYG{n}{remapQubitIndex}\PYG{p}{(}\PYG{n}{index\PYGZus{}map}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{remap\PYGZus{}pauli = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{remap\PYGZus{}pauli}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Index : }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{remap\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  index\_map里面是前后映射关系，以a*b为例，如果直接调用getMaxIndex接口返回的结果是7，说明这个泡利算符类需要操作7个量子比特，其实2号，3号和4号比特并未被使用；如果使用remapQubitIndex接口，即可用4个量子比特来进行计算操作。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{remap\PYGZus{}pauli} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{2.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z1 X2 X3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mf}{6.000000}
\PYG{l+m+mf}{3.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{4.}\PYG{n}{Index} \PYG{p}{:} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
  泡利算符类提供了其它一些常用功能，例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.isEmpyt()          // 判空
2.dagger()           // 返回共轭泡利算符
3.isAllPauliZorI()   // 判断是否全为泡利“Z”或“I”
4.toString()         // 返回字符串形式
5.data()             // 返回泡利运算符内部维护的数据结构
\end{sphinxVerbatim}


\subsection{4.5.6 哈密顿量}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id6}}
\sphinxAtStartPar
  对于一个物理系统，可以用哈密顿量来描述，其实哈密顿量在数学表示上就是一个矩阵，只不过这个矩阵有点特殊，它的本征值都是实数。

\sphinxAtStartPar
  哈密顿量的本征向量描述对应的物理系统所处的各个本征态，本征值就是物理系统所处的本征态对应的能量。

\sphinxAtStartPar
  对于一个问题，如果找到了它的哈密顿量，根据这个哈密顿量就可以求得它的本征态和本征能量，得到了本征态和本征能量就相当于解决了问题。

\sphinxAtStartPar
  例如图4.5.5，对于这个由三个台阶和一个小球组成的系统，它可以存在三种不同的状态，将小球放在不同的台阶上，可以看到每个台阶的高度不同，小球的重力势能是不相等的，所以这个系统有三种不同的能量状态。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.5}.png}\hspace*{\fill}}

\begin{center}图4.5.5 三种不同状态
\end{center}
\sphinxAtStartPar
  假设每个状态对应的能量分别是 \(\mathrm{E1}\) ， \(\mathrm{E2}\) 和  \(\mathrm{E3}\) 。

\sphinxAtStartPar
  用1，0，0来表示第一个状态，用0，1，0来表示第二个状态；用0，0，1来表示第三个状态。

\sphinxAtStartPar
  那这个系统的哈密顿量可以表示成这样的矩阵形式：

\sphinxAtStartPar
  对于对角矩阵，它对角线上的每个元素都是该矩阵的本征值。其中1，0，0；0，1，0和0，0，1就是该对角矩阵的本征向量。

\sphinxAtStartPar
  对于布尔变量a来说，它有两个状态a和非a，如果a表示真的话，那非a就表示假，假设用数字1来表示真，用数字0来表示假。则如表4.5.3：

\begin{center}表4.5.3 布尔变量的状态及值
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.3}.png}\hspace*{\fill}}

\sphinxAtStartPar
  它有两个本征态 \(|0\rangle\) 和  \(|1\rangle\) ，这两个本征态对应的本征值为1和\sphinxhyphen{}1。如果用1表示布尔变量为真状态时的能量，\sphinxhyphen{}1表示布尔变量为假状态时的能量，那么泡利  \(z\) 就是布尔变量这个简单物理系统的哈密顿量形式。

\sphinxAtStartPar
\sphinxstylestrong{逻辑表达式a∧b的哈密顿量}

\sphinxAtStartPar
  逻辑与也叫做逻辑乘，逻辑与对应的哈密顿量可以表示成两个逻辑变量的哈密顿量之间的乘积。

\sphinxAtStartPar
  假设给出a与b的真值表，如表4.5.4。当逻辑变量a和逻辑变量b都为true时，逻辑表达式a与b值为1，其它情况值都为0。

\begin{center}表4.5.4 a与b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.4}.png}\hspace*{\fill}}

\sphinxAtStartPar
  哈密顿量的本征向量可以描述对应物理系统所处的各个本征态，哈密度量的本征值可以描述物理系统所处的本征态对应的能量。

\sphinxAtStartPar
  对于逻辑表达式a与b这个简单系统来说，它有4个状态，第一个状态能量值为1，其它状态能量值为0；那么逻辑表达式a与b的哈密顿量，有4个本征态，本征态对应的能量分别为1,0,0,0。
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a} \land \mathrm{b}}=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  逻辑与也叫做逻辑乘，逻辑与对应的哈密顿量可以表示成两个逻辑变量的哈密顿量之间的乘积。如果用 \(|0\rangle\) 态来表示a状态和b状态，用 \(|1\rangle\) 态来表示非a状态和非b状态。令状态a和状态b的值为真。则逻辑表达式a与b的真值表如表4.5.5所示：

\begin{center}表4.5.5 逻辑表达式a与b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.5}.png}\hspace*{\fill}}

\sphinxAtStartPar
\(|0\rangle\) 态对应的哈密顿量为 \(\frac{I+\sigma^{2}}{2}\) ，将变量a和b用其哈密顿量来替换，逻辑与用矩阵乘来替换，则逻辑表达式a与b的哈密顿量可以这样推导，对于a和b各用1个比特来表示，用索引值为0的比特来表示a，索引值为1的比特来表示b，表达式为：
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a} \land \mathrm{b}}=\frac{\mathrm{I}+\sigma_{0}^{z}}{2} \cdot \frac{\mathrm{I}+\sigma_{1}^{z}}{2}=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  同理，如果用 \(|1\rangle\) 态来表示a状态和b状态，用 \(|0\rangle\) 态来表示非a状态和非b状态。则逻辑表达式a与b的真值表可以如表4.5.6所示：

\begin{center}表4.5.6 逻辑表达式a与b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.6.6}.png}\hspace*{\fill}}

\sphinxAtStartPar
\(|1 \rangle\) 态对应的哈密顿量为 \(\frac{I-\sigma^{2}}{2}\) ，将变量a和b用哈密顿量来替换，逻辑与用矩阵乘来替换，则逻辑表达式a与b的哈密顿量推导形式为：
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a} \land \mathrm{b}}=\frac{\mathrm{I}-\sigma_{0}^{z}}{2} \cdot \frac{\mathrm{I}-\sigma_{1}^{z}}{2}=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{逻辑表达式的a∨b哈密顿量}

\sphinxAtStartPar
  所有的逻辑表达式都可以用逻辑与和逻辑非来表示。那么逻辑表达式a或b，可以表示为非a与非b的非。

\sphinxAtStartPar
  假设给出逻辑表达式a或b的真值表，如表4.5.7。当逻辑变量a和b都为false的时候，逻辑表达式a或b值为0。其它情况值都为1。
\begin{equation*}
\begin{split}\mathrm{a} \lor \mathrm{b}=\neg(\neg \mathrm{a} \wedge \neg \mathrm{b})\end{split}
\end{equation*}
\begin{center}表4.5.7 逻辑表达式a或b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.7}.png}\hspace*{\fill}}

\sphinxAtStartPar
  根据状态和对应的能量，写出逻辑表达式a或b的哈密顿量，这个哈密顿量也有4个本征态，本征态对应的能量分别为1,1,1,0。
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a}{\mathrm{\lor} b}}=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  同样假设用 \(|0 \rangle\) 态来表示a状态和b状态，用 \(|1 \rangle\) 态来表示非a状态和非b状态，令状态a和状态b的值为真。则逻辑表达式a或b的真值表如表4.5.8所示:

\begin{center}表4.5.8 逻辑表达式a与b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.8}.png}\hspace*{\fill}}

\sphinxAtStartPar
\(|1 \rangle\) 态对应的哈密顿量为  \(\frac{I-\sigma^{2}}{2}\) ，将非a状态和非b状态用对应 \(|1 \rangle\) 的哈密顿量来替换，逻辑与用矩阵乘来替换，再取非就相当于用单位向量做减法，则逻辑表达式a或b的哈密顿量推导形式为：
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a} \lor \mathrm{~b}}=\mathrm{I}-\frac{\mathrm{I}-\sigma_{0}^{2}}{2} \cdot \frac{\mathrm{I}-\sigma_{1}^{2}}{2}=\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  从上述表达式不难发现，它与用状态及其能量写出来的哈密顿量形式一样。

\sphinxAtStartPar
  同理，如果用 \(|1 \rangle\) 态来表示a状态和b状态，用 \(|0 \rangle\) 态来表示非a状态和非b状态。则逻辑表达式a或b的真值表如表4.5.9所示：

\begin{center}表4.5.9 逻辑表达式a或b的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.9}.png}\hspace*{\fill}}

\sphinxAtStartPar
\(|0 \rangle\) 态对应的哈密顿量为  \(\frac{1+\sigma^{\pi}}{2}\) , 同时将非a状态和非b状态用  \(|0\rangle\) 态对应的哈密顿量来替换，逻辑与用矩阵乘来替换，非操作相当于用单位向量进行减法操作，则逻辑 表达式a或b的哈密顿量形式也可以推导为:
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a \lor b}}=\mathrm{I}-\frac{\mathrm{I}+\sigma_{0}^{2}}{2} \cdot \frac{\mathrm{I}+\sigma_{1}^{2}}{2}=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{逻辑表达式的a+b哈密顿量}

\sphinxAtStartPar
  加法对应的哈密顿量可以表示为变量对应的哈密顿量进行加操作，所以a加b的哈密顿量等于变量a和变量b取值对应的哈密顿量之和。

\sphinxAtStartPar
  假设a,b只能在0和1中进行取值，可以看到总共存在4种情况，当a取0，b取0的时候值为0，a取0，b取1的时候值为1，a取1，b取0的时候值为1，a取1，b取1的时候值为2，如表4.5.10所示：

\begin{center}表4.5.10 4种情况
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.10}.png}\hspace*{\fill}}

\sphinxAtStartPar
  根据状态及其对应能量，对于这种状态比较少的情况，直接将它对应的哈密顿量写出，这个哈密顿量也有4个本征态，本征态对应的能量分别为0，1，1，2。
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a}+\mathrm{b}}=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 2 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
同样，可以各用 1 个比特来表示a和b的取值范围，如果用  \(|0\rangle\) 态来表示a和b取值为 1 时的状态，用  \(|1\rangle\) 态表示  \(a\) 和b取值为 0 时的状态，列出所有情况如表 4.5.11 所示:

\begin{center}表4.5.11 所有情况
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.11}.png}\hspace*{\fill}}

\sphinxAtStartPar
  那么，逻辑表达式a+b的哈密顿量形式为：
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a}+\mathrm{b}}=\frac{\mathrm{I}+\sigma_{0}^{2}}{2}+\frac{\mathrm{I}+\sigma_{1}^{z}}{2}=\left[\begin{array}{llll} 2 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  同理，用  \(|1\rangle\) 态来表示a和b取值为 1 时的状态，用  \(|0\rangle\) 态表示a和b，取值为0时的状态，如表4.5.12所示：

\begin{center}表4.5.12 所有情况
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.12}.png}\hspace*{\fill}}

\sphinxAtStartPar
  那么，逻辑表达式a+b的哈密顿量形式为：
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{a}+\mathrm{b}}=\frac{\mathrm{I}-\sigma_{0}^{z}}{2}+\frac{\mathrm{I}-\sigma_{1}^{z}}{2}=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 2 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{逻辑表达式的a+b哈密顿量}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=360\sphinxpxdimen]{{4.5.6}.png}\hspace*{\fill}}

\begin{center}图4.5.6 杠铃图
\end{center}
\sphinxAtStartPar
  对杠铃图AB这条边，如果顶点A和顶点B分配到相同组，例如“0组”或“1组”，则AB这条边将不会被切割，对总的切割贡献为0；相反，如果将顶点A和B分配到不同组，假设将A分配到“0组”，将B分配到“1组”，或对调分配，则AB这条边将会被切割，对总的切割贡献为这条边的权重(例如AB这条边权重为1，则贡献为1）。

\sphinxAtStartPar
  那么，如果将对应于最大切割的比特串（或比特串组），视为是使用哈密顿量编码的代价函数的基态。这个哈密顿量的形式，可以通过构造经典函数返回值来决定，如果被切割边所对应的两个节点跨越不同组，则返回1（或边的权重），否则返回0。哈密顿量的形式为：
\begin{equation*}
\begin{split}C_{i j}=\frac{1}{2}\left(1-Z_{i} Z_{j}\right)\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.7}.png}\hspace*{\fill}}

\begin{center}图4.5.7 分组情况
\end{center}
\sphinxAtStartPar
  如果顶点 \(Z_{i}\) 或  \(Z_{j}\) 属于“ \(0\) 组”，则  \(Z_{i}\) 或  \(Z_{j}\) 的值为 \(+1\) ，如果顶点 \(Z_{i}\) 或  \(Z_{j}\) 属于“ \(1\) 组”，则  \(Z_{i}\) 或  \(Z_{j}\) 的值为  \(-1\) 。那么，可以用公式来表示图4.5.7的分组情况:
\begin{equation*}
\begin{split}\mathrm{C}_{\mathrm{ij}}=\frac{1}{2}\left(1-\mathrm{Z}_{\mathrm{i}} \mathrm{Z}_{\mathrm{j}}\right) \text { 其中 }\left\{\begin{array}{l} \mathrm{Z}_{\mathrm{i}}, \mathrm{Z}_{\mathrm{j}} \in 0 \text { 组, } \mathrm{Z}_{\mathrm{i}}, \mathrm{Z}_{\mathrm{i}}=1 \\ \mathrm{Z}_{\mathrm{i}}, \mathrm{Z}_{\mathrm{j}} \in 1 \text { 组, } \mathrm{Z}_{\mathrm{i}}, \mathrm{Z}_{\mathrm{j}}=-1 \end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
  对于更复杂的图来说，最大切割值等于每条边切割贡献的总和：
\begin{equation*}
\begin{split}\text { MaxCut }=\sum_{i j} C_{i j}\end{split}
\end{equation*}
\sphinxAtStartPar
  对于杠铃图来说，它有 4 个分组，如果将它看作一个系统的话，表示这个系统有 4 个状态，并且每个状态都是孤立存在的，用狄拉克符号表示它的状态就是  \(|00\rangle\) 、 \(|01\rangle\) 、 \(|10\rangle\) 和  \(|11\rangle\) 。每个分组都对应一个切割值，可以将这个切割值看作是系统处在这个状态时的能量，系统处在 \(|00\rangle\) 状态时能量为 0 ，系统处在  \(|01\rangle\) 状态时能量为 1 ，系统处在  \(|10\rangle\) 状态时，能量为 1 ，系统处在  \(|11\rangle\) 状态时能量为 0 。

\sphinxAtStartPar
  用哈密顿量表示成如下的矩阵形式:
\begin{equation*}
\begin{split}\begin{aligned} &|00\rangle=\left[\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right]|01\rangle=\left[\begin{array}{l} 0 \\ 1 \\ 0 \\ 0 \end{array}\right]|10\rangle=\left[\begin{array}{l} 0 \\ 0 \\ 1 \\ 0 \end{array}\right]|11\rangle=\left[\begin{array}{l} 0 \\ 0 \\ 0 \\ 1 \end{array}\right] \\ &E_{|00\rangle}=0 \quad E_{|01\rangle}=1 \quad E_{|10\rangle}=1 \quad E_{|11\rangle}=0 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  它的第一个和第四个状态能量为0，第二个和第三个状态能量为1。
\begin{equation*}
\begin{split}H=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  对于这个简单的系统，可以发现，它其实对应着一个异或表达式，异或表达式的真值表如表4.5.13所示：

\begin{center}表4.5.13 异或表达式的真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.5.13}.png}\hspace*{\fill}}

\sphinxAtStartPar
  当变量a和变量b取不同值时，异或的结果为1，取相同值时，异或的结果为0。

\sphinxAtStartPar
  a异或b也可以表示成两个逻辑与运算之和。
\begin{equation*}
\begin{split}a \oplus b=a \wedge \neg b+\neg a \wedge b\end{split}
\end{equation*}
\sphinxAtStartPar
  前面介绍过逻辑与相当于矩阵之间乘积，非操作相当于跟单位矩阵之间做减法操作，加操作相当于矩阵之间相加。则a异或b的哈密顿量可以用这样的公式来推导：
\begin{equation*}
\begin{split}\begin{aligned} &H_{a \oplus b}=\frac{I+\sigma_{0}^{z}}{2} \cdot \frac{I-\sigma_{1}^{z}}{2}+\frac{I-\sigma_{0}^{z}}{2} \cdot \frac{I+\sigma_{1}^{z}}{2} \\ &=\frac{I-\sigma_{0}^{z} \sigma_{1}^{z}}{2} \\ &=\left[\begin{array}{llll} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{array}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  对于复杂的最大切割系统，将其简化成杠铃图这样的简单系统的组合，其切割值就是各个简单系统切割值的和。对应这个复杂系统的最大切割问题，其哈密顿量表示如下：
\begin{equation*}
\begin{split}H_{\text {Maxcut }}=H_{1}+H_{2}+\cdots+H_{n}=\sum_{i j} \frac{1}{2}\left(I-\sigma_{i}^{z} \sigma_{j}^{z}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{在QPanda中构造最大切割问题对应的哈密顿量}

\sphinxAtStartPar
  对于杠铃图来说，它对应的哈密顿量形式为
\begin{equation*}
\begin{split}\frac{I-\sigma_{i}^{z} \sigma_{j}^{z}}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  去掉这个表达式中的单位矩阵和常系数，它描述的其实是：
\begin{equation*}
\begin{split}\sigma_{i}^{z} \sigma_{j}^{z}\end{split}
\end{equation*}
\sphinxAtStartPar
  之前介绍过在QPanda中用泡利算符类来描述泡利矩阵之间的关系。用 \(\{ ^{\prime \prime} \text { Z0 Z1}^{\prime \prime} \text{} ,1\}\) 来构造杠铃图对应的泡利算符类。其实Z0Z1对应的就是泡利算符之间的乘积关系，系数1表示切割的权重。

\sphinxAtStartPar
  对方形图来说，它的哈密顿量是各个简单系统哈密顿量之和。在QPanda中可以通过map的形式构造多个表达式，各表达式之间对应的关系是加操作。
\begin{equation*}
\begin{split}\{ ^{\prime \prime} \text { Z0 Z1}^{\prime \prime} \text{} ,1\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\{ ^{\prime \prime} \text { Z1 Z2}^{\prime \prime} \text{} ,1\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\{ ^{\prime \prime} \text { Z2 Z3}^{\prime \prime} \text{} ,1\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\{ ^{\prime \prime} \text { Z3 Z0}^{\prime \prime} \text{} ,1\}\end{split}
\end{equation*}

\subsection{4.5.7 算法原理}
\label{\detokenize{rst/4.5QAOA_u7b97_u6cd5:id7}}
\sphinxAtStartPar
\sphinxstylestrong{绝热量子计算}

\sphinxAtStartPar
  绝热量子计算（Adiabatic quantum computation）是量子计算的一种形式，它依赖于绝热定理进行计算。 首先，对于一个特定的问题，找到一个（可能复杂的）哈密顿量，其基态描述了该问题的解决方案；然后，准备一个具有简单哈密顿量的系统并初始化为基态；最后，简单的哈密顿量绝热地演化为期望的复杂哈密顿量。 根据绝热定理，系统保持在基态，因此最后系统的状态描述了问题的解决方案， 绝热量子计算已经被证明在线路模型中与传统的量子计算是多项式等价的。

\sphinxAtStartPar
  绝热量子计算是通过以下过程解决特定问题和其他组合搜索问题。通常这种问题就是寻找一种状态满足  \(C_1 \wedge C_2 \wedge^{\cdots} \wedge C_{m}\) , 该表达式包含可满足条件的M个子问题，每个子问题  \(\mathrm{C}{i}\) 值为True或False，并且可能包含n位，这里的每一位都是一个变量  \(\mathrm{x}{j} \in{0,1}\) 所以  \(\mathrm{C}{i}\) 是一个关于  \(\mathrm{x}{1}, \mathrm{x}{2}, \cdots, \mathrm{x}{n}\) 的布尔值函数，绝热量子算法利用量子绝热演化解决了这类问题。它以初始哈密顿量  \(\mathrm{H}_{B}\) 开始:
\begin{equation*}
\begin{split}\mathrm{H}_{B}=H_{B_{1}}+H_{B_{2}}+\cdots+H_{B_{M}}\end{split}
\end{equation*}
\sphinxAtStartPar
  这里  \(H_{B_{i}}\) 对应于该子问题  \(\mathrm{C}{i}\) 的哈密顿量，通常选择的  \(H_{B_{i}}\) 不会依赖于其它的子问题。然后经历绝热演化，以问题的哈密顿量  \(\mathrm{H}_{P}\) 结束:
\begin{equation*}
\begin{split}H_{P}=\sum_{C} H_{P, C}\end{split}
\end{equation*}
\sphinxAtStartPar
  这里  \(\mathrm{H}_{P, C}\) 是满足问题  \(\mathrm{C}\) 的的哈密顿量，它有特征值0和 1 。如果子问题  \(\mathrm{C}\) 满足条件则特征值为1，不满足则特征值为 0 。对于一个简单的绝热演化路径，如图4.5.8 所示

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.8}.png}\hspace*{\fill}}

\begin{center}图4.5.8 一个简单的绝热演化路径
\end{center}\begin{equation*}
\begin{split}H(t)=\left(1-\frac{t}{T}\right) H_{B}+\frac{t}{T} H_{P}\end{split}
\end{equation*}
\sphinxAtStartPar
  令  \(\mathrm{s}=\frac{\mathrm{t}}{T}\) , 则有：
\begin{equation*}
\begin{split}\tilde{H}(t)=(1-s) H_{B}+(s) H_{P}\end{split}
\end{equation*}
\sphinxAtStartPar
  这就是算法的绝热演化哈密顿量。

\sphinxAtStartPar
  根据绝热定理，从哈密顿量的基态开始  \(\mathrm{H}_{B}\) ，首先，经历一个绝热过程，最后以问题哈密顿量的基态结束 \(\mathrm{H}_{P}\) ;然后测量最终状态 \(\mathrm{n}\) 个自旋的Z分量，这将产生一个 字符串  \(\mathrm{Z}_{1}\) ， \(\mathrm{Z}_{2}\) ， \(\cdots\) ， \(\mathrm{Z}_{n}\) 这很可能就是问题的结果。根据绝热定理  \(\mathrm{T}=\left(\frac{\varepsilon}{g{\min }^{2}}\right)\) 所示，这里运行时间T必须足够长以确保结果的正确性，而 \(\mathrm{g}_{\min }=\min_{0 \leq s \leq 1}(E_{1}(S)-E_{0}(S))\) 是基态和第一激发态之间的最小能隙。

\sphinxAtStartPar
\sphinxstylestrong{初始哈密顿量}

\sphinxAtStartPar
  QAOA定义的初始哈密顿量 \(H_{B}\) 是泡利X算符在每个量子位上的和。
\begin{equation*}
\begin{split}H_{B}=\sum_{i=0}^{n-1} \sigma_{i}^{x}\end{split}
\end{equation*}
\sphinxAtStartPar
  该哈密顿量具有基态，该基态是泡利算子最高能量对应的特征向量  \((|+\rangle)\) 的张量积。
\begin{equation*}
\begin{split}\left|\phi_{0}\right\rangle=|+\rangle_{0}|+\rangle_{1} \cdots|+\rangle_{\mathrm{n}-1}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{QAOA量子线路}

\sphinxAtStartPar
  以最大切割问题为例，QAOA线路是以 \(H_B\) 为生成元的酉变换跟以 \(H_P\) 为生成元的酉变换乘积的累积。
\begin{equation*}
\begin{split}\mathrm{U}(\vec{\beta}, \vec{\gamma})=\prod_{\mathrm{i}=1}^{\mathrm{m}} \mathrm{U}\left(\mathrm{H}_{\mathrm{B}}, \beta_{\mathrm{i}}\right) \mathrm{U}\left(\mathrm{H}_{\mathrm{P}}, \gamma_{\mathrm{i}}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  其中  \(\mathrm{m}\) 表示演化步数，所以每一步对应的量子线路都是这两个酉变换之间的乘积，每一步都对应着两个参数 \(\beta\) 和  \({\gamma}\) ；这里，以  \(H_{B}\) 为生成元的酉变换等于 \(e^{-i H_B \beta_i}\) 为生成元的酉变换等于  \(e^{-i H_{P} \gamma_{1}}\) 。这里的  \(\beta_{i}\) 和  \(\gamma_{i}\) 表示步数对应的量子线路的参数。
\begin{equation*}
\begin{split}\mathrm{U}\left(\mathrm{H}_{\mathrm{B}}, \beta_{\mathrm{i}}\right)=\mathrm{e}^{-\mathrm{iH}_{\mathrm{B}} \beta_{\mathrm{i}}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\mathrm{U}\left(\mathrm{H}_{\mathrm{P}}, \gamma_{\mathrm{i}}\right)=\mathrm{e}^{-\mathrm{iH}_{P} \gamma_{\mathrm{i}}}\end{split}
\end{equation*}
\sphinxAtStartPar
  那么，基态  \(\left|\phi_{0}\right\rangle\) ， 经过一组以 \(\beta\) 和 \(\gamma\) 为参数的酉变换后，演化到了基态  \(\left|\phi_{1}\right\rangle\) 。其中步数  \(\mathrm{m}\) 越大，量子线路得到的效果就越好。
\begin{equation*}
\begin{split}\left|\phi_{1}\right\rangle=|\vec{\beta}, \vec{\gamma}\rangle=U(\vec{\beta}, \vec{\gamma})\left|\phi_{0}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{量子逻辑门}

\sphinxAtStartPar
  对于以  \(H_{B}\) 为生成元，参数为  \(\beta\) 的酉变换，将  \(H_{B}\) 的值带入，然后可以推导出的是一组RX门操作。如下所示:
\begin{equation*}
\begin{split}H_{B}=\sum_{i=0}^{n-1} \sigma_{i}^{x}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{U}\left(H_{B}, \quad \beta_{i}\right)=e^{-i H_{B} \beta_{i}} \\ &=e^{-{i} \sum_{n=0}^{N-1} \sigma_{n}^{x} \beta_{i}} \\ &=\prod_{n=0}^{N-1} e^{-i \sigma_{n}^{x} \beta_{i}} \\ &=\prod_{n=0}^{N-1} R X\left(n, 2 \beta_{i}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  同样，以  \(H_{p}\) 为生成元，参数为  \(\gamma\) 的酉变换，将最大切割对应的哈密顿量带入，推导得出其中前一项是个常数，再对后面一项进行推导，最终可以推导出是一组 CNOT门和RZ门的组合操作，如下所示:
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{P}}=\sum_{\mathrm{ij}} \frac{1}{2}\left(\mathrm{I}-\sigma_{\mathrm{i}}^{z} \sigma_{\mathrm{j}}^{z}\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{U}\left(\mathrm{H}_{\mathrm{P}}, \gamma_{\mathrm{i}}\right)=\mathrm{e}^{-\mathrm{iH}_{\mathrm{p}} \gamma_{\mathrm{i}}}\\ &=\mathrm{e}^{-\mathrm{i} \sum_{\mathrm{jk}} \frac{1}{2}\left(\mathrm{I}-\sigma_{j}^{2} \otimes \sigma_{j}^{2}\right) \gamma_{\mathrm{i}}}\\ &=\prod_{\mathrm{jk}} \mathrm{e}^{-\mathrm{i} \frac{\gamma_{\mathrm{i}} \mathrm{I}}{2}} \cdot \prod_{\mathrm{jk}} \mathrm{e} \mathrm{e}^{\mathrm{i} \frac{\mathrm{y}_{\mathrm{i}}}{2} \sigma_{\mathrm{j}}^{2} \otimes \sigma_{\mathrm{j}}^{z}}\\ &=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{array}\right]\left[\begin{array}{cccc} \mathrm{i}^{\mathrm{i} \frac{\gamma_{1}}{2}} & 0 & 0 & 0 \\ 0 & \mathrm{e}^{-\mathrm{i} \frac{\gamma_{1}}{2}} & 0 & 0 \\ 0 & 0 & \mathrm{e}^{\mathrm{i} \frac{\gamma_{1}}{2}} & 0 \\ 0 & 0 & 0 & \mathrm{e}^{-\mathrm{i}_{2}{ }^{\gamma_{1}}} \end{array}\right]\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{array}\right]\\ &\equiv \mathrm{CNOT}(\mathrm{j}, \mathrm{k}) \mathrm{RZ}\left(\mathrm{k},-\gamma_{\mathrm{i}}\right) \mathrm{CNOT}(\mathrm{j}, \mathrm{k}) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  对于图4.5.9所示的方形环图，假设当步长等于1时，求解其最大切割问题需要使用到4个量子比特。对于A，B，C，D这4个节点分别用0号比特，1号比特，2号比特和3号比特进行映射。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{4.5.9}.png}\hspace*{\fill}}

\begin{center}图4.5.9 方形环图
\end{center}
\sphinxAtStartPar
  首先对所有量子比特作用一个H门， 制备该系统的初始状态。
  然后进行以  \(H_{P}\) 为生成元，  \(\gamma 1\) 为参数的酉变换; 按上述推导，该酉变换对应的量子线路是一组由  \(CNOT\) 门和  \(RZ\) 门 组成的线路，对AB节点映射的0号和1号比特作用 了一个CNOT门， 又在1号比特上作用了一个RZ门，然后又在 0 号和1号比特上作用了一个CNOT门，其中0号比特是控制位，1号比特是受控位， RZ门的参数含有  \(\gamma 1\) ；同理，对  \(B C, C D, D A\) 映射的比特做同样的操作。

\sphinxAtStartPar
  执行完以  \(H_{P}\) 为生成元，  \(\gamma 1\) 为参数的酉变换后，该线路接着执行以 \(H_{B}\) 为生成元， \(\beta 1\) 为参数的酉变换，由上述推导得出这个酉变换是一组RX门操作。 当  \(\beta 1\) 和  \(\gamma 1\) 设置了合适的参数后，初始状态经过这个量子线路变换后得到末态; 对末态进行测量，就可以高概率的得到该问题对应最大切割的比特串。 步数  \(m=1\) 时
\begin{equation*}
\begin{split}|\beta, \gamma\rangle=\mathrm{U}\left(\beta_{1}, \gamma_{1}\right)\left|\phi_{0}\right\rangle=\mathrm{U}\left(\mathrm{H}_{\mathrm{B}}, \beta_{1}\right) \mathrm{U}\left(\mathrm{H}_{\mathrm{P}}, \gamma_{1}\right)\left|\phi_{0}\right\rangle\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.10}.png}\hspace*{\fill}}

\begin{center}图4.5.10 线路图
\end{center}
\sphinxAtStartPar
  如图4.5.10，红色部分就是步数为1时对应的线路，当步数增加，相当于红色线路重复执行，只不过线路对应的参数会不同。

\sphinxAtStartPar
\sphinxstylestrong{QAOA的工作流程：} 
\begin{quote}

\sphinxAtStartPar
第1步：制备线路的初始状态；

\sphinxAtStartPar
第2步：初始化待优化的参数β和γ，主要是用来确定RZ门和RX门的旋转角度（通常参数初始化为0)；

\sphinxAtStartPar
第3步：根据参数生成量子线路；

\sphinxAtStartPar
第4步：测量量子状态计算每一个子项的期望；

\sphinxAtStartPar
第5步：计算当前参数对应的总的期望值；

\sphinxAtStartPar
第6步：将当前参数及其对应的期望值传入到经典优化器进行优化得到一组新的参数；

\sphinxAtStartPar
第7步：重复执行3\sphinxhyphen{}6步，一直到满足预先设定好的结束条件。
\end{quote}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250\sphinxpxdimen]{{4.5.11}.png}\hspace*{\fill}}

\begin{center}图4.5.11 QAOA的工作流程图
\end{center}\begin{equation*}
\begin{split}\text{Cost}(\vec{\beta}, \vec{\gamma})=\left\langle\phi_{0}\left|\mathrm{U}^{\dagger}(\vec{\beta}, \vec{\gamma}) \mathrm{H}_{\mathrm{p}} \mathrm{U}(\vec{\beta}, \vec{\gamma})\right| \phi_{0}\right\rangle\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.12}.png}\hspace*{\fill}}

\begin{center}图4.5.12 量子处理器与经典处理器的工作流程图
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{QAOA综合示例}

\sphinxAtStartPar
  对于n对象的MAX\sphinxhyphen{}CUT问题，需要n个量子位来对结果进行编码，其中测量结果（二进制串）表示问题的切割配置。

\sphinxAtStartPar
  通过 VQNet 可以有效地实现 MAX\sphinxhyphen{}CUT 问题的 QAOA 算法。 VQNet中QAOA的流程图如图4.5.13所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.13}.png}\hspace*{\fill}}

\begin{center}图4.5.13 VQNet中QAOA的流程图
\end{center}
\sphinxAtStartPar
  给定一个MAX\sphinxhyphen{}CUT的问题如图4.5.14所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.14a}.png}\hspace*{\fill}}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.14b}.png}\hspace*{\fill}}

\begin{center}图4.5.14（Max\sphinxhyphen{}cut Graph\sphinxhyphen{}最大切割图，weight of Graph Edge\sphinxhyphen{}最大分割图对应边的权重表）
\end{center}
\sphinxAtStartPar
  首先，输入MAX\sphinxhyphen{}CUT问题的图形信息，以用来构造相应的问题哈密顿量。

\sphinxAtStartPar
​  problem = \{‘Z0 Z4’:0.73,’Z0 Z5’:0.33,’Z0 Z6’:0.5,’Z1 Z4’:0.69,’Z1 Z5’:0.36,

\sphinxAtStartPar
  ‘Z2 Z5’:0.88,’Z2 Z6’:0.58,’Z3 Z5’:0.67,’Z3 Z6’:0.43\}

\sphinxAtStartPar
  然后，使用哈密顿量和待优化的变量参数beta和gamma，构建QAOA 的VQC。 QOP 的输入参数是问题哈密顿量、VQC 、 一组量子比特和量子运行环境。QOP 的输出是问题哈密顿量的期望。 在这个问题中，损失函数是问题哈密顿量的期望，因此需要最小化 QOP 的输出。通过使用梯度下降优化器 MomentumOptimizer 来优化vqc中的变量beta和gamma。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}iostream\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Components/Operator/PauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}Components/Optimizer/AbstractOptimizer.h\PYGZdq{}}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QAlg/QAOA/QAOA.h\PYGZdq{}}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}\PYG{n}{double} \PYG{n}{myFunc}\PYG{p}{(}\PYG{n}{const} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{,} \PYG{n}{const} \PYG{n}{PauliOperator}\PYG{o}{\PYGZam{}} \PYG{n}{pauli}\PYG{p}{)}
\PYG{l+m+mf}{10.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{11.}    \PYG{n}{double} \PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{QHamiltonian} \PYG{n}{hamiltonian} \PYG{o}{=} \PYG{n}{pauli}\PYG{o}{.}\PYG{n}{toHamiltonian}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{hamiltonian}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{16.}        \PYG{n}{hamiltonian}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{17.}        \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{const} \PYG{n}{QHamiltonianItem}\PYG{o}{\PYGZam{}} \PYG{n}{item}\PYG{p}{)}
\PYG{l+m+mf}{18.}        \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{19.}            \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{index\PYGZus{}vec}\PYG{p}{;}
\PYG{l+m+mf}{20.}            \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n+nb}{iter} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{first}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{21.}                \PYG{n+nb}{iter} \PYG{o}{!=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{first}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{22.}                \PYG{n+nb}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{l+m+mf}{23.}            \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{24.}                \PYG{n}{index\PYGZus{}vec}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n+nb}{iter}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{25.}            \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}            \PYG{o}{/}\PYG{o}{/}           \PYG{n}{double} \PYG{n}{value} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{second}\PYG{p}{;}
\PYG{l+m+mf}{28.}            \PYG{n}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{n}{index\PYGZus{}vec}\PYG{o}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{29.}            \PYG{n}{size\PYGZus{}t} \PYG{n}{j} \PYG{o}{=} \PYG{n}{index\PYGZus{}vec}\PYG{o}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{30.}            \PYG{k}{if} \PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{key}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{31.}            \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{32.}                \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{second}\PYG{p}{;}
\PYG{l+m+mf}{33.}            \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{34.}        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{;}
\PYG{l+m+mf}{37.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{38.}
\PYG{l+m+mf}{39.}\PYG{n}{auto} \PYG{n}{getHamiltonian}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{40.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{41.}    \PYG{o}{/}\PYG{o}{/}\PYG{k}{return} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{42.}    \PYG{o}{/}\PYG{o}{/}    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.73}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z2 Z5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.88}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{43.}    \PYG{o}{/}\PYG{o}{/}    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.33}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z2 Z6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.58}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{44.}    \PYG{o}{/}\PYG{o}{/}    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.50}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z3 Z5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.67}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{45.}    \PYG{o}{/}\PYG{o}{/}    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z1 Z4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.69}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z3 Z6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.43}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{46.}    \PYG{o}{/}\PYG{o}{/}    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z1 Z5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.36}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{47.}    \PYG{o}{/}\PYG{o}{/}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{48.}
\PYG{l+m+mf}{49.}    \PYG{k}{return} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{n}{PauliOperator}\PYG{p}{:}\PYG{p}{:}\PYG{n}{PauliMap}\PYG{p}{\PYGZob{}} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{50.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z0 Z6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.49}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{51.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z6 Z1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.59}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{52.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z1 Z7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.44}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{53.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z7 Z2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.56}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{54.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z2 Z8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.63}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{55.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z8 Z13}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.36}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{56.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z13 Z19}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.81}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{57.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z19 Z14}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.29}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{58.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z14 Z9}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.52}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{59.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z9 Z4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.43}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{60.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z13 Z18}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.72}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{61.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z18 Z12}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.40}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{62.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z12 Z7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.60}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{63.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z12 Z17}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.71}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{64.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z17 Z11}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.50}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{65.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z11 Z6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.64}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{66.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z11 Z16}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.57}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{67.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z16 Z10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.41}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{68.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z10 Z5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.23}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{69.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z10 Z15}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.40}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+m+mf}{70.}        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z5 Z0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.18}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{71.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{72.}
\PYG{l+m+mf}{73.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{74.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{75.}    \PYG{n}{QAOA} \PYG{n}{qaoa}\PYG{p}{;}
\PYG{l+m+mf}{76.}    \PYG{n}{auto} \PYG{n}{hamiltonian} \PYG{o}{=} \PYG{n}{getHamiltonian}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{77.}    \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{setHamiltonian}\PYG{p}{(}\PYG{n}{hamiltonian}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{78.}    \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{setStep}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{79.}    \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{setShots}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{80.}    \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{getOptimizer}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setDisp}\PYG{p}{(}\PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{81.}    \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{regiestUserDefinedFunc}\PYG{p}{(}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bind}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{myFunc}\PYG{p}{,}
\PYG{l+m+mf}{82.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{placeholders}\PYG{p}{:}\PYG{p}{:}\PYG{n}{\PYGZus{}1}\PYG{p}{,}
\PYG{l+m+mf}{83.}        \PYG{n}{hamiltonian}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{84.}
\PYG{l+m+mf}{85.}    \PYG{k}{return} \PYG{n}{qaoa}\PYG{o}{.}\PYG{n}{exec}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{86.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{87.}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.16}.png}\hspace*{\fill}}

\begin{center}图4.5.15 测量结果
\end{center}
\sphinxAtStartPar
  将图4.5.15的测量结果绘制出柱状，如图4.5.16所示，可以看到‘0001111’和‘1110000’这两个比特串测量得到的概率最大，也正是这个问题的解。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.5.17}.png}\hspace*{\fill}}

\begin{center}图4.5.16 测量结果柱状图
\end{center}
\sphinxstepscope


\section{4.6 VQE算法}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:vqe}}\label{\detokenize{rst/4.6VQE_u7b97_u6cd5::doc}}
\sphinxAtStartPar
  随着量子化学理论的不断完善，计算化学已经成了化学工作者解释实验现象、预测实验结果、指导实验设计的重要工具，在药物的合成、催化剂的制备等方面有着广泛的应用。但是，面对计算化学所涉及的巨大计算量，经典计算机在计算精度、计算尺寸等方面显得能力有限，这就在一定程度上限制了计算化学的发展。而费曼曾提出：可以创造一个与已知物理系统条件相同的系统，让它以相同的规律演化，进而获得我们自己想要的信息。费曼的这一猜想提示我们——既然化学所研究的体系是量子体系，我们何不在量子计算机上对其进行模拟呢？

\sphinxAtStartPar
  就目前的量子计算机发展水平而言，可以通过变分量子特征值求解算法（Variational\sphinxhyphen{}Quantum\sphinxhyphen{}Eigensolver，简称VQE），在量子计算机上实现化学模拟。该算法作为用于寻找一个较大矩阵H的特征值的量子与经典混合算法，不仅能保证量子态的相干性，其计算结果还能达到化学精度。


\subsection{4.6.1 计算化学}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id1}}
\sphinxAtStartPar
\sphinxstylestrong{1.1 定义}

\sphinxAtStartPar
  计算化学，顾名思义，就是利用数学方法通过计算机程序对化学体系进行模拟计算，以解释或解决化学问题。它主要包括两个分支——量子化学与分子模拟。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.1}.png}\hspace*{\fill}}

\begin{center}图4.6.1 计算化学
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{1.2 作用}

\sphinxAtStartPar
  早期由于计算能力较弱，化学研究主要以理论和实验交互为主。但随着科学技术的蓬勃发展、量子化学理论的不断完善，计算已经成为一种独立的科研手段，与理论和实验形成三足鼎立之势，如图4.6.2。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.2}.png}\hspace*{\fill}}

\begin{center}图4.6.2 三足鼎立之势
\end{center}
\sphinxAtStartPar
  而如今，计算化学对于化学工作者来说，已经成了解释实验现象、预测实验结果、指导实验设计的重要工具，在材料科学、纳米科学、生命科学等领域得到了广泛的应用。

\sphinxAtStartPar
\sphinxstylestrong{（1）原子间库仑衰变现象的成功预测} 

\sphinxAtStartPar
  早在1997年，赛德鲍姆（Cederbaum）等人通过计算和分析HF分子和水分子的电离谱，成功预测了2003年才发现的原子间库仑衰变现象（Interatomic Coulobic Decay,简称ICD）。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.3}.png}\hspace*{\fill}}

\begin{center}图4.6.3 HF分子和水分子的电离谱  \(^{[52]}\)
\end{center}
\sphinxAtStartPar
  原子间库仑衰变现象是指对于组成团簇的原子（或分子），如果它的电子层中存在激发态的电子，就可能会把能量传递到相邻原子的价层电子，使得后者电离变成阳离子。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.4}.png}\hspace*{\fill}}

\begin{center}图4.6.4 原子间库仑衰变现象 \(^{[53]}\)
\end{center}
\sphinxAtStartPar
  如图4.6.4中所示，左侧原子中的一个激发态电子，从高能级跃迁至低能级时，所释放出的能量被右侧原子的一个价层电子吸收，由于原子核对价层电子的束缚能力本来就比较弱，所以吸收了这部分能量的价层电子很容易逸出，使右侧原子变成阳离子。

\sphinxAtStartPar
  如今，人们正在尝试将这种现象应用于DNA损伤修复领域。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps819}.png}\hspace*{\fill}}

\begin{center}图4.6.5 DNA损伤修复
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{（2）α突触核蛋白聚集过程的动力学模拟} 

\sphinxAtStartPar
  2007年，齐格列尼等美国科研工作者利用超级计算中心的运算能力，对含有23万多个原子的体系进行动力学模拟，并结合生物化学分析和超微结构分析，首次揭示了α突触核蛋白的聚集过程及其在细胞膜表面形成致病孔状结构的复杂过程，这一成果为帕金森症的治疗提供了新的线索。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.6}.png}\hspace*{\fill}}

\begin{center}图4.6.6 动力学模拟
\end{center}

\subsection{4.6.2 量子化学}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id2}}
\sphinxAtStartPar
  量子化学，作为计算化学的主要研究方向之一，简单来说就是应用量子力学的规律和方法来研究化学问题。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.7}.png}\hspace*{\fill}}

\begin{center}图4.6.7 量子化学
\end{center}
\sphinxAtStartPar
  量子化学的研究范围包括：分子的结构、性质及其结构与性能之间的关系；分子与分子之间的相互作用；分子之间的相互碰撞和相互反应等问题。P.O.Lowdin提出量子化学可以分为三个领域，包括基础理论、计算方法和应用研究，三者之间相互影响，构成了三角关系，只有严密的理论、精细的算法、深入的应用相结合，才能构成完美的量子化学。但是，要想真正通过计算模拟、运用基础理论去解决或解释化学问题，仅仅依靠精细的算法还是无法实现，必须还要借助于计算机的计算能力。可以说，量子化学的发展与计算机的发展息息相关。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.8}.png}\hspace*{\fill}}

\begin{center}图4.6.8 三角关系
\end{center}
\sphinxAtStartPar
  由于在对一个 \(N\) 电子体系计算模拟时，往往需要解薛定谔方程，这就涉及到了 \(3N\) 维波函数的求解。
\begin{equation*}
\begin{split}\begin{aligned} &\hat{H} \Psi=E \Psi \\ &\hat{H}=\frac{h^{2}}{2 m_{e}} \sum_{i=1}^{n} \nabla_{i}^{2}-\sum_{i=1}^{n} \frac{Z e^{2}}{r_{i}}+\sum_{i=1}^{n} \sum_{j=1}^{n} \frac{e^{2}}{r_{i j}} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  由此可知，计算量会随着研究体系的电子数的增加而呈指数式递增。

\sphinxAtStartPar
  就目前而言，面对量子化学计算中所涉及到的如此惊人的计算量，经典计算机在计算精度、计算范围等方面十分有限。想要突破这一瓶颈，就必须依靠量子计算机强大的计算能力。因此，在量子计算机上实现量子化学模拟刻不容缓。


\subsection{4.6.3 量子化学模拟}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id3}}
\sphinxAtStartPar
  量子计算最引人注目的可能性之一是对其它量子系统的模拟。量子系统的量子模拟包含了广泛的任务，其中最重要的任务包括：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
量子系统时间演化的模拟。

\item {} 
\sphinxAtStartPar
基态属性的计算。

\end{enumerate}

\sphinxAtStartPar
  当考虑相互作用的费米子系统时这些应用特别有用，例如分子和强相关材料；费米子系统的基态性质的计算是凝聚态哈密顿量的相图映射出来的起点，它也为量子化学中电子结构问题的关键问题即反应速率提供了途径。

\sphinxAtStartPar
  由于在化学应用中的相关性，尺寸相对适中的分子系统，它们被认为是早期量子计算机的理想测试平台。更正式地，基态问题要求如下：

\sphinxAtStartPar
  对于某些物理哈密顿量 \(\mathrm{H}\) , 找到其最小特征值  \(\mathrm{E}{g}\) ，这样  \(\mathrm{H}\left|\varphi{g}\right\rangle=\mathrm{E}{g}\left|\varphi{g}\right\rangle\) ，其中 \(\left|\varphi_{g}\right\rangle\) 是对应于  \(\mathrm{E}_{g}\) 的特征向量。

\sphinxAtStartPar
  而量子化学模拟是指，将真实化学体系的哈密顿量（包括其形式和参数）映射到由自己构建的可操作哈密顿量上，然后通过调制参数和演化时间，找到能够反映真实体系的本征态。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.9}.png}\hspace*{\fill}}

\begin{center}图4.6.9 量子化学模拟过程
\end{center}
\sphinxAtStartPar
  众所周知，即使在量子计算机上，这个问题通常也是难以处理的，这意味着不能指望有一种有效的量子算法可以用来准备一般哈密顿量的基态。尽管存在这种限制，但对于特定的哈密顿量而言考虑到相互作用的物理限制，有可能有效地解决上述问题。目前，至少存在四种不同的方法来解决这个问题：

\sphinxAtStartPar
​  量子相位估计：假设可以近似准备状态 \(| \varphi_g \rangle\) ，该例使用哈密顿量的受控来找到其最小的特征值。

\sphinxAtStartPar
​  量子力学的绝热定理：通过哈密顿量的缓慢演化，量子系统被绝热地从一个普通哈密顿量的基态演化为期望目标问题的哈密顿量基态。

\sphinxAtStartPar
​  耗散（非酉矩阵）量子操作：目标系统的基态是个固定点，而非平凡假设是指在量子硬件上实现耗散映射。

\sphinxAtStartPar
​  变分量子特征值求解算法：假设基态可以用包含相对较少参数的参数化表示。

\sphinxAtStartPar
  为了使量子化学模拟在近期硬件设备上实现，我们采用变分量子特征值求解算法(Variational\sphinxhyphen{}Quantum\sphinxhyphen{}Eigensolver，简称VQE)来寻找体系的基态。该量子算法不仅能保证量子态的相干性，其计算结果还能达到化学精度。

\sphinxAtStartPar
  该算法是用于寻找一个较大矩阵H的特征值的量子与经典混合算法，如图4.6.10所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.10}.png}\hspace*{\fill}}

\begin{center}图4.6.10 算法示意图
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子化学计算包}

\sphinxAtStartPar
  常用的量子化学包有ussian16、PyQuante、pySCF、PSI4等。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.11}.png}\hspace*{\fill}}

\begin{center}图4.6.11 量子化学计算包
\end{center}
\sphinxAtStartPar
  其中，PSI4；它是开源的一款从头算量子化学计算包，它能够运用Hatree\sphinxhyphen{}Fock方法、密度泛函理论、耦合团簇理论、组态相互作用方法等方法对电子结构进行计算。后续章节将利用PSI4中的Hatree\sphinxhyphen{}Fock方法计算得到的二次哈密顿量构造量子线路，寻找H2的基态。


\subsection{4.6.4 费米子的哈密顿量}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id4}}
\sphinxAtStartPar
\sphinxstylestrong{1、二次量子化哈密顿量}
\begin{equation*}
\begin{split}H \Psi=E \Psi \qquad (1)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\hat{\mathrm{H}}_{\mathrm{el}}=-\frac{1}{2} \sum_{i=1}^{N} \nabla_{i}^{2}-\sum_{i=1}^{N_{\mathrm{el}}} \sum_{A=1}^{N_{\mathrm{nu}}} \frac{Z_{A}}{r_{i A}}+\sum_{i=1, j>i}^{N_{\mathrm{el}}, N_{\mathrm{el}}} \frac{1}{r_{i j}} \qquad(2)\end{split}
\end{equation*}
\sphinxAtStartPar
  在之前的章节中，我们曾提到描述  \(N\) 电子体系的薛定谔方程，其中式 (1) 中的  \(\hat{\mathrm{H}}\) 算符就是哈密顿算符。在玻恩\sphinxhyphen{}奥本海默近似下，电子哈密顿算符可以写成式 (2) 这种形式，其中  \(-\frac{1}{2} \sum_{i} \nabla_{i}^{2}\) 是电子的动能项;  \(-\sum_{A,i} \frac{Z_{A}}{r_{A i}}\) 是核与电子之间的引力势能项;  \(\sum_{i>j}\frac{1}{r_{i j}}\) 是电子之间的排斥能项。式 (2) 被称之为 “一次量子化电子哈密顿算符”。

\sphinxAtStartPar
  如图4.6.12所示，由于一次量子化哈密顿量映射到量子比特上需要耗费的量子比特数要比二次量子化哈密顿量多，VQE算法选择了更为经济的二次量子化哈密顿量。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.12}.png}\hspace*{\fill}}

\begin{center}图4.6.12 一次量子化与二次量子化
\end{center}
\sphinxAtStartPar
  所谓二次量子化哈密顿量就是将波场函数转换为场算符，这一转换需要借助创造算子 \(\mathrm{a}{\mathrm{p}}^{\dagger}\) 和湮灭算子  \(\mathrm{a}{\mathrm{q}}\) 来实现，它们满足反对易关系，即：
\begin{equation*}
\begin{split}\left\{a_{p}^{\dagger}, a_{q}\right\}=\delta_{p q}\end{split}
\end{equation*}
\sphinxAtStartPar
  最终可以得到如下形式的二次量子化哈密顿量：
\begin{equation*}
\begin{split}\hat{\mathrm{H}}_{P}=\sum_{p q} h_{p q} a_{p}^{\dagger} a_{q}+\frac{1}{2} \sum_{p q r s} h_{p q r s} a_{p}^{\dagger} a_{q}^{\dagger} a_{r} a_{s}\end{split}
\end{equation*}
\sphinxAtStartPar
  该式中，  \(\sum_{p q} h_{p q} a_{p}^{\dagger} a_{q}\) 是单粒子算符，  \(\frac{1}{2} \sum_{p q r s} h_{p q r s} a_{p}^{\dagger} a_{q}^{\dagger} a_{r} a_{s}\) 是双粒子算符；下标 \(pqrs\) 分别代表不同的单电子自旋分子轨道，  \(h_{p q}\) 和  \(h_{p q r s}\) 是常数项，前者称为 单电子积分项，后者称为双电子积分项。

\sphinxAtStartPar
  计算公式如下:
\begin{equation*}
\begin{split}\begin{aligned} &h_{p q}=\int d r x_{p}(\mathrm{r})^{*}\left(-\frac{1}{2} \nabla^{2}-\sum_{a} \frac{Z_{\alpha}}{\left|r_{\alpha}-r\right|}\right) x_{q}(r) \\ &h_{p q r s}=\int d r_{1} d r_{2} \frac{1}{\left|r_{1}-r_{2}\right|} \cdot x_{p}\left(r_{1}\right)^{*} x_{q}\left(r_{2}\right)^{*} x_{r}\left(r_{1}\right) x_{s}\left(r_{2}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\chi_{\mathrm{p}}\) 、 \(\chi_{\mathrm{q}}\) 等分别表示不同的单电子自旋轨道波函数；  \(\mathrm{Z}_{\alpha}\) 表示核电荷;  \(\mathrm{r}_{\alpha}\) 表示核位置;  \(\mathrm{r}_{1}\) 、 \(\mathrm{r}_{2}\) 分别表示不同电子的位置。

\sphinxAtStartPar
  从  \(h_{pq}\) 的计算公式中，可以发现括号中的两项正是一次量子化哈密顿量中的电子动能项  \(-\frac{1}{2} \nabla^{2}\) 和核与电子之间的引力势能项  \(-\sum_{\alpha} \frac{z_{\alpha}}{\left|r_{\alpha}-r\right|}\) , 只不过这里采用的是原子单位; 从 \(h_{p q r s}\) 的计算公式中，可以发现，  \(\frac{1}{\left|r_{1}-r_{2}\right|}\) 正是一次量子化哈密顿量中的电子间排斥能项。由此可见，  \(h_{p q}\) 和   \(h_{pqrs}\) 起到了联系二次量子化哈密顿量与一次量化哈密顿量的作用。

\sphinxAtStartPar
\sphinxstylestrong{2、H2分子费米子哈密顿量}

\sphinxAtStartPar
  众所周知，每个氢原子都有一个电子，填充在1s轨道上，如图4.6.13所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.13}.png}\hspace*{\fill}}

\begin{center}图4.6.13 氢原子
\end{center}
\sphinxAtStartPar
  而氢分子则由两个氢原子组成，那么它就含有两个电子。以q0、q1量子比特表示a号氢原子自旋向下和自旋向上的1s轨道，以q2、q3分别表示b号氢原子自旋向下和自旋向上的1s轨道，如图4.6.14所示。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.14}.png}\hspace*{\fill}}

\begin{center}图4.6.14 氢分子
\end{center}
\sphinxAtStartPar
  假设氢分子的两个电子分别处在q0和q1这两个轨道上面，如图4.6.15所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.15}.png}\hspace*{\fill}}

\begin{center}图4.6.15 q0和q1轨道
\end{center}
\sphinxAtStartPar
  如果以量子态  \(|1 \rangle\) 表示自旋轨道上有一个电子，以量子态  \(|0 \rangle\) 表示自旋轨道为空轨道，那么此时氢分子的状态可以表示为  \(|0011 \rangle\) 。

\sphinxAtStartPar
  当q0上的电子跃迁到q2上时，也就是电子先从q0上“湮灭”，然后在q1上“创造”，如图4.6.16所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.16}.png}\hspace*{\fill}}

\begin{center}图4.6.16 q0上的电子跃迁到q2上
\end{center}
\sphinxAtStartPar
  此时，其簇算符表示为
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{1}=t_{20} a_{2}^{\dagger} a_{0}\end{split}
\end{equation*}
\sphinxAtStartPar
  同理，当q0上的电子跃迁到q3上时，其哈密顿量可以表示为
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{2}=\mathrm{t}_{30} a_{3}^{\dagger} a_{0}\end{split}
\end{equation*}
\sphinxAtStartPar
  当q1上的电子跃迁到q2上时，其哈密顿量可以表示为
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{3}=\mathrm{t}_{21} a_{2}^{\dagger} a_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  当q1上的电子跃迁到q3上时，其哈密顿量可以表示为
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{4}=\mathrm{t}_{31} a_{3}^{\dagger} a_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  当q0、q1上的电子同时跃迁到q2、q3上时，其哈密顿量可以表示为
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{5}=\mathrm{t}_{3210}a_{3}^{\dagger} a_{2}^{\dagger} a_{0} a_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\mathrm{\hat{T}}_{1}\) 、 \(\mathrm{\hat{T}}_{2}\) 、 \(\mathrm{\hat{T}}_{3}\) 、 \(\mathrm{\hat{T}}_{4}\) 所描述的电子跃迁形式为单激发形式，而H5则是双激发形式。对于氢分子而言，由前四项单激发所构造成的哈密顿量称之为CCS，而由单激发和双激发所共同构造成的哈密顿量被称之为CCSD，也就是这五项之和，即：
\begin{equation*}
\begin{split}\mathrm{\hat{T}}_{U}=t_{20} a_{2}^{\dagger} a_{0}+t_{30} a_{3}^{\dagger} a_{0}+t_{21} a_{2}^{\dagger} a_{1}+t_{31} a_{3}^{\dagger} a_{1}+t_{3210} a_{3}^{\dagger} a_{2}^{\dagger} a_{0} a_{1}\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.17}.png}\hspace*{\fill}}

\begin{center}图4.6.17 CCS和CCSD
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{3、费米子算符类}

\sphinxAtStartPar
  假设，用字符串 \(X\) 来表示湮没算符，用字符串 \(X+\) 来表示创建算符，其中 \(X\) 表示电子轨道的序号，表达为：
\begin{equation*}
\begin{split}\begin{aligned} &{ }^{\prime \prime} X^{\prime \prime} \equiv a_{x} \\ &{ }^{\prime \prime} X+^{\prime \prime} \equiv a_{x}^{\dagger} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  例如,  \(\{^{\prime \prime} 1+0^{\prime \prime}, 2\} \equiv 2 a_{1}^{\dagger} a_{0}\)  ，表示电子在 0 号轨道湮没，在1号轨道创建，其系数为2;  \(\{^{\prime \prime}3+2+1+0^{\prime \prime}, 3\} \equiv 3 a_{3}^{\dagger} a_{2}^{\dagger} a_{1} a_{0}\)  表示有两个电子同时从0号轨道和1号轨道湮没，并在3号轨道和 2 号轨道创建，其系数为3。另外也可以定义电子之间的排斥能，例如：  \(\{^{\prime \prime\ \ \prime\prime}, 2\}=2 I\) ，表示电子之间的排斥能为 2 。

\sphinxAtStartPar
  在QPanda中实现示例

\sphinxAtStartPar
  通过如下示例代码构建费米子算符类。使用C++构建方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}Operator/FermionOperator.h\PYGZdq{}
2.int main()
3.\PYGZob{}
4.    using namespace QPanda;
5.    FermionOperator p1;
6.    FermionOperator p2(\PYGZob{} \PYGZob{}“1+  0”, 2\PYGZcb{},\PYGZob{}“3+ 2+  1 0”, 3\PYGZcb{} \PYGZcb{});
7.    FermionOperator p3(“1+ 0”, 2);
8.    FermionOperator p4(2); // FermionOperator p4(“”, 2);
9.    FermionOperator p5(p2);
10.
11.    return 0;
12.\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python构建方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3+ 2+ 1 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{p3} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{n}{p4} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{n}{p5} \PYG{o}{=} \PYG{n}{p2}
\end{sphinxVerbatim}

\sphinxAtStartPar
  构造一个空的费米子算符类P1，里面不包含任何创建和湮没算符及单位矩阵；也可以通过前面所述的规则，以字典序的形式构建多个表达式，例如P2；或者只构建一个表达式例如P3；还可以只构造一个电子之间排斥能项，例如P4；也可以通过已经构造好的费米子算符来构造它的一份副本例如P5。

\sphinxAtStartPar
  费米子算符类支持常规的加、减、乘等运算操作。计算返回的结果还是一个费米子算符类。

\sphinxAtStartPar
  假设定义了a和b两个费米子算符类，可以让费米子算符类之间进行加操作，减操作和乘操作。使用C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}Operator/FermionOperator.h\PYGZdq{}
2.using namespace QPanda;
3.int main()
4.\PYGZob{}
5.    FermionOperator a(“1+  0\PYGZdq{}, 2);
6.    FermionOperator b(“3+  2\PYGZdq{}, 3);
7.    auto plus = a + b;
8.    auto minus = a \PYGZhy{} b;
9.    auto muliply = a * b;
10.
11.    return 0;
12.\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3+ 2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{plus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\PYG{l+m+mf}{6.}    \PYG{n}{minus} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}
\PYG{l+m+mf}{7.}    \PYG{n}{muliply} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\end{sphinxVerbatim}

\sphinxAtStartPar
  费米子算符类同样也支持打印功能，可以直接将费米子算符类打印输出到屏幕上。C++打印输出方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a + b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{plus} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{2.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a \PYGZhy{} b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{minus} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{3.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{multiply} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python打印输出方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a + b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{plus}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{2.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a \PYGZhy{} b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{minus}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a * b = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{muliply}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过使用上述示例代码， a+b，a\sphinxhyphen{}b和a*b的计算结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{2.1}\PYG{o}{+} \PYG{l+m+mi}{0} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{3.3}\PYG{o}{+} \PYG{l+m+mi}{2} \PYG{p}{:} \PYG{l+m+mf}{3.000000}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{5.}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.1}\PYG{o}{+} \PYG{l+m+mi}{0} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{7.3}\PYG{o}{+} \PYG{l+m+mi}{2}  \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.000000}
\PYG{l+m+mf}{8.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{9.}\PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{10.1}\PYG{o}{+} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3}\PYG{o}{+} \PYG{l+m+mi}{2} \PYG{p}{:} \PYG{l+m+mf}{6.000000}
\PYG{l+m+mf}{11.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  还可以通过normal\_ordered接口对费米子算符进行整理。在这个转换中规定张量因子从高到低进行排序，并且创建算符出现在湮没算符之前。

\sphinxAtStartPar
  整理规则如下：对于相同数字，交换湮没和创建算符，等价于单位1减去正规序，如果同时存在两个创建或湮没算符，则该项表达式等于0；对于不同的数字，整理成正规序，需要将正规序的系数变为相反数。

\sphinxAtStartPar
  normal\_ordered接口的使用方式如示例代码所示。C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}Operator/FermionOperator.h\PYGZdq{}
2.using namespace QPanda;
3.int main()
4.\PYGZob{}
5.    FermionOperator a(\PYGZdq{}0 1 3+ 2+\PYGZdq{}, 2);
6.    auto muliply = a.normal\PYGZus{}ordered() ;
7.    std::cout \PYGZlt{}\PYGZlt{} “before = \PYGZdq{} \PYGZlt{}\PYGZlt{} a \PYGZlt{}\PYGZlt{} std::endl;
8.    std::cout \PYGZlt{}\PYGZlt{} “after = \PYGZdq{} \PYGZlt{}\PYGZlt{} b \PYGZlt{}\PYGZlt{} std::endl;
9.    return 0;
10.\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0 1 3+ 2+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{normal\PYGZus{}ordered}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{before = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{after = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  对于表达式“0 1 3+ 2+”，整理成正规序“3+ 2+ 1 0”，相当于不同数字交换了5次，系数变为了相反数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{before} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{2.0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{+} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{3.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{4.}\PYG{n}{after} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.3}\PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{+} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{6.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  费米子算符类还提供了其它一些常用功能，例如：isEmpyt接口，用来判断是否是个空的费米子算符；toString接口返回费米子算符的字符串形式；data接口返回费米子算符内部为维护的数据

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{isEmpyt}\PYG{p}{(}\PYG{p}{)}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{判空}
\PYG{l+m+mf}{2.}\PYG{n}{toString}\PYG{p}{(}\PYG{p}{)}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{返回字符串形式}
\PYG{l+m+mf}{3.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}            \PYG{o}{/}\PYG{o}{/} \PYG{n}{返回内部维护的数据}
\end{sphinxVerbatim}

\sphinxAtStartPar
  C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.\PYGZsh{}include \PYGZdq{}Operator/FermionOperator.h\PYGZdq{}
2.using namespace QPanda;
3.int main()
4.\PYGZob{}
5.    FermionOperator a(“1+  0\PYGZdq{}, 2);
6.
7.    auto data = a.data();
8.
9.    std::cout \PYGZlt{}\PYGZlt{} “isEmpty = “ \PYGZlt{}\PYGZlt{} a.isEmpty() \PYGZlt{}\PYGZlt{} std::endl;
10.    std::cout \PYGZlt{}\PYGZlt{} “stringValue = “ \PYGZlt{}\PYGZlt{} a.toString() \PYGZlt{}\PYGZlt{} std::endl;
11.
12.    return 0;
13.\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{5.}
\PYG{l+m+mf}{6.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{isEmpty = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{isEmpty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{strValue = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{toString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  计算结果为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{isEmpty} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{l+m+mf}{2.}\PYG{n}{strValue} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{3.1}\PYG{o}{+} \PYG{l+m+mi}{0} \PYG{p}{:} \PYG{l+m+mf}{2.000000}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{5.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{4、可变费米子算符类和可变泡利算符类}

\sphinxAtStartPar
  费米算符类是一个模板类，如果用complex来构造该模板参数T，得到的就是费米子算符类；如果用complex\_var类来构造模板参数T，得到的就是可变费米子算符类；同样泡利算符类也是一个模板类，选择不同的模板参数类型，可以得到泡利算符类和可变泡利算符类，如图4.6.18。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.18}.png}\hspace*{\fill}}

\begin{center}图4.6.18 泡利算符类和可变泡利算符类
\end{center}
\sphinxAtStartPar
  可变费米子算符类和可变泡利算符类，跟费米子算符类和泡利算符类拥有相同的接口，但是在构造它们的时候所传的参数是个Var变量。Var类是VQNet框架中的符号计算系统，在表达式不变的情况下，通过改变Var的值，即可改变表达式的值。因此可以通过构造可变费米子算符类和可变泡利算符类并利用VQNet框架，来实现VQE算法。

\sphinxAtStartPar
  C++示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include “Veriational/VarFermionOperator.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}include “Veriational/VarPauliOperator.h\PYGZdq{}}
\PYG{l+m+mf}{3.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{Variational}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{6.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{7.}    \PYG{n}{var} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)} \PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{var} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)} \PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{VarFermionOperator} \PYG{n}{fermion\PYGZus{}op}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1+  0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}    \PYG{n}{VarPauliOperator} \PYG{n}{pauli\PYGZus{}op}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z1  Z0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{12.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  python示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{a} \PYG{o}{=} \PYG{n}{var}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{b} \PYG{o}{=} \PYG{n}{var}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{VarFermionOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1+ 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{n}{pauli\PYGZus{}op} \PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z1 Z0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{费米子算符类构造分子的哈密顿量示例介绍}

\sphinxAtStartPar
  通过向get\_ccsd接口传入轨道个数（也就是比特数）、电子数和每一个子项的系数，即可构造所需的费米子哈密顿量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ccsd}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{,} \PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{\PYGZgt{}}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{3.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{4.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{==}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{k}{return} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{k}{if} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)} \PYG{o}{!=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{13.}        \PYG{k}{for} \PYG{n}{ex} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{,} \PYG{n}{qn}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{14.}            \PYG{n}{fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{15.}            \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}electron}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{18.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n\PYGZus{}electron}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{19.}            \PYG{k}{for} \PYG{n}{ex1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}electron}\PYG{p}{,}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{20.}                \PYG{k}{for} \PYG{n}{ex2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ex1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{21.}                    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}
\PYG{l+m+mf}{22.}                        \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex2}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex1}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{23.}                        \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}
\PYG{l+m+mf}{24.}                    \PYG{p}{)}
\PYG{l+m+mf}{25.}                    \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}    \PYG{k}{return} \PYG{n}{fermion\PYGZus{}op}
\end{sphinxVerbatim}

\sphinxAtStartPar
  在图4.6.19中，红色框起来的部分代码构造的是单电子激发的哈密顿量，绿色框起来的部分构造的是双电子激发的哈密顿量。构造CCS只需要包含红色框起来的部分即可，而构造CCSD需要包含红色和绿色框起来的代码。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.19}.png}\hspace*{\fill}}

\begin{center}图4.6.19 构造CCS和CCSD
\end{center}
\sphinxAtStartPar
  在二次量子化哈密顿量的介绍中，曾提到过费米子算符遵循反对易关系，  \(\left[a_{p}^{\dagger}, a_{q}\right]=\delta_{p q}\) ， 因此， 在进行量子化学模拟时，将费米子哈密顿量成功映射到量子比特 上的核心问题在于能否在量子线路的构造中将这一反对易关系反映出来,为了解决这一问题，需要通过J\sphinxhyphen{}W变换、Parity变换、B\sphinxhyphen{}K变换等方法将费米子算符转换成泡利算符。

\sphinxAtStartPar
\sphinxstylestrong{J\sphinxhyphen{}W变换}
\begin{equation*}
\begin{split}\begin{aligned} &a_{j}^{\dagger}=I^{\otimes n-j-1} \otimes Q^{+} \otimes Z_{j-1}^{\oplus}(1) \\ &a_{j}=I^{\otimes n-j-1} \otimes Q^{-} \otimes Z_{j-1}^{\over{ }}(2) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
将创造算子和湮灭算子分别表示成式 (1) 、式 (2) 这种形式, 其中,  \(n\) 表示自旋轨道的数目，也就是量子比特数;  \(j\) 为算符所作用的子空间，也就是量子比特序号;  \(\quad Z^{\rightarrow}_{j-1}\) 这一项被称之为宇称算子，定义如下:
\begin{equation*}
\begin{split}Z_{j-1}^{\rightarrow}=\sigma_{j-1}^{z} \otimes \sigma_{j-2}^{z} \otimes \ldots \otimes \sigma_{1}^{z} \otimes \sigma_{0}^{z}\end{split}
\end{equation*}
\sphinxAtStartPar
  为了能够同  \(Z_{j-1}\) 一起将创造算子和湮灭算子之间的反对易关系反映出来，需要将  \(Q^{+}\) 、 \(Q^{-}\) 分别构造成  \(|1\rangle\) 和  \(|0\rangle\) 的外积、  \(|0\rangle\) 和  \(|1\rangle\) 的外积，即：
\begin{equation*}
\begin{split}\begin{aligned} &Q^{+}=|1\rangle \langle0|=\frac{1}{2}\left(\sigma^{x}-i \sigma^{y}\right) \\ &Q^{-}=|0\rangle \langle1|=\frac{1}{2}\left(\sigma^{x}+i \sigma^{y}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  \(J-W\) 变换需要消耗的逻辑门个数与量子比特数成线性关系。

\sphinxAtStartPar
  可以通过QPanda或者pyQPanda来构造 \(J-W\) 变换，这里给出的是python代码示例， get\_fermion\_jordan\_wigner接口返回的是费米子算符中的一个子项 \(J-W\) 变换。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}item}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fermion\PYGZus{}item}\PYG{p}{:}
\PYG{l+m+mf}{4.}        \PYG{n}{op\PYGZus{}qubit} \PYG{o}{=} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{5.}        \PYG{n}{op\PYGZus{}str} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{6.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}            \PYG{n}{op\PYGZus{}str} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{8.}        \PYG{n}{op\PYGZus{}str1} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{9.}        \PYG{n}{op\PYGZus{}str2} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}        \PYG{n}{pauli\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{12.}        \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}        \PYG{k}{if} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
\PYG{l+m+mf}{15.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{16.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{17.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}        \PYG{n}{pauli} \PYG{o}{*}\PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}map}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
  JordanWignerTransform是对整个费米子算符进行 \(J-W\) 变换。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{data} \PYG{o}{=} \PYG{n}{fermion\PYGZus{}op}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{pauli} \PYG{o}{+}\PYG{o}{=} \PYG{n}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{6.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
  JordanWignerTransformVar是对可变费米子算符进行 \(J-W\) 变换。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{JordanWignerTransformVar}\PYG{p}{(}\PYG{n}{var\PYGZus{}fermion\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{data} \PYG{o}{=} \PYG{n}{var\PYGZus{}fermion\PYGZus{}op}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{n}{var\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{one\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{6.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{one\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}            \PYG{n}{var\PYGZus{}pauli} \PYG{o}{+}\PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{complex\PYGZus{}var}\PYG{p}{(}
\PYG{l+m+mf}{8.}                \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}
\PYG{l+m+mf}{9.}                \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{o}{+}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{n}{var\PYGZus{}pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Parity变换}
\begin{equation*}
\begin{split}\begin{aligned}a_{j}^{\dagger} & \equiv \frac{1}{2} X_{j+1}^{\leftarrow} \otimes\left(\sigma_{j}^{x} \otimes \sigma_{j-1}^{z}-i \sigma_{j}^{y}\right) \\a_{j} & \equiv \frac{1}{2} X_{j+1}^{\leftarrow} \otimes\left(\sigma_{j}^{x} \otimes \sigma_{j-1}^{z}+i \sigma_{j}^{y}\right)\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\(X_{j+1}^{\leftarrow}\) 称为更新算子，定义式如下：
\begin{equation*}
\begin{split}X_{j+1}^{\leftarrow}=\sigma_{n-1}^{x} \otimes \sigma_{n-2}^{x} \otimes \ldots \otimes \sigma_{j+2}^{x} \otimes \sigma_{j+1}^{x}\end{split}
\end{equation*}
\sphinxAtStartPar
  通过比较J\sphinxhyphen{}W变换和Parity变换，可以发现，由于J\sphinxhyphen{}W变换中存在宇称算子，而Parity变换中存在更新算子，所以Parity变换所需要消耗的逻辑门数也是与量子比特数成线性关系。

\sphinxAtStartPar
\sphinxstylestrong{B\sphinxhyphen{}K 变换}
\begin{equation*}
\begin{split}\begin{aligned} &a_{j}^{+}=\frac{1}{2} X_{U(j)} \otimes\left(\sigma_{j}^{x} \otimes Z_{P(j)}-i \sigma_{j}^{y} \otimes Z_{\rho(j)}\right) \\ &a_{j}=\frac{1}{2} X_{U(j)} \otimes\left(\sigma_{j}^{x} \otimes Z_{P(j)}+i \sigma_{j}^{y} \otimes Z_{\rho(j)}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  从B\sphinxhyphen{}K变换的表达式不难发现，它要比J\sphinxhyphen{}W变换和Parity变换复杂的多，因为它既有更新算子 \(X_U\) ，又有宇称算子 \(Z_P\) ，只不过在这里，更新算子不再是 \((\mathrm{n}-\mathrm{j}-1)\) 个泡利X的张量积，宇称算子也不再是j个泡利Z的张量积。最后一项 \(Z_{P(j)}\) 在j为偶数时，就等于宇称算子，在j为奇数时，就等于 \(Z_{R(j)}\) 。 \(R(j)\) 被称之为余子集，它等于  \(P(j)\) 对翻转集  \(F(j)\) 求余，即：
\begin{equation*}
\begin{split}R(j)=P(j) \% F(j)\end{split}
\end{equation*}
\sphinxAtStartPar
  假设 \(j=3\) , 若 \(U(3)=(q5,q6)\) ,  \(P(3)=(q0,q2)\) ,  \(F(3)=(q0)\) ，则更新算子就等于作用于相应量子比特上的两个泡利  \(x\) 的张量积，宇称算子就等于作用于相应量子比特上的两个泡利  \(z\) 的张量积。
\begin{equation*}
\begin{split}X_{U(3)}=\sigma_{6}^{x} \otimes \sigma_{5}^{x}, \quad Z_{P(3)}=\sigma_{2}^{z} \sigma_{0}^{z}\end{split}
\end{equation*}
\sphinxAtStartPar
  而余子集：
\begin{equation*}
\begin{split}\mathrm{R}(3)=P(3) \% F(3)=(\mathrm{q} 2)\end{split}
\end{equation*}
\sphinxAtStartPar
  由此：
\begin{equation*}
\begin{split}Z_{\rho(3)}=Z_{R(3)}=\sigma_{2}^{z}\end{split}
\end{equation*}
\sphinxAtStartPar
  虽然，B\sphinxhyphen{}K变换相对于J\sphinxhyphen{}W变换和Parity变换的在形式上很复杂，但实际上它所需要消耗的量子逻辑门数是与量子比特数的对数成线性关系，可以节省量子逻辑门资源，简化量子线路。


\subsection{4.6.5 算法原理}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id5}}
\sphinxAtStartPar
  对于一个  \(n\) 阶的较大方阵，如果想找到它的特征值， \(\lambda_{1} \lambda_{2} \ldots \lambda_{n}\) 可以利用VQE算法，同样该算法也可以寻找到描述某一体系 (如多电子体系) 的哈密顿量的特征值，  \(\mathrm{E}_{1} ,\mathrm{E}_{2}, \cdots ,\mathrm{E}_{n}\) ，进而求得体系的基态能量 \(\mathrm{E}_0\) ， VQE算法是基于变分原理而提出的。

\sphinxAtStartPar
  所谓变分原理，是指对于任意一个试验态 (它是一个品优波函数)，用某一体系 (如多电子体系) 的哈密顿量作用于它时，可以得到该体系在这一状态下的平均能量  \(\mathrm{E}\)  ，它将大于或接近于体系的基态能量  \(\mathrm{E}_{0}\) ，即：
\begin{equation*}
\begin{split}\mathrm{E}=\frac{\left\langle\psi^{*}|\mathrm{H}| \psi\right\rangle}{\left\langle\psi^{*} \mid \psi\right\rangle} \geq \mathrm{E}_{0}\end{split}
\end{equation*}
\sphinxAtStartPar
  从该表达式中不难看出，如果所选择的试验态  \(|\psi\rangle\) 正好就是体系的基态  \(\left|\psi_{0}\right\rangle\) , 那么不等式中的等号成立，直接得到了体系的基态能量 \(\mathrm{E}\) ; 但往往更多的情况是, 选择的试验态  \(|\psi\rangle\) 与体系的基态相比有一定差距，导致计算得到的  \(\mathrm{E}\) 大于  \(\mathrm{E}_0\) 很多，这时就需要引入一组参数  \(\vec{ \mathrm{t}}\) ，通过不断调节 来调节试验态， \(\vec{ \mathrm{t}}\) 使其最终非常接近体系的基态。

\sphinxAtStartPar
  通过对变分原理的介绍，可以发现：VQE算法在寻找体系基态能量时，实际上需要依次完成三步操作：

\sphinxAtStartPar
   (1) 制备试验态  \(\left|\psi\left(\vec{ \mathrm{t}}\right)\right\rangle\) ；

\sphinxAtStartPar
   (2) 测量试验态  \(\left|\psi\left(\vec{ \mathrm{t}}\right)\right\rangle\) 的平均能量 \(\mathrm{E}_n\) ;

\sphinxAtStartPar
   (3) 判断 \(\mathrm{E}_n - \mathrm{E}_{n-1}\) 是否小于所设定的阈值，是，就返回 \(\mathrm{E}_n\) 作为基态能量; 否，则用优化器优化生成一组新参数  \(\vec{ \mathrm{t}}\) 重新制备试验态。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.20}.png}\hspace*{\fill}}

\begin{center}图4.6.20 VQE算法
\end{center}
\sphinxAtStartPar
  显然，如图4.6.20所示，这是一个循环迭代的过程。其中，步骤（1）和（2）是在量子处理器上完成的，步骤（3）是在经典处理器上完成的。在构造量子线路以制备试验态时， VQE算法利用了幺正耦合团簇理论(UCC理论)和渐进近似定理；在试验态能量进行测量时，VQE采用的是量子期望估计方法；在对参数  \(\vec{t}\) 进行优化时，VQE算法利用的是非线性的经典优化器，包括梯度无关和梯度相关两大类，这两类优化器已经在QAOA算法原理章节介绍过了，这里不再赘述。

\sphinxAtStartPar
\sphinxstylestrong{1、初始化Hatree\sphinxhyphen{}Fock态}

\sphinxAtStartPar
  对于含有四个单电子自旋分子轨道两个电子的氢分子的Hatree\sphinxhyphen{}Fock态，是用量子态 \(|0011\rangle\) 来表示的，即一个量子比特代表一个自旋分子轨道， \(|0\rangle\) 表示空轨道， \(|1\rangle\) 表示占据轨道。这样的话，只要在q{[}0{]}和q{[}1{]}上分别加上一个 \(NOT\) 门，就可以在量子线路中将 \(|0000\rangle\) 初始化成 \(|0011\rangle\) ，如图4.6.21所示。
\begin{equation*}
\begin{split}H_{2}:|\varphi\rangle_{\text {Hartree-Fock }}=|0011\rangle\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.21}.png}\hspace*{\fill}}

\begin{center}图4.6.21 初始化Hartree\sphinxhyphen{}Fock态
\end{center}
\sphinxAtStartPar
  事实上，对于任意一个含有M个自旋分子轨道分子轨道的N电子体系，它的hatree\sphinxhyphen{}fock态都可以这样简单的表示，如图4.6.22所示，只要在量子线路中给定M个量子比特，然后在前N个量子线路上加上NOT门即可得到所需要的N电子体系的hatree\sphinxhyphen{}fock态。

\sphinxAtStartPar
   \(N\) 电子体系（ \(M\) 自旋轨道）： \(|\varphi\rangle_{\text {Hartree-Fock }} \equiv |0 \ldots 011 \ldots 11\rangle\)

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.22}.png}\hspace*{\fill}}

\begin{center}图4.6.22 N电子体系的Hartree\sphinxhyphen{}Fock态
\end{center}
\sphinxAtStartPar
  在QPanda或pyQPanda中用如下示例代码来初始化Hatree\sphinxhyphen{}fock态：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{prepareInitialState}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{en}\PYG{p}{:}
\PYG{l+m+mf}{4.}        \PYG{k}{return} \PYG{n}{circuit}
\PYG{l+m+mf}{5.}
\PYG{l+m+mf}{6.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{k}{return} \PYG{n}{circuit}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{2、耦合簇法（Coupled Cluster, CC）}

\sphinxAtStartPar
  它是一种从Hatree\sphinxhyphen{}Fock分子轨道  \(|\varphi\rangle\) 出发，通过拟设得到试验态  \(|\psi\rangle\) 的方法。这里的拟设为指数耦合簇算符 \(e^{T}\) ：
\begin{equation*}
\begin{split}|\psi\rangle=e^{T}|\varphi\rangle_{\text {Hatree }-\text { Fock }}\end{split}
\end{equation*}
\sphinxAtStartPar
拟设中的 \(\mathrm{\hat{T}}\) 就是  \(N\) 电子簇算符，其定义式为若干激发算符之和，即:
\begin{equation*}
\begin{split}\mathrm{\hat{T}}=\mathrm{\hat{T}}_{1}+\mathrm{\hat{T}}_{2}+\mathrm{\hat{T}}_{3}+\mathrm{\hat{T}}_{4}+\mathrm{\hat{T}}_{5}+\cdots+\mathrm{\hat{T}}_{N}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中  \($\mathrm{\hat{T}}_1\) 是单粒子激发算符， \($\mathrm{\hat{T}}_2\) 是双粒子激发算符，其余项以此类推。由于在一个多电子体系中，三激发、四激发发生的概率很小，所以通常在双激发处进行“截 断”，最终只剩  \($\mathrm{\hat{T}}_1\) 和 \($\mathrm{\hat{T}}_2\) 两项，它们的定义式如下：
\begin{equation*}
\begin{split}\mathrm{\hat{T}}=\mathrm{\hat{T}}_{1}+\mathrm{\hat{T}}_{2}\end{split}
\end{equation*}
\sphinxAtStartPar
其中:
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{\hat{T}}_{1}=\sum_{pq} t_{pq} a_{p}^{\dagger} a_{q} \\ &\mathrm{\hat{T}}_{2}=\sum_{pq r s} t_{p q r s} a_{p}^{\dagger} a_{q}^{\dagger} a_{r} a_{s} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
这里的待定系数 \(\mathrm{t}{\mathrm{pq}}\) 、 \(\mathrm{t}{\mathrm{p q r s}}\) 就是需要通过优化器来寻找的参数 \(\vec{ \mathrm{t}}\) :
\begin{equation*}
\begin{split}\vec{\mathrm{t}}= \begin{cases}\left.\mathrm{t}_{\mathrm{pq}}, \mathrm{t}_{\text {pqrs }}\right\} & \end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
对于描述氢分子的 \(|0011\rangle_{\text {hatree-fock }}\) 态，此时的 \(\mathrm{\hat{T}}\) 正是费米子哈密顿量 \(\mathrm{H}_{\mathrm{U}}\) :
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{\hat{T}}=\mathrm{H}_{\mathrm{U}}=t_{20} a_{2}^{\dagger} a_{0}+t_{30} a_{3}^{\dagger} a_{0}+t_{21} a_{2}^{\dagger} a_{1}+t_{31} a_{3}^{\dagger} a_{1}+t_{3210} a_{3}^{\dagger} a_{2}^{\dagger} a_{1} a_{0} \\ &\mathrm{\hat{T}}_{1}=t_{20} a_{2}^{\dagger} a_{0}+t_{30} a_{3}^{\dagger} a_{0}+t_{21} a_{2}^{\dagger} a_{1}+t_{31} a_{3}^{\dagger} a_{1} \\ &\mathrm{\hat{T}}_{2}=t_{3210} a_{3}^{\dagger} a_{2}^{\dagger} a_{1} a_{0} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  当 \(\mathrm{\hat{T}}=\mathrm{\hat{T}}_1\) 时，即由前四项单激发所构造成的哈密顿量，称之为 \(\mathrm{CCS}\) ; 当  \(\mathrm{\hat{T}}=\mathrm{\hat{T}}_1+\mathrm{\hat{T}}_2\) 时，即由单激发和双激发所共同构造成的哈密顿量。称之为 \(\mathrm{CCSD}\) 。

\sphinxAtStartPar
\sphinxstylestrong{3、耦合簇法（UCC）}

\sphinxAtStartPar
  但是，想要将 \(\mathrm{e}^{\mathrm{T}}\) 这种指数耦合簇算符通过J\sphinxhyphen{}W变换、B\sphinxhyphen{}K变换等方法映射到量子比特上，这是行不通的，因为这 \(\mathrm{e}^{\mathrm{T}}\) 种指数耦合簇算符不是酉算子,无法设计成量子线路，所以，需要构造出酉算子版本的指数耦合笶算符，即么正耦合笶算符 (Unitary Coupled Cluster, UCC)，可以完美的解决这个问题。那么我如何构造UCC呢?

\sphinxAtStartPar
  首先，定义一个等效的厄米哈密顿量  \(\mathrm{\hat{T}(\vec{ \mathrm{t}})}\) ， 令它等于 \(i\left(\hat{T}-\hat{T}^{\dagger}\right)\) 。
\begin{equation*}
\begin{split}\mathrm{\hat{T}}(\vec{\mathrm{t}})=\mathrm{i}\left(\mathrm{\hat{T}}-\mathrm{\hat{T}}^{\dagger}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  然后，以  \(\mathrm{\hat{T}(\vec{ \mathrm{t}})}\) 为生成元就生成了UCC算符：
\begin{equation*}
\begin{split}\mathrm{U}[\mathrm{\hat{T}(\vec{ \mathrm{t}})}]=\exp [-\mathrm{i\hat{T}}({\vec{ \mathrm{t}}})]=e^{\mathrm{\hat{T}}-\mathrm{\hat{T}}^{\dagger}}\end{split}
\end{equation*}
\sphinxAtStartPar
  若UCC中的簇算符  \(\mathrm{\hat{T}}\) 只含有 \(\mathrm{\hat{T}}_1\) 这一项，则称这一拟设为单激发耦合簇 (UCCS)；若UCC中的簇算符 \(\mathrm{\hat{T}}\) 含有 \(\mathrm{\hat{T}}_{1}\) 和 \(\mathrm{\hat{T}}_{2}\) 两项，则称这个拟设为单双激发耦合簇算符(UCCSD) 。

\sphinxAtStartPar
\sphinxstylestrong{4、渐进近似定理}

\sphinxAtStartPar
  费米子哈密顿量通过  \(\mathrm{J}-\mathrm{W}\) 变换变成泡利算子形式时，它是若干子项的和，表达式为：
\begin{equation*}
\begin{split}\mathrm{\hat{H}}(\vec{t})=\mathrm{\hat{H}}(\vec{h})=\sum h_{\alpha}^{i} \sigma_{\alpha}^{i}+\sum h_{\alpha \beta}^{i j} \sigma_{\alpha}^{i} \otimes \sigma_{\beta}^{j}+\ldots\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(\sigma\) 是泡利算子，  \(\alpha, \beta \in(X, Y, Z, I)\) ，而  \(i\) ,  \(j\) 则表示哈密顿量子项所作用的子空间，  \(h\) 是实数。但是，如果对这些子项进行求和，最后得到的泡利算子形式哈密顿量想要对角化以生成酉算子，是比较困难的。

\sphinxAtStartPar
  那么，假设令 \(\mathrm{\hat{H}}_{k}\left(h_{a \beta}^{i j}\right)=\frac{h_{a}^{i} \sigma_{\alpha}^{j}}{h_{a}^{\alpha} \sigma_{\alpha}} / \sigma_{\alpha}^{i} \otimes \sigma_{\beta}^{j} /  \cdot\cdot\cdot\) ，是不是就可以将该哈密顿量分解成有限个酉算子 \(U_k\) 了呢?
\begin{equation*}
\begin{split}\begin{aligned} \mathrm{U}[\hat{H}(\vec{h})] &=\exp [-\mathrm{iH}(\vec{h})] \\ &=\exp \left[-\mathrm{i} \sum H_{k}\left(h_{a \beta . .}^{i j ..}\right)\right] \\ &=\prod \exp \left[-\mathrm{i} \mathrm{H}_{k}\left(h_{\alpha \beta . .}^{i j . }\right)\right] \\ &= \prod U_{k}\left[H_{k}\left(h_{\alpha \beta . .}^{i j . .}\right)\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  答案是不可以，这是因为一般情况下，子项 \(\mathrm{\hat{H}}_k\) 之间并不是对易的，即：
\begin{equation*}
\begin{split}\left[\mathrm{\hat{H}}_{k}, \mathrm{\hat{H}}_{l}\right] \neq 0\end{split}
\end{equation*}
\sphinxAtStartPar
  这推导过程中:
\begin{equation*}
\begin{split}\exp \left[-i \sum \mathrm{\hat{H}}_{k} \left( \ h_{\alpha \beta  . .}^{i j ..}\right)\right] \neq \prod \exp \left[-i\mathrm{\hat{H}}_{k}\left(h_{\alpha \beta . .}^{i j ..}\right)\right].\end{split}
\end{equation*}
\sphinxAtStartPar
为了能够以每个子项 \(\mathrm{\hat{H}}_k\) 为生成元将UCC算符分解成有限个酉算子来进行哈密顿量模拟，有必要引进渐进近似定理一一特罗特公式 (Trotter Foluma)，该定理是量子仿真算法的核心:
\begin{equation*}
\begin{split}\lim _{n \rightarrow \infty}\left(e^{i A t / n} e^{i B t / n}\right)^{n}=e^{i(A+B) t}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中， \(A\) 、 \(B\) 均为厄米算符,  \(\mathrm{t}\) 为实数， \(\mathrm{n}\) 为正整数。

\sphinxAtStartPar
  从特罗特公式可以看出，如果将系数 \(h\) 分成 \(n\) 片,每一片记为  \(\theta\) ， 即：
\begin{equation*}
\begin{split}h_{a \beta . .}^{i j ..}=\mathrm{n} * \theta_{\alpha \beta ..}^{i j ..}\end{split}
\end{equation*}
\sphinxAtStartPar
那么，当 \(n\) 趋于无穷大时，可以得到:
\begin{equation*}
\begin{split}\exp \left[-i \sum \hat{H}_{k}\left(h_{\alpha \beta . .}^{i j ..}\right)\right]=\left\{\prod\left[\exp \left[-\mathrm{i\hat{H}}_{k}\left(\theta_{\alpha \beta . .}^{i j ..}\right)\right]\right\}^{n}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
  这就提供了一个分解UCC算子构造量子线路的新思路:   如图4.6.23所示，可以通过三次演化逐步逼近最终得到试验态，这样的话每一次演化都是通过有限个酉算子 \(U_k\) 所构造的量子线 \(\mathrm{U}{k}\left(\Pi U{k}\right)\) 。

\sphinxAtStartPar
  此时， \(U_k\) 的生成元为：  \(\mathrm{\hat{H}}_{k}\left(\theta_{\alpha \beta ..}^{\mathfrak{ij} ..}\right)\) , 其中
\begin{equation*}
\begin{split}\theta_{\alpha, \beta . .}^{ij \ldots}=\frac{h_{\alpha, \beta . .}^{ij..}}{3}\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.23}.png}\hspace*{\fill}}

\begin{center}图4.6.23 三次演化
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{5、哈密顿量模拟}

\sphinxAtStartPar
  假设 \(J-W\) 变换后的泡利算子型哈密顿量 \(\mathrm{\hat{H}}\) 形式如下:
\begin{equation*}
\begin{split}\mathrm{\hat{H}}=\mathrm{\hat{H}}_{1}+\mathrm{\hat{H}}_{2}+\mathrm{\hat{H}}_{3}+\mathrm{\hat{H}}_{4}+\mathrm{\hat{H}}_{5}=\sigma_{z}^{0}+\sigma_{z}^{0} \otimes \sigma_{z}^{1}+\sigma_{z}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2}+\sigma_{x}^{0} \otimes \sigma_{z}^{1}+\sigma_{y}^{0} \otimes \sigma_{z}^{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  将以它为例具体介绍如何构造量子线路来模拟哈密顿量。

\sphinxAtStartPar
  根据渐进近似定理，可以逐项模拟。先对 \(\mathrm{\hat{H}}_1\) 项进行模拟：
\begin{equation*}
\begin{split}\mathrm{U}_{1}\left(\mathrm{\hat{H}}_{1}, \mathrm{\theta}_{1}\right)=e^{-i \sigma_{z}^{0} \theta_{1}}=\left[\begin{array}{cc} e^{-i \theta_{1}} & 0 \\ 0 & e^{i \theta_{1}} \end{array}\right]=\mathrm{RZ}\left(0,2 \theta_{1}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  通过推导，不难得出在 \(q[0]\) 上直接加上 \(\mathrm{RZ}\) 门即可模拟 \(\mathrm{\hat{H}}_1\) 项。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.24}.png}\hspace*{\fill}}

\begin{center}图4.6.24 模拟 \(H_1\) 项（此时 \(RZ\) 门表达式为 \(2\theta_{1}\) ）
\end{center}
\sphinxAtStartPar
对于 \(\mathrm{H}_2\) 项进行模拟:
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{U}_{2}\left(\mathrm{\hat{H}}_{2}, \theta_{2}\right)=e^{-i \sigma_{z}^{0} \otimes \sigma_{z}^{1} \theta_{2}}=\left[\begin{array}{cccc} e^{-i \theta_{2}} & 0 & 0 & 0 \\ 0 & e^{i \theta_{2}} & 0 & 0 \\ 0 & 0 & e^{i \theta_{2}} & 0 \\ 0 & 0 & 0 & e^{-i \theta_{2}} \end{array}\right] \\ &=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{array}\right]\left[\begin{array}{cccc} e^{i \theta_{2}} & 0 & 0 & 0 \\ 0 & e^{-i \theta_{2}} & 0 & 0 \\ 0 & 0 & e^{i \theta_{2}} & 0 \\ 0 & 0 & 0 & e^{-i \theta_{2}} \end{array}\right]\left[\begin{array}{llll} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{array}\right] \\ &=\text{CNOT}(0,1) \ \text{RZ}\left(1,2 \theta_{2}\right) \ \text{CNOT}(0,1) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  通过推导可以发现，想要模拟 \(\mathrm{\hat{H}}_2\) 项，需以q0为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) 门，然后在q1上加上 \(\mathrm{RZ}(2 \theta{2})\) 门，接着再以q0比特为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) 门：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.25}.png}\hspace*{\fill}}

\begin{center}图4.6.25 模拟 \(H_2\) 项（此时 \(RZ\) 门表达式为 \(2\theta_{2}\) ）
\end{center}
\sphinxAtStartPar
  对于 \(\mathrm{\hat{H}}_3\) 项，可以参照 \(\mathrm{\hat{H}}_1\) 和 \(\mathrm{\hat{H}}_2\) ，可得
\begin{equation*}
\begin{split}\mathrm{U}_{3}\left(\mathrm{\hat{H}}_{3}, \theta_{3}\right)=e^{-i \sigma_{z}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2} \theta_{3}}=\text{CNOT}(0,2) \text{CNOT}(1,2) \mathrm{RZ}\left(2,2 \theta_{3}\right) \text{CNOT}(1,2) \text{CNOT}(0,2)\end{split}
\end{equation*}
\sphinxAtStartPar
  通过推导，可知模拟 \(\mathrm{\hat{H}}3\) 项，需要先依次以q0为控制比特q2为目标比特、q1为控制比特q2为目标比特依次添加上两个 \(\mathrm{CNOT}\) 门，然后在q2上加上  \(\mathrm{RZ}(2 \theta{3})\) 门，接着再依次以q0为控制比特q2为目标比特、q1为控制比特q2比特为目标比特依次添加上两个  \(\mathrm{CNOT}\) 门：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.26}.png}\hspace*{\fill}}

\begin{center}图4.6.26 模拟 \(H_3\) 项（此时 \(RZ\) 门表达式为 \(2\theta_{3}\) ）
\end{center}
\sphinxAtStartPar
对于  \(\mathrm{\hat{H}}4\) 项，因为  \(\sigma{x}\) 不是对角阵，所以需要将它先对角化，然后再进行推导
\begin{equation*}
\begin{split}\begin{aligned} \mathrm{U}_{4}\left(\hat{H}_{4}, \theta_{4}\right) &=e^{-{i} \sigma_{x}^{0} \otimes \sigma_{z}^{1} \theta_{4}}=e^{-i\left(\hat{H}_{0} \sigma_{z}^{0} H_{0}\right) \otimes \sigma_{z}^{1} \theta_{4}} \\ &=H_{0} e^{-i \sigma_{\sigma}^{0} \otimes \sigma_{z}^{1} \theta_{4}} H_{0}=H(0) \text{CNOT}(0,1) R Z\left(1,2 \theta_{4}\right) C N O T(0,1) H(0) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  通过推导可以发现模拟 \(\mathrm{\hat{H}}4\) 项，需先在q0上加上Hadamard门；再以q0比特为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) ；接着在q1上加上 \(\mathrm{RZ}(2 \theta{4})\) 门；然后再以q0比特为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) 再在q0的第二个 \(\mathrm{CNOT}\)   \({(0,1)}\) ；最后再在q0上加上Hadamard门：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.27}.png}\hspace*{\fill}}

\begin{center}图4.6.27 模拟 \(H_4\) 项（此时 \(RZ\) 门表达式为 \(2\theta_{4}\) ）
\end{center}
\sphinxAtStartPar
对于 \(\mathrm{\hat{H}}_5\) 项，因为  \(\sigma{y}\) 也不是对角阵, 所以需要对它进行对角化处理，类比  \(\mathrm{\hat{H}}_4\) , 不难得出
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{U}_{5}\left(\hat{H}_{5}, \theta_{5}\right)=e^{-i \sigma_{y}^{0} \otimes \sigma_{z}^{1} \theta_{5}}=e^{-i\left(R X_{0}\left(\frac{\pi}{2}\right) \sigma_{g}^{0} R X_{0}\left(-\frac{\pi}{2}\right)\right) \otimes \sigma_{z}^{1} \theta_{5}} \\ & =R X_{0}\left(\frac{\pi}{2}\right) e^{-i \sigma_{z}^{0} \otimes \sigma_{z}^{1} \theta_{4}} R X_{0}\left(-\frac{\pi}{2}\right) \\ &=R X\left(0, \frac{\pi}{2}\right) \text{CNOT}(0,1) R Z\left(1,2 \theta_{4}\right) \text{CNOT}(0,1) R X\left(0,-\frac{\pi}{2}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  因此要想模拟 \(\mathrm{\hat{H}}_5\) 项,需先在q0上先加上 \(\text{RX}\left(\frac{\pi}{2}\right)\) 门；再以q0比特为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) ；接着在q1上加上 \(\mathrm{RZ}(2 \theta{5})\) 门；然后再以q0比特为控制比特以q1为目标比特加上 \(\mathrm{CNOT}\) 再在q0的第二个 \(\mathrm{CNOT(0,1)}\) ；最后再在q1加上 \(\text{RX}\left(-\frac{\pi}{2}\right)\) 门：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.28}.png}\hspace*{\fill}}

\begin{center}图4.6.28 模拟 \(H_5\) 项（此时 \(RZ\) 门表达式为 \(2\theta_{5}\) ）
\end{center}
\sphinxAtStartPar
  那么，最终模拟 \(\mathrm{\hat{H}}\) 的量子线路构造为：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.29}.png}\hspace*{\fill}}

\begin{center}图4.6.29 模拟H的量子线路构造
\end{center}
\sphinxAtStartPar
  可以通过QPanda来实现上述的哈密顿量模拟算法，哈密顿量模拟的python示例代码：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,}\PYG{n}{pauli}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{slices}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}     \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a general case of hamiltonian by Trotter\PYGZhy{}Suzuki}
\PYG{l+s+s1}{4.    approximation. U=exp(\PYGZhy{}iHt)=(exp(\PYGZhy{}i H1 t/n)*exp(\PYGZhy{}i H2 t/n))\PYGZca{}n}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{slices}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{for} \PYG{n}{op} \PYG{o+ow}{in} \PYG{n}{pauli}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{10.}            \PYG{n}{term} \PYG{o}{=} \PYG{n}{op}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{11.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}
\PYG{l+m+mf}{12.}                \PYG{n}{simulate\PYGZus{}one\PYGZus{}term}\PYG{p}{(}
\PYG{l+m+mf}{13.}                    \PYG{n}{qubit\PYGZus{}list}\PYG{p}{,}
\PYG{l+m+mf}{14.}                    \PYG{n}{term}\PYG{p}{,} \PYG{n}{op}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}
\PYG{l+m+mf}{15.}                    \PYG{n}{t}\PYG{o}{/}\PYG{n}{slices}
\PYG{l+m+mf}{16.}                \PYG{p}{)}
\PYG{l+m+mf}{17.}            \PYG{p}{)}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}    \PYG{k}{return} \PYG{n}{circuit}
\end{sphinxVerbatim}

\sphinxAtStartPar
  simulate\_hamiltonian接口需要传入的参数是哈密顿量相关联的一组量子比特，哈密顿量泡利算符，演化时间t和切片数。其中哈密顿量泡利算符、演化时间和切片数，分别对应特罗特公式中的H、t和n。

\sphinxAtStartPar
  simulate\_one\_term接口是对哈密顿量的一个子项进行哈密顿量模拟，传入的参数分别为一组量子比特，哈密顿量子项，哈密顿量子项对应的系数以及演化时间。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}one\PYGZus{}term}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{,} \PYG{n}{coef}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a single term of Hamilonian like }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{X0 Y1 Z2}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ with}
\PYG{l+s+s1}{4.    coefficient and time. U=exp(\PYGZhy{}it*coef*H)}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{circuit} \PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{return} \PYG{n}{circuit}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{transform}\PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{tmp\PYGZus{}qlist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{term} \PYG{o+ow}{in} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{k}{if} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{15.}            \PYG{n}{transform}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}        \PYG{k}{elif} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{17.}            \PYG{n}{transform}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}        \PYG{n}{tmp\PYGZus{}qlist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}    \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{transform}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{k}{if} \PYG{n}{size} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{25.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{26.}    \PYG{k}{elif} \PYG{n}{size} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{27.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{29.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{30.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{31.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{32.}
\PYG{l+m+mf}{33.}    \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{transform}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{34.}
\PYG{l+m+mf}{35.}    \PYG{k}{return} \PYG{n}{circuit}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{6、量子期望估计算法}

\sphinxAtStartPar
  VQE算法在制备出试验态 \(\left|\psi_{n}\right\rangle\) 后，需要开始利用量子期望估计算法来计算试验态 \(\left|\psi_{n}\right\rangle\) 在分子哈密顿量上的期望。那么，什么是量子期望估计方法呢? 所谓量子期望估计，是指对于多电子体系、Heisenberg模型 (海森堡模型) 、量子Ising模型 (易辛模型) 等体系的哈密顿量H可以展开成多个子项的和，即：
\begin{equation*}
\begin{split}H=\sum h_{\alpha}^{i} \sigma_{\alpha}^{i}+\sum h_{\alpha \beta}^{i j} \sigma_{\alpha}^{i} \sigma_{\beta}^{j}+\sum h_{\alpha \beta \gamma}^{i j k} \sigma_{\alpha}^{i} \sigma_{\beta}^{j} \sigma_{\gamma}^{k}+\ldots\end{split}
\end{equation*}
\sphinxAtStartPar
  其中， \(\mathrm{h}\) 是实数， \(\mathrm{\sigma}\) 是泡利算子（ \(\alpha ` 、 :math:\)beta` 、 \(\gamma\) 可以在 \(\mathrm{X}/ \mathrm{Y}/ \mathrm{Z}/\mathrm{I}\) 中进行取值），而  \({i}\) 、 \({i}\)mathrm\{j\}` 则表示哈密顿量子项所作用的子空间。

\sphinxAtStartPar
  由于可观测量是线性的，因此在利用下式计算体系的平均能量时：
\begin{equation*}
\begin{split}E=\left\langle\psi^{*}|H| \psi\right\rangle\left(\psi^{*} \text { 与 } \psi\right. \text { 是正交归一的) }\end{split}
\end{equation*}
\sphinxAtStartPar
  等式右边也可以展开成这种形式：
\begin{equation*}
\begin{split}E=\sum h_{\alpha}^{i} \left\langle \psi^{*}\left|\sigma_{a}^{i}\right| \psi\right\rangle +\sum h_{\alpha \beta}^{i j}\left\langle\psi^{*}\left|\sigma_{a}^{i} \sigma_{\alpha \beta}^{i j}\right| \psi\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  由此可知，只须先对每个子项求期望，然后对各个期望求和，就能得到体系的平均能量 \(E\) 。

\sphinxAtStartPar
  在VQE算法中，每个子项期望的测量是在量子处理器上进行的，而经典处理器则负责对各个期望进行求和。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.30}.png}\hspace*{\fill}}

\begin{center}图4.6.30 各个期望求和
\end{center}
\sphinxAtStartPar
  假设某一个体系的哈密顿量为 \(\hat{H}\) ，它最终可以展开成这种形式：
\begin{equation*}
\begin{split}\hat{H}_{P}=\hat{H}_{1}+\hat{H}_{2}+\hat{H}_{3}=I^{\otimes 2}+\sigma_{z}^{0} \otimes \sigma_{z}^{1}+\sigma_{x}^{0} \otimes \sigma_{y}^{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  在该式中，所有子项系数  \(h\) 均是1。并假设所制备出的试验态为这种形式：
\begin{equation*}
\begin{split}|\psi\rangle=a|00\rangle +b| 01\rangle+c|10\rangle +d| 11\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  其中， \(a^2\) 、 \(b^2\) 、 \(c^2\) 、 \(d^2\) 分别是指测量试验态时，坍塌到 \(|00 \rangle\) 、 \(|01\rangle\) 、 \(|10\rangle\) 、 \(|11\rangle\) 的概率 \(P_s\) ，将哈密顿量的各个子项 \(\mathrm{\hat{H}}_1\) 、 \(\mathrm{\hat{H}}_2\) 、 \(\mathrm{\hat{H}}_3\) 分别作用于试验态上，可以依次得到期望 \(\mathrm{E}(1)\) 、 \(\mathrm{E}(2)\) 、 \(\mathrm{E}(3)\) 。
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{E}(1)=\left\langle\psi^{*}\left|\mathrm{\hat{H}}_{1}\right| \psi\right\rangle \\ &\mathrm{E}(2)=\left\langle\psi^{*}\left|\mathrm{\hat{H}}_{2}\right| \psi\right\rangle \\ &\mathrm{E}(3)=\left\langle\psi^{*}\left|\mathrm{\hat{H}}_{3}\right| \psi\right\rangle \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  下面将以 \(\mathrm{E}(1)\) 、 \(\mathrm{E}(2)\) 、 \(\mathrm{E}(3)\) 为例，详细介绍VQE算法是如何构造线路来测量各项期望进而计算出平均能量 \(E\) 的。

\sphinxAtStartPar
  对于期望 \(\mathrm{E}(1)\) ，系数  \(h\) 就是期望，无须构造线路测量。
\begin{equation*}
\begin{split}\mathrm{E}(1)=\left\langle\psi\left|\mathrm{I}^{\otimes 2}\right| \psi\right\rangle=h=1\end{split}
\end{equation*}
\sphinxAtStartPar
  对于期望 \(\mathrm{E}(2)\) ，其哈密顿量为
\begin{equation*}
\begin{split}\sigma_{z}^{0} \otimes \sigma_{z}^{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  由于测量操作是在 \(\sigma_{z}\) 上（以 \(\sigma_{z}\) 的特征向量为基向量所构成的子空间）进行的，所以只需要在0号量子比特和1号量子比特上加上测量门即可，然后将测量结果传递给经典处理器求和，如图4.6.31所示。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1023}.png}\hspace*{\fill}}

\begin{center}图4.6.31 测量过程
\end{center}
\sphinxAtStartPar
具体测量过程是这样的，因为两个 \(\sigma_{z}\) 张乘所形成的矩阵是一个对角阵:
\begin{equation*}
\begin{split}\sigma_{z}^{0} \otimes \sigma_{z}^{1}=\left[\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & -1 & 0 & 0 \\ 0 & 0 & -1 & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  根据线性代数知识可知其特征值就是对角线上的元素  \(1\) 、 \(-1\)  、 \(-1\) 、 \(1\) , 与特征值相对应的特征向量正好就是基底S:  \(|00\rangle\) 、 \(|01\rangle\) 、 \(|10\rangle\)、 \(|11\rangle\) , 如果仔细观察的话，可以发现，量子态为  \(|00\rangle\) 、 \(|11\rangle\) 时，其中1的个数分别为 0 和2，均为偶数，特征值均为  \(+1\) ，而量子态为  \(|01\rangle\) 、 \(|10\rangle\) 时，其中 1 的个数均为 1 ，为奇数，特征值均为  \(-1\) 。

\sphinxAtStartPar
  事实上，对于任何作为基底的量子态的特征值都有这样“奇负偶正”的规律。这样的话，一将测量门加到相应的量子线路，试验态就会以一定概率坍塌到不同的量子态  \(s\) , 接着确定量子态  \(s\) 中1的个数  \(N_s\) 就行了，然后通过下式就可以计算出期望 \(\mathrm{E}(i)\) 。
\begin{equation*}
\begin{split}E(i)=h_{\alpha \beta ..}^{i j ..} \sum_{\mid 00 . .\rangle}^{\mid 11 ..\rangle}(-1)^{N_{s}} P_{s}\end{split}
\end{equation*}
\sphinxAtStartPar
  即，如果量子态中有奇数个 1 ，其概率  \(P\) 取负值; 如果量子态中有奇数个1，其概率  \(P\) 取正值，然后累加起来，再乘以系数  \(h\) 就得到了期望。
\begin{equation*}
\begin{split}E(2)=\left\langle\psi\left|\sigma_{z}^{0} \otimes \sigma_{z}^{1}\right| \psi\rangle=a^{2}-b^{2}-c^{2}+d^{2}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
对于 \(\mathrm{E}(3)\) 项，其哈密顿量:
\begin{equation*}
\begin{split}\sigma_{x}^{0} \otimes \sigma_{y}^{1}\end{split}
\end{equation*}
\sphinxAtStartPar
  此时，不能直接测量。这是因为对于试验态中的每一个基底(如  \(|01\rangle\) ),它们均是单位阵和  \(\sigma_{Z}\) 的特征向量，但不是  \(\sigma_{x}\) 和  \(\sigma_{y}\) 的特征向量。 根据线性代数知识，需要分别对  \(\sigma_{x}\) 和  \(\sigma_{y}\) 进行换基操作，也就是让试验态再演化一次，而：
\begin{equation*}
\begin{split}\begin{aligned} &\sigma_{x}=H \times \sigma_{z} \times H \\ &\sigma_{y}=R X\left(\frac{\pi}{2}\right) \times \sigma_{z} \times R X\left(-\frac{\pi}{2}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  所以在测量前，需要在 \(q 0\) 号量子比特上添上  \(H\) 门、在  \(q 1\) 号量子比特上添上  \(RX\left(\frac{\pi}{2}\right)\) 门，如图4.6.32所示。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1045}.png}\hspace*{\fill}}

\begin{center}图4.6.32 测量操作
\end{center}
\sphinxAtStartPar
  此时，试验态  \(|\psi\rangle\) 演化为  \(\left|\psi^{\prime}\right\rangle\) 。
\begin{equation*}
\begin{split}\left.\left.\left|\psi^{\prime}\right\rangle=A|00\rangle +B| 01\right\rangle+C|10\rangle +D| 11\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  之后再利用“奇负偶正”这一规律进行测量， 不难得到:
\begin{equation*}
\begin{split}E(3)=\left\langle\psi^{*}\left|\sigma_{x}^{0} \otimes \sigma_{y}^{1}\right| \psi\right\rangle=\left\langle\psi^{'*}\left|\sigma_{z}^{0} \otimes \sigma_{z}^{1}\right| \psi^{\prime}\right\rangle=A^{2}-B^{2}-C^{2}+D^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  在CPU上对这三个期望求和，就得到了平均能量  \(\mathrm{E}\) 。
\begin{equation*}
\begin{split}E=E(1)+E(2)+E(3)\end{split}
\end{equation*}
\sphinxAtStartPar
  同样，也可以利用QPanda来实现量子期望估计算法，在VQE算法演示中， 需要向优化器注册一个计算损失值的函数。

\sphinxAtStartPar
  这里定义损失值为计算体系哈密顿量在试验态下的期望值，定义损失函数 loss\_func，传入的参数为待优化的参数列表，量子比特个数，电子个数，体系哈密顿量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{loss\PYGZus{}func}\PYG{p}{(}\PYG{n}{para\PYGZus{}list}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{Hamiltonian}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    \PYGZlt{}𝜓\PYGZca{}∗|𝐻|𝜓\PYGZgt{}, Calculation system expectation of Hamiltonian in experimental state.}
\PYG{l+s+s1}{4.    para\PYGZus{}list: parameters to be optimized}
\PYG{l+s+s1}{5.    qubit\PYGZus{}number: qubit number}
\PYG{l+s+s1}{6.    electron\PYGZus{}number: electron number}
\PYG{l+s+s1}{7.    Hamiltonian: System Hamiltonian}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{9.}    \PYG{n}{fermion\PYGZus{}cc} \PYG{o}{=}\PYG{n}{get\PYGZus{}ccsd}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{para\PYGZus{}list}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n}{pauli\PYGZus{}cc} \PYG{o}{=} \PYG{n}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{ucc} \PYG{o}{=} \PYG{n}{cc\PYGZus{}to\PYGZus{}ucc\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{n}{component} \PYG{o+ow}{in} \PYG{n}{Hamiltonian}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{n}{expectation}\PYG{o}{+}\PYG{o}{=}\PYG{n}{get\PYGZus{}expectation}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{n}{component}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{expectation}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{k}{return} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{expectation}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  get\_expectation接口用来计算体系哈密顿量的子项在试验态下的期望。这个接口需要传入的参数为量子比特数，电子个数，通过UCC模型构造的哈密顿量，体系哈密顿量的一个子项。

\sphinxAtStartPar
  程序大体流程是首先创建一个虚拟机，从虚拟机申请量子比特，接着构建量子线路，先制备初态，再构造UCC哈密顿量的模拟线路，并在测量前对体系哈密顿量子项进行换基操作，最后进行测量，并根据测量结果通过奇负偶正规则，计算当前体系哈密顿量子项的期望。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}expectation}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{n}{component}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}     \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    get expectation of one hamiltonian.}
\PYG{l+s+s1}{4.    n\PYGZus{}qubit: qubit number}
\PYG{l+s+s1}{5.    n\PYGZus{}en: electron number}
\PYG{l+s+s1}{6.    ucc: unitary coupled cluster operator}
\PYG{l+s+s1}{7.    component: paulioperator and coefficient,e.g. (}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X0 Y1 Z2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,0.2)}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{machine}\PYG{o}{=}\PYG{n}{init\PYGZus{}quantum\PYGZus{}machine}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{q} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{prog}\PYG{o}{=}\PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{prepareInitialState}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{simulate\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{18.}        \PYG{k}{if} \PYG{n}{j}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{19.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{20.}        \PYG{k}{elif} \PYG{n}{j}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{21.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{directly\PYGZus{}run}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{n}{result}\PYG{o}{=}\PYG{n}{machine}\PYG{o}{.}\PYG{n}{get\PYGZus{}prob\PYGZus{}dict}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{select\PYGZus{}max}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{25.}    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qFree\PYGZus{}all}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{28.}    \PYG{c+c1}{\PYGZsh{}奇负偶正}
\PYG{l+m+mf}{29.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{result}\PYG{p}{:}
\PYG{l+m+mf}{30.}        \PYG{k}{if} \PYG{n}{parity\PYGZus{}check}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{31.}            \PYG{n}{expectation}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{32.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{33.}            \PYG{n}{expectation}\PYG{o}{+}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{34.}    \PYG{k}{return} \PYG{n}{expectation}\PYG{o}{*}\PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
  其中，奇偶校验代码如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{parity\PYGZus{}check}\PYG{p}{(}\PYG{n}{number}\PYG{p}{,} \PYG{n}{terms}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{check}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{3.}    \PYG{n}{number}\PYG{o}{=}\PYG{n}{number}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{terms}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{k}{if} \PYG{n}{number}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{7.}            \PYG{n}{check}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{k}{return} \PYG{n}{check}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{7、利用VQE算法寻找基态能量}

\sphinxAtStartPar
  以氢分子基态的寻找为例，介绍VQE算法寻找基态能量的整个流程。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.33}.png}\hspace*{\fill}}

\begin{center}图4.6.33 量子处理器与经典处理器的VQE工作流程图
\end{center}
\sphinxAtStartPar
  首先，进行初始化，即在q0上和q1上分别加上  \(NOT\) 门，得到了氢分子的一个hatree\sphinxhyphen{}fock态 \(|0011\rangle\) 。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.34}.png}\hspace*{\fill}}

\begin{center}图4.6.34 初始化
\end{center}
\sphinxAtStartPar
  然后将hatree\sphinxhyphen{}fock态制备成试验态  \(|\psi\rangle\) ，演化经过的量子线路是通过  \(J-W\) 变换和渐进近似定理将费米子哈密顿量 \(H_U\) 映射到量子比特上构造出来的。 但需要注意的是，由于利用了渐进近似定理将系数 \(\vec{h}\) 分成了 3 个 \(\vec{\theta}\) ，所以需要循环演化hatree\sphinxhyphen{}fock态三次，才能制备出试验态 \(|\psi\rangle\) 。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.35}.png}\hspace*{\fill}}

\begin{center}图4.6.35 制备实验态
\end{center}
\sphinxAtStartPar
  现在，以第一个酉算子为例，介绍氢分子试验态的制备过程。类比之前哈密顿量模拟时的推导过程，可以得到以下推导:
\begin{equation*}
\begin{split}U\left(\sigma_{y}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2} \otimes \sigma_{x}^{3}, \theta\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}=R X\left(0, \frac{\pi}{2}\right) H(3) U\left(\sigma_{z}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2} \otimes \sigma_{z}^{3}, \theta\right) H(3) R X\left(0,-\frac{\pi}{2}\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}=R X\left(0, \frac{\pi}{2}\right) H(3) \text{CNOT}(0,3) \text{CNOT}(1,3) \text{CNOT}(2,3) R Z(3,2 \theta) \text{CNOT}(2,3)\\ \text{CNOT}(1,3) \text{CNOT}(0,3) H(3) R X(0,\left.\quad-\frac{\pi}{2}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  根据推导结果，构造出的量子线路为：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.36}.png}\hspace*{\fill}}

\begin{center}图4.6.36 构造出的量子线路
\end{center}
\sphinxAtStartPar
  再将剩下的哈密顿量子项也映射到量子比特，将费米子哈密顿量Hu模拟出来，然后利用这条线路对hatree\sphinxhyphen{}fock态循环演化三次，就制备出了试验态 \(|\psi\rangle\) 。

\sphinxAtStartPar
  下面，开始对试验态 \(|\psi\rangle\) 进行测量，而测量线路则是通过J\sphinxhyphen{}W变换等方法 将 \(Psi4\) 所计算出来的氢分子哈密顿量 \(H_P\) 映射到量子比特构造出来。

\sphinxAtStartPar
  在测量期望时，所运用的方法是量子期望估计算法，即首先分别构造整个氢分子哈密顿量 \(H_P\) 的15个子项的测量线路，测得各个子项的期望 \(E(i)\) 。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.37}.png}\hspace*{\fill}}

\begin{center}图4.6.37 量子期望估计算法
\end{center}
\sphinxAtStartPar
  将各个子项期望测量线路展开，即可得到各个子项期望 \(E(i)\) 的测量线路，如图4.6.38所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.38}.png}\hspace*{\fill}}

\begin{center}图4.6.38 测量线路
\end{center}
\sphinxAtStartPar
  接着，量子处理器将 \(E(i)\) 依次传给经典处理器求和，就得到了氢分子在该试验态下的平均能量 \(E(n)\) 。
\begin{equation*}
\begin{split}E_{n}=\sum_{i=1}^{15} E(i)\end{split}
\end{equation*}
\sphinxAtStartPar
  最后， \(\mathrm{CPU}\) 会将求和得到的平均能量En传给优化器，优化器会判断 \(E_n - E_{n-1}\) 是否小于阈值 \(L\) ，是的话就返回 \(En\) 的值，作为该键长下的基态能量，否的话优化器会利用梯度相关算法或无关算法优化参数 \(\vec{t}_{n}\) ，然后传给量子处理器，继续演化和测量，直至找到氢分子在该键隹下的基态能量。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.39}.png}\hspace*{\fill}}

\begin{center}图4.6.39 优化过程
\end{center}

\subsection{4.6.6 综合示例}
\label{\detokenize{rst/4.6VQE_u7b97_u6cd5:id6}}
\sphinxAtStartPar
\sphinxstylestrong{使用梯度下降优化器进行演示} 

\sphinxAtStartPar
  首先，开始准备工作，导入所需要的库：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k+kn}{from} \PYG{n+nn}{psi4\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{3.}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{l+m+mf}{4.}\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{partial}
\PYG{l+m+mf}{5.}\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{l+m+mf}{6.}\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\sphinxAtStartPar
  使用get\_ccsd\_n\_term接口的作用是返回构造CCSD模型需要用到的参数个数：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    coupled cluster single and double model.}
\PYG{l+s+s1}{4.    e.g. 4 qubits, 2 electrons}
\PYG{l+s+s1}{5.    then 0 and 1 are occupied,just consider 0\PYGZhy{}\PYGZgt{}2,0\PYGZhy{}\PYGZgt{}3,1\PYGZhy{}\PYGZgt{}2,1\PYGZhy{}\PYGZgt{}3,01\PYGZhy{}\PYGZgt{}23}
\PYG{l+s+s1}{6.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{\PYGZgt{}}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}} \PYG{n}{en}\PYG{p}{)} \PYG{o}{*} \PYG{n}{en} \PYG{o}{+} \PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}} \PYG{n}{en}\PYG{p}{)}\PYG{o}{*} \PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}}\PYG{n}{en} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{en} \PYG{o}{*} \PYG{p}{(}\PYG{n}{en} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  使用get\_ccsd\_var接口则是用来构造可变参数对应的CCSD模型哈密顿量，代码实

\sphinxAtStartPar
  现跟get\_ccsd接口一样，只不过这里用到的费米子算符类是可变费米子算符类获取CCSD模型的参数个数构造可变参数的CCSD模型的哈密顿量：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ccsd\PYGZus{}var}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{,} \PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    get Coupled cluster single and double model with variational parameters.}
\PYG{l+s+s1}{4.    e.g. 4 qubits, 2 electrons}
\PYG{l+s+s1}{5.    then 0 and 1 are occupied,just consider 0\PYGZhy{}\PYGZgt{}2,0\PYGZhy{}\PYGZgt{}3,1\PYGZhy{}\PYGZgt{}2,1\PYGZhy{}\PYGZgt{}3,01\PYGZhy{}\PYGZgt{}23.}
\PYG{l+s+s1}{6.    returned FermionOperator like this:}
\PYG{l+s+s1}{7.    }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{2+ 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[0]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[1]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{2+ 1}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[2]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 1}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[3]\PYGZcb{},}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 2+ 1 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[4]\PYGZcb{} \PYGZcb{}}
\PYG{l+s+s1}{9.}
\PYG{l+s+s1}{10.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{11.}    \PYG{k}{if} \PYG{n}{en} \PYG{o}{\PYGZgt{}} \PYG{n}{qn}\PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{13.}    \PYG{k}{if} \PYG{n}{en} \PYG{o}{==} \PYG{n}{qn}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{k}{return} \PYG{n}{VarFermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{k}{if} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)} \PYG{o}{!=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{17.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}    \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{20.}    \PYG{n}{var\PYGZus{}fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{VarFermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{22.}        \PYG{k}{for} \PYG{n}{ex} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{,} \PYG{n}{qn}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{23.}            \PYG{n}{var\PYGZus{}fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{VarFermionOperator}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{24.}            \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{25.}
\PYG{l+m+mf}{26.}    \PYG{k}{return} \PYG{n}{var\PYGZus{}fermion\PYGZus{}op}
\PYG{l+m+mf}{27.}
\PYG{l+m+mf}{28.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{29.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{30.}            \PYG{k}{for} \PYG{n}{ex1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{,} \PYG{n}{qn}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{31.}                \PYG{k}{for} \PYG{n}{ex2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ex1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qn}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{32.}                    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{VarFermionOperator}\PYG{p}{(}
\PYG{l+m+mf}{33.}                        \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex2}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex1}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{34.}                        \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}
\PYG{l+m+mf}{35.}                    \PYG{p}{)}
\PYG{l+m+mf}{36.}                    \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{37.}
\PYG{l+m+mf}{38.}    \PYG{k}{return} \PYG{n}{fermion\PYGZus{}op}
\end{sphinxVerbatim}

\sphinxAtStartPar
  get\_fermion\_jordan\_wigner接口则是将费米子哈密顿量的子项转换成泡利哈密顿量：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}item}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fermion\PYGZus{}item}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{op\PYGZus{}qubit} \PYG{o}{=} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{6.}        \PYG{n}{op\PYGZus{}str} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{7.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}            \PYG{n}{op\PYGZus{}str} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}        \PYG{n}{op\PYGZus{}str1} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{11.}        \PYG{n}{op\PYGZus{}str2} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}        \PYG{n}{pauli\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{14.}        \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}        \PYG{k}{if} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
\PYG{l+m+mf}{17.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{18.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{19.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}        \PYG{n}{pauli} \PYG{o}{*}\PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}map}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
  JordanWignerTransformVar接口的作用是将可变费米子哈密顿量转换成可变泡利哈密顿量：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{JordanWignerTransformVar}\PYG{p}{(}\PYG{n}{var\PYGZus{}fermion\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{data} \PYG{o}{=} \PYG{n}{var\PYGZus{}fermion\PYGZus{}op}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{n}{var\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{one\PYGZus{}pauli} \PYG{o}{=} \PYG{n}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{6.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{one\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}            \PYG{n}{var\PYGZus{}pauli} \PYG{o}{+}\PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{complex\PYGZus{}var}\PYG{p}{(}
\PYG{l+m+mf}{8.}                \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}
\PYG{l+m+mf}{9.}                \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{o}{+}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{n}{var\PYGZus{}pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
  cc\_to\_ucc\_hamiltonian\_var接口的作用是CC模型对应的哈密顿量转成UCC模型对应的哈密顿量：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{cc\PYGZus{}to\PYGZus{}ucc\PYGZus{}hamiltonian\PYGZus{}var}\PYG{p}{(}\PYG{n}{cc\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    generate Hamiltonian form of unitary coupled cluster based on coupled cluster,H=1j*(T\PYGZhy{}dagger(T)),}
\PYG{l+s+s1}{4.    then exp(\PYGZhy{}jHt)=exp(T\PYGZhy{}dagger(T))}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{cc\PYGZus{}op}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}        \PYG{n}{pauli} \PYG{o}{+}\PYG{o}{=} \PYG{n}{VarPauliOperator}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{complex\PYGZus{}var}\PYG{p}{(}\PYG{n}{var}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{var}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
  prepareInitialState制备初态

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{prepareInitialState}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    prepare initial state.}
\PYG{l+s+s1}{4.    qlist: qubit list}
\PYG{l+s+s1}{5.    en: electron number}
\PYG{l+s+s1}{6.    return a QCircuit}
\PYG{l+s+s1}{7.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{8.}    \PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{en}\PYG{p}{:}
\PYG{l+m+mf}{10.}        \PYG{k}{return} \PYG{n}{circuit}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{13.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{n}{circuit}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  simulate\_one\_term\_var是构造哈密顿量子项的模拟线路：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}one\PYGZus{}term\PYGZus{}var}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{,} \PYG{n}{coef}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a single term of Hamilonian like }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{X0 Y1 Z2}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ with}
\PYG{l+s+s1}{4.    coefficient and time. U=exp(\PYGZhy{}it*coef*H)}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{vqc} \PYG{o}{=} \PYG{n}{VariationalQuantumCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{return} \PYG{n}{vqc}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{tmp\PYGZus{}qlist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{12.}    \PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{term} \PYG{o+ow}{in} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{13.}        \PYG{k}{if} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{14.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{15.}        \PYG{k}{elif} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{16.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}        \PYG{n}{tmp\PYGZus{}qlist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{19.}
\PYG{l+m+mf}{20.}    \PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{k}{if} \PYG{n}{size} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{22.}        \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{VariationalQuantumGate\PYGZus{}RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{23.}    \PYG{k}{elif} \PYG{n}{size} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{24.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{25.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{26.}        \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{VariationalQuantumGate\PYGZus{}RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{27.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{29.}
\PYG{l+m+mf}{30.}    \PYG{c+c1}{\PYGZsh{} dagger}
\PYG{l+m+mf}{31.}    \PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{term} \PYG{o+ow}{in} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{32.}        \PYG{k}{if} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{33.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{34.}        \PYG{k}{elif} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{35.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{36.}
\PYG{l+m+mf}{37.}    \PYG{k}{return} \PYG{n}{vqc}
\end{sphinxVerbatim}

\sphinxAtStartPar
  simulate\_hamiltonian\_var接口作用是构造哈密顿量的模拟线路：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}hamiltonian\PYGZus{}var}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,}\PYG{n}{var\PYGZus{}pauli}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{slices}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a general case of hamiltonian by Trotter\PYGZhy{}Suzuki}
\PYG{l+s+s1}{4.    approximation. U=exp(\PYGZhy{}iHt)=(exp(\PYGZhy{}i H1 t/n)*exp(\PYGZhy{}i H2 t/n))\PYGZca{}n}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{vqc} \PYG{o}{=} \PYG{n}{VariationalQuantumCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{slices}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{var\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{10.}            \PYG{n}{term} \PYG{o}{=} \PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{11.}            \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{simulate\PYGZus{}one\PYGZus{}term\PYGZus{}var}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,} \PYG{n}{term}\PYG{p}{,} \PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{t}\PYG{o}{/}\PYG{n}{slices}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{k}{return} \PYG{n}{vqc}
\end{sphinxVerbatim}

\sphinxAtStartPar
  梯度下降优化算法的主体接口GradientDescent，该接口接受的参数是体系哈密顿量，轨道个数，电子个数，迭代次数。

\sphinxAtStartPar
  具体看一下这个接口的实现，首先初始化一组var类型的待优化参数，利用ccsd模型构造的可变费米子哈密顿量，通过JW变换将可变费米子哈密顿量转换为可变泡利哈密顿量，接着将CC转化成UCC，然后创建一个量子虚拟机，并向量子虚拟机申请指定数量的量子比特，再接着构建可变量子线路。首先制备初态，然后构造哈密顿量模拟线路。

\sphinxAtStartPar
  接着通过VQNet的qop操作构造损失函数，然后创建一个基于动量的梯度下降优化器，迭代执行优化器，最后返回优化器优化的最低能量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{GradientDescent}\PYG{p}{(}\PYG{n}{mol\PYGZus{}pauli}\PYG{p}{,} \PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{,} \PYG{n}{iters}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{n\PYGZus{}para} \PYG{o}{=} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}electron}\PYG{p}{)}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{para\PYGZus{}vec} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{5.}    \PYG{n}{var\PYGZus{}para} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{6.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{n}{var\PYGZus{}para}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{var}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{8.}        \PYG{n}{para\PYGZus{}vec}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{fermion\PYGZus{}cc} \PYG{o}{=} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}var}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{,} \PYG{n}{var\PYGZus{}para}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{pauli\PYGZus{}cc} \PYG{o}{=} \PYG{n}{JordanWignerTransformVar}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{ucc} \PYG{o}{=} \PYG{n}{cc\PYGZus{}to\PYGZus{}ucc\PYGZus{}hamiltonian\PYGZus{}var}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{machine}\PYG{o}{=}\PYG{n}{init\PYGZus{}quantum\PYGZus{}machine}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{qlist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{n}{vqc} \PYG{o}{=} \PYG{n}{VariationalQuantumCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{18.}    \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{prepareInitialState}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{19.}    \PYG{n}{vqc}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{simulate\PYGZus{}hamiltonian\PYGZus{}var}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}    \PYG{n}{loss} \PYG{o}{=} \PYG{n}{qop}\PYG{p}{(}\PYG{n}{vqc}\PYG{p}{,} \PYG{n}{mol\PYGZus{}pauli}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{)}
\PYG{l+m+mf}{22.}    \PYG{n}{gd\PYGZus{}optimizer} \PYG{o}{=} \PYG{n}{MomentumOptimizer}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{(}\PYG{n}{loss}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)}
\PYG{l+m+mf}{23.}    \PYG{n}{leaves} \PYG{o}{=} \PYG{n}{gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{get\PYGZus{}variables}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{24.}
\PYG{l+m+mf}{25.}    \PYG{n}{min\PYGZus{}energy}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{26.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iters}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{27.}        \PYG{n}{gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{leaves}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{28.}        \PYG{n}{loss\PYGZus{}value} \PYG{o}{=} \PYG{n}{gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{get\PYGZus{}loss}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{29.}
\PYG{l+m+mf}{30.}        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{loss\PYGZus{}value}\PYG{p}{)}
\PYG{l+m+mf}{31.}        \PYG{k}{if} \PYG{n}{loss\PYGZus{}value} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}energy}\PYG{p}{:}
\PYG{l+m+mf}{32.}            \PYG{n}{min\PYGZus{}energy} \PYG{o}{=} \PYG{n}{loss\PYGZus{}value}
\PYG{l+m+mf}{33.}            \PYG{k}{for} \PYG{n}{m}\PYG{p}{,}\PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{var\PYGZus{}para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{34.}                \PYG{n}{para\PYGZus{}vec}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}    \PYG{k}{return} \PYG{n}{min\PYGZus{}energy}
\end{sphinxVerbatim}

\sphinxAtStartPar
  获取原子对应的电子数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{getAtomElectronNum}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{atom\PYGZus{}electron\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{3.}        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{He}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Li}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Be}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ne}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}
\PYG{l+m+mf}{4.}        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Na}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Al}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Si}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{18}
\PYG{l+m+mf}{5.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{k}{if} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{atom\PYGZus{}electron\PYGZus{}map}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}contains\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}        \PYG{k}{return} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{k}{return} \PYG{n}{atom\PYGZus{}electron\PYGZus{}map}\PYG{p}{[}\PYG{n}{atom}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
  最后，这是该示例对应的主函数，首先构造一组不同距离下的氢分子模型，然后计算每个氢分子模型对应的基态能量，最后将计算的结果绘制成曲线图。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{distances} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mf}{0.1} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mf}{3.}    \PYG{n}{molecule} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H 0 0 0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{H 0 0 }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}    \PYG{n}{molecules} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{6.}    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{distances}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{n}{molecules}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{chemistry\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{10.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mol}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mf}{11.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{multiplicity}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{l+m+mf}{12.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{l+m+mf}{13.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sto\PYGZhy{}3g}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mf}{14.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{n}{energies} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{distances}\PYG{p}{:}
\PYG{l+m+mf}{19.}        \PYG{n}{mol} \PYG{o}{=} \PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}        \PYG{n}{chemistry\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mol}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{l+m+mf}{22.}        \PYG{n}{data} \PYG{o}{=} \PYG{n}{run\PYGZus{}psi4}\PYG{p}{(}\PYG{n}{chemistry\PYGZus{}dict}\PYG{p}{)}
\PYG{l+m+mf}{23.}        \PYG{c+c1}{\PYGZsh{}get molecule electron number}
\PYG{l+m+mf}{24.}        \PYG{n}{n\PYGZus{}electron} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{25.}        \PYG{n}{mol\PYGZus{}splits} \PYG{o}{=} \PYG{n}{mol}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{26.}        \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{27.}        \PYG{k}{while} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mol\PYGZus{}splits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{n}{n\PYGZus{}electron} \PYG{o}{+}\PYG{o}{=} \PYG{n}{getAtomElectronNum}\PYG{p}{(}\PYG{n}{mol\PYGZus{}splits}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{29.}            \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{l+m+mf}{30.}
\PYG{l+m+mf}{31.}        \PYG{n}{fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{parsePsi4DataToFermion}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{32.}        \PYG{n}{pauli\PYGZus{}op} \PYG{o}{=} \PYG{n}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}op}\PYG{p}{)}
\PYG{l+m+mf}{33.}
\PYG{l+m+mf}{34.}        \PYG{n}{n\PYGZus{}qubit} \PYG{o}{=} \PYG{n}{pauli\PYGZus{}op}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}        \PYG{n}{energies}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{GradientDescent}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}op}\PYG{p}{,} \PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}electron}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{37.}
\PYG{l+m+mf}{38.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{distances} \PYG{p}{,} \PYG{n}{energies}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{39.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{distance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{40.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{41.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VQE PLOT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{42.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  图4.6.40所示就是对应的输出结果，是氢分子在不同距离下对应的基态能量：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.6.40}.png}\hspace*{\fill}}

\begin{center}图4.6.40 氢分子在不同距离下对应的基态能量
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{参考文献} 

\sphinxAtStartPar
{[}1{]} 图片引自论文《Giant Intermolecular Decay and Fragmentation of Clusters》

\sphinxAtStartPar
{[}2{]} 图片引自论文《Interatomic and intermolecular Coulombic decay: the coming of age story》

\sphinxAtStartPar
{[}3{]} 图片引自论文《Dynamics of a\sphinxhyphen{}synuclein aggregation and inhibition of pore\sphinxhyphen{}like oligomer development by b\sphinxhyphen{}synuclein》

\sphinxAtStartPar
{[}4{]} 图片引自论文《A variational eigenvalue solver on a quantum processor》

\sphinxstepscope


\section{4.7 Shor分解算法}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:shor}}\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5::doc}}
\sphinxAtStartPar
  Shor算法，又叫质因数分解算法，是以数学家Peter·Shor命名的。1994年，Shor针对“给定一个整数 \(N\) ，找出它的质因数”这道题，发明了破解RSA加密的量子算法。在一个量子计算机上面，要分解整数 \(N\) ，Shor算法的运作需要多项式时间（时间是 \(\log N\) 的某个多项式这么长， \(\log N\) 在这里的意义是输入的文件长度）。更精确的说，这个算法花费 \(\mathrm{O}((\log N)^3)\) 的时间，展示出质因数分解问题可以使用量子计算机以多项式时间解出，因此在复杂度类BQP里面。这比起传统已知最快的因数分解算法:普通数域筛选法，其花费次指数时间 – 大约 \(\mathrm{O}\left(e^{1.92(\log N)^{1 / 3}(\log \log N) ^{2 / 3}}\right)\) ，还要快了一个指数的差异。


\subsection{4.7.1 加密与解密}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:id1}}
\sphinxAtStartPar
  自古以来，加密和解密都伴随着人类的发展。中国军事谋略中也常听到知己知彼，百战不殆的说法；在军事上，信息的安全保密被认为是取得胜利的关键因素；在生活中，也经常可以看到使用智慧找到解开密码的方法（方法就是密码学里的密钥），从而解开那些千奇百怪的密文。

\sphinxAtStartPar
  密码学，主要分为古典密码学和现代密码学。对于计算机时代，主要讨论现代加密方式，就是基于二进制编码信息的现代密码学。

\sphinxAtStartPar
\sphinxstylestrong{对称加密（symmetric encryption）}

\sphinxAtStartPar
  采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单钥加密。通俗的说，就是将明文（原本的信息）通过某种方式打乱，使得加密后的信息与原文不相同，但是这种打乱方式有一定的规律，使用密钥进行加密。

\sphinxAtStartPar
  所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令；算法是一组规则，规定如何进行加密和解密。

\sphinxAtStartPar
  例如：Alice要给Bob发一段信息，需要用密钥给信息加密，而Bob接收信息时候需要利用相同的密钥，才可以解密信息。如图4.7.1：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.1}.png}\hspace*{\fill}}

\begin{center}图4.7.1 对称加密
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{非对称加密（Asymmetric encryptio）}

\sphinxAtStartPar
  非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。如图4.7.2所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.2}.png}\hspace*{\fill}}

\begin{center}图4.7.2 非对称加密
\end{center}

\subsection{4.7.2 RSA加密算法}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:rsa}}
\sphinxAtStartPar
  RSA加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。该算法是著名的非对称加密算法，它是数论与计算机科学相结合产物。目前，很多加密方式都采用这个原理，而Shor算法所威胁的正是RSA的加密方式.

\sphinxAtStartPar
  RSA是Internet上的标准加密算法。该方法是公知的，但非常难以破解。其核心是它使用两个密钥进行加密，公钥是公开的，客户端使用它来加密随机会话密钥；截获加密密钥的任何人都必须使用第二个密钥（私钥）对其进行解密；否则，得到的信息是没有任何含义。而会话密钥解密后，服务器使用它以更快的算法加密和解密更多消息。因此，只要保证私钥安全，通信就是安全的。

\sphinxAtStartPar
  实际上，RSA算法，其核心的思想并不困难，它使用的是，两个质数相乘容易，但是反过来分解成两个质数相乘却非常困难的规则来构建。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.3}.png}\hspace*{\fill}}

\begin{center}图4.7.3 数字相乘与数字分解
\end{center}
\sphinxAtStartPar
  例如图4.7.3，求这串数字相乘，对于经典计算机来说，非常的简单。但是如果将这串数字分解为两个质数相乘，就非常困难。

\sphinxAtStartPar
\sphinxstylestrong{RSA算法规则}

\sphinxAtStartPar
  首先要使用概率算法来验证随机产生的大的整数是否是质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。

\sphinxAtStartPar
  首先，生成两个大的质数  \(\mathrm{p}\) 和  \(\mathrm{q}\) ; 然后计算  \(\mathrm{n}=\mathrm{p} \times \mathrm{q}\) ， 以及  \(\varphi=(p-1) \times(q-1)\) ; 再选择一个随机数 \(1<e<\varphi\) , 那么， \(\text{gcd}(e, \varphi)=1\) ; 最后计算唯一的整数  \(1<d<\varphi\) , 那么: \(e \times d=1(\bmod \varphi)\) ; 就可以生成  \((d, n)\) 是私钥;  \((e, n)`是公钥。 进行加密，将讯息 :math:`m\) 用区间  \([0, n-1]\) 的整数来表示; 通过加密得到数据 \(c\) ，然后发送 \(c\)。
\begin{equation*}
\begin{split}c=m^{e} \bmod n\end{split}
\end{equation*}
\sphinxAtStartPar
  那么，解密钥则是:
\begin{equation*}
\begin{split}m=c^{d} \bmod n\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{GCD算法}

\sphinxAtStartPar
  两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数；最大公约数缩写为GCD；GCD算法是最大公约数算法的简称；例如 \(\text{gcd}(\mathrm{N}{1}, \mathrm{~N}{2})\) ，就是求  \(\mathrm{N}{1}, \mathrm{~N}{2}\) 的最大公因数算法，如果  \(\text{gcd}(\mathrm{N}{1}, \mathrm{~N}{2})=1\) ，则称  \(\mathrm{N}{1}, \mathrm{~N}{2}\) 互质。

\sphinxAtStartPar
  例，求  \(\text{gcd}(12, 24)\) ?

\sphinxAtStartPar
  答: 数字 24 可以表示为几组不同正整数的乘积:
\begin{equation*}
\begin{split}24=1 \times 24=2 \times 12=3 \times 8=4 \times 6\end{split}
\end{equation*}
\sphinxAtStartPar
  所以，24 的正因数为: 1,2,3,4,6,8,12,24 。

\sphinxAtStartPar
  数字 12 可以表示为几组不同正整数的乘积:
\begin{equation*}
\begin{split}12=1 \times 12=2 \times 6=3 \times 4\end{split}
\end{equation*}
\sphinxAtStartPar
  所以， 12 的正因素为 1 ， 2 ， 3 ， 4 ， 6 ， 12 。

\sphinxAtStartPar
  两组数中共同的元素，就是它们的公因数：1，2，3，4，6，12；其中的最大公因数是 12 ，即  \(\text{gcd}(12, 24)=12\) 。

\sphinxAtStartPar
\sphinxstylestrong{Mod运算符}

\sphinxAtStartPar
  Mod 运算，是求模运算符（即求余运算），是在整数运算中求一个整数  \(\mathrm{x}\) 除以另一 个整数  \(\mathrm{y}\) 的余数的运算，且不考虑运算的商。例如  \(a \bmod b=c\) ，表明  \({a}\) 除以  \({b}\) 余数为  \({c}\) 。 如下所示:
\begin{equation*}
\begin{split}\begin{aligned} 1 \bmod 12 &=1 \\ 4 \bmod 12 &=4 \\ 20 \bmod 12 &=8 \\ 25 \bmod 12 &=1 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  模运算满足条件:
\begin{equation*}
\begin{split}a b \bmod N=[(\text{amod} N) \times(b \bmod N)] \bmod N\end{split}
\end{equation*}
\sphinxAtStartPar
例: 求  \(5^{3} \bmod 11\) ?   答:
\begin{equation*}
\begin{split}\begin{aligned} & 5^{3} \bmod 11 \\ =& 5^{2} \times 5 \bmod 11 \\ =& 25 \times 5 \bmod 11 \\ =& 3 \times 5 \bmod 11 \\ =& 15 \bmod 11=4 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  那么，由此推导得出的公式为
\begin{equation*}
\begin{split}f(r)=a^{r} \bmod N\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{RSA加密原理}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.4}.png}\hspace*{\fill}}

\begin{center}图4.7.4 RSA加密原理
\end{center}
\sphinxAtStartPar
  RSA加密原理，就是发送方把信息进行RSA加密算法的运算，得到加密的信息进行传输，传输完成，接收方收到的加密信息需要进行解密算法的运算，才可以得出原始传输数据信息。讯息，也是明文。比如文本，有效数据之类的信息。

\sphinxAtStartPar
  例：假设A=65，B=66，…，Z=90，…；怎样可以安全的把BY这个信息从上海带回合肥？

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.5}.png}\hspace*{\fill}}

\begin{center}图4.7.5 例题图
\end{center}
\sphinxAtStartPar
  答: 由上述信息可知，运用 RSA算法，明文 BY 对应的字符串 T 是： 66,89 ；再构 造公钥和私么钥: 选取  \(p=103\) , \(q=97\) ；那么，得出公钥为  \((e, n)=(1213, 9991)\) , 私钥为 \((d, n)=(4117, 9991)\) 。 由  \(\mathrm{RSA}\) 加宓公式 \(c=m^{e} \bmod n\) ;可得:
\begin{equation*}
\begin{split}\begin{array}{l} C_{1}=66^{1213} \bmod 9991=8151 \\ C_{2}=89^{1213} \bmod 9991=176 \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  所以，最终荧回合肥的信息为 \(8151\) ， \(176\) 。

\sphinxAtStartPar
  那么，最终带回合肥的信息如何解密呢?

\sphinxAtStartPar
  由上述的可知，私钥为  \((d, n)=(4117, 9991)\) ; 再进行 RSA 解密运算  \(m=c^{d} \bmod n\) ； 可得
\begin{equation*}
\begin{split}\begin{aligned} m_{1} &=8151^{4117} \bmod 9991=66 \\ m_{2} &=176^{4117} \bmod 9991=89 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  再由题中的已知条件，就可以恢复明文为 BY。

\sphinxAtStartPar
\sphinxstylestrong{Shor算法破解RSA加密问题}

\sphinxAtStartPar
  在一个量子计算机上面，要分解整数  \(\mathrm{N}\) ， Shor 算法的运作需要多项式时间 ( 时间是  \(\log \mathrm{N}\) 的某个多项式这么长，  \(\log \mathrm{N}\) 在这里的意义是输入的档案长度 ) ; 更精确的说，这个算法花费  \(\mathrm{O}((\log \mathrm{N}))\) 的时间，展示出质因数分解问题可以使用量子计算机以多项式时间解 出，因此在复杂度类  \(\mathrm{BQP}\) 里面，Shor 算法比起传统已知最快的因数分解算法、普通数域筛选法还要快了一个指数的差异。

\sphinxAtStartPar
  参考图4.7.6的线路图，量子部分，主要帮助寻找到周期：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1126}.jpg}\hspace*{\fill}}

\begin{center}图4.7.6 线路图
\end{center}
\sphinxAtStartPar
  Shor算法可以分为经典部分和量子部分，通过两个部分的相互结合，从而到到分解的目的。经典部分，主要是在传统计算机上进行运行，目前不存在已知的算法可以对RSA带来威胁；但是量子部分是需要用量子系统来处理，量子计算对RSA提供了解决方案。

\sphinxAtStartPar
\sphinxstylestrong{shor算法运算流程：} 
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
随机选择任意数字 \(1<a<N\) ；

\item {} 
\sphinxAtStartPar
计算 \(\text{gcd}(a, N)\)。使用经典算法完成；

\item {} 
\sphinxAtStartPar
如果  \(\text{gcd}{(a}, N) \neq 1\) 则返回到第一步；

\item {} 
\sphinxAtStartPar
当 \(\text{gcd}(a, N)=1\) 时，构造函数 \(f(x)= a^{x} \bmod N\) 。 寻找最小周期  \(r\) ,使得 \(f(x+ r)=f(x)\).（量子计算部分）；

\item {} 
\sphinxAtStartPar
如果得到找到的 \(\mathrm{r}\) 是奇数，回到第1步；

\item {} 
\sphinxAtStartPar
如果 \(a^{\frac{r}{2}}=-1(\bmod N)\) ，同样回到第1步，从新开始选择 \(a\) ；

\item {} 
\sphinxAtStartPar
如果 \(a^{\frac{r}{2}} \neq-1(\bmod N)\) ，则  \(\text{gcd}(a^{\frac{r}{2}} \pm 1, N)\) 即为所求, 分解完成。

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.7}.png}\hspace*{\fill}}

\begin{center}图4.7.7 Shor算法运算流程
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子算法效能比较：} 

\sphinxAtStartPar
  经典算法和Shor算法就这个问题的对比情况（如图4.7.8）；随着问题的增加，所需要的时间差异非常的大。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.8}.png}\hspace*{\fill}}

\begin{center}图4.7.8 经典算法和Shor算法对比情况
\end{center}

\subsection{4.7.3 量子逻辑电路及量子傅里叶变换}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:id2}}
\sphinxAtStartPar
  量子逻辑电路,分为经典不可逆逻辑电路和经典可逆逻辑电路。

\sphinxAtStartPar
\sphinxstylestrong{经典不可逆逻辑电路}

\sphinxAtStartPar
  对于经典计算，可建立抽象的计算模型。如图4.7.9所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.9}.png}\hspace*{\fill}}

\begin{center}图4.7.9 计算模型
\end{center}
\sphinxAtStartPar
  因为有信息擦出，从而导致，输出不可复原输入；这种不可复原输入的计算模型被称为不可逆计算。

\sphinxAtStartPar
  例，假设这里有个黑盒子，给 \(a\) ,  \(b\) 做模运算，输入 \({a=1}\) ,  \({b=0}\) ，进行模运算后，得出结果为： \(x=1\) ，如图4.7.10所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.10}.png}\hspace*{\fill}}

\begin{center}图4.7.10 模运算
\end{center}
\sphinxAtStartPar
  但是，假设已知  \(x=1\) ，返回去是不能求出  \(a\) 和  \(b\) 的；因为 \(a\) 和  \(b\) 都有可能为1。由此得出，输出不可复原输入，是不可逆计算。

\sphinxAtStartPar
\sphinxstylestrong{经典可逆逻辑电路}

\sphinxAtStartPar
  对于经典计算，可建立抽象的计算模型。如图4.7.11所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.11}.png}\hspace*{\fill}}

\begin{center}图4.7.11 计算模型
\end{center}
\sphinxAtStartPar
  Bennett已经证明了任何经典不可逆计算都可以转化为可逆计算的形式；可逆计算的优点，是可以通过逆计算恢复原始输入。

\sphinxAtStartPar
\sphinxstylestrong{量子线路}

\sphinxAtStartPar
  在量子计算里，酉变换构成的线路是可逆的，如图4.7.12所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.12}.png}\hspace*{\fill}}

\begin{center}图4.7.12 量子可逆线路
\end{center}
\sphinxAtStartPar
  经典线路不可逆计算可以通过特殊的方式转换为量子线路；通过构建黑盒子 \(U_{a}\) 来完成可逆计算，使用  \(U_{a}^{-1}\) 可以复原  \(|0\rangle\) 和  \(|a\rangle\) 。

\sphinxAtStartPar
  量子可逆逻辑电路是构建量子计算机的基本单元，量子可逆逻辑电路综合就是根据电路功能,以较小的量子代价自动构造量子可逆逻辑电路。

\sphinxAtStartPar
\sphinxstylestrong{量子加法器}

\sphinxAtStartPar
  经典加法器的模型，包括了三个输入和两个输出；其中输出与输入的对应关系是：
\begin{equation*}
\begin{split}\begin{array}{c} s_{i}=a_{i} \oplus b_{i} \oplus c_{i} \\ c_{i+1}=a_{i} b_{i} \oplus b_{i} c_{i} \oplus a_{i} c_{i} \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  模型如图4.7.13所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.13}.png}\hspace*{\fill}}

\begin{center}图4.7.13 经典加法器模型
\end{center}
\sphinxAtStartPar
  其对应的真值表，如表4.7.1所示：

\begin{center}表4.7.1 经典加法器真值表
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{表4.7.1}.png}\hspace*{\fill}}

\sphinxAtStartPar
  由上述可知，假设给定任意的输入  \(a_{i}\) ,  \(b_{i}\) ,  \(c_{i}\) ，都能有对应的值输出; 并且它们都 满足上述的加法条件。

\sphinxAtStartPar
\sphinxstylestrong{量子加法器假想模型}

\sphinxAtStartPar
  经典加法器的模型，实际上是一个不可逆的变换，因为它有三个输入两个输出，不可实现复原操作。所以量子加法器的模型需要去构建一个酉变换，也就是可逆操作；它可以通过一次计算，同时得到  \(s_{i}\) 和  \(c_{i+1}\) 。如图4.7.14：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.14}.png}\hspace*{\fill}}

\begin{center}图4.7.14 量子加法器模型
\end{center}
\sphinxAtStartPar
  相对于经典加法器, 它的三个输入没有发生变化，只是输出由之前的  \(s_{i}\) 和  \(c_{i+1}\) ， 多了一个输出  \(a_{i}\) 。 那么，输出与输入的对应关系是;
\begin{equation*}
\begin{split}\begin{array}{c} s_{i}=a_{i} \oplus b_{i} \oplus c_{i} \\ c_{i+1}=a_{i} b_{i} \oplus b_{i} c_{i} \oplus a_{i} c_{i} \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  由此，可以发现其对应关系是没有发生变化的。

\sphinxAtStartPar
  通过上述假想模型，给量子加法器提供了很好的思考方向；量子加法器里包含两个重要的模块，MAJ模块和UMA模块。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.15}.png}\hspace*{\fill}}

\begin{center}图4.7.15 MAJ模块和UMA模块
\end{center}
\sphinxAtStartPar
  两个模块是构建量子加法器的基本组件；是作为量子加法器最重要的核心单元之一。

\sphinxAtStartPar
  假设给定MAG和UMA模块后，给定i=4，那么可以看到，它呈现一种递进关系，如图4.7.16：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.16}.png}\hspace*{\fill}}

\begin{center}图4.7.16 递进关系
\end{center}
\sphinxAtStartPar
  给定一个初始辅助比特  \(c_{0}\) 和 0 ; 重要的是比如  \(a_{0}\) 的输出  \(a_{0+1}\) ，那么  \(a_{0+1}\) 就会作下一个模块的输入，依次递进；然后这个控制位，主要是用来判断是否有进位项；最后再通过一系列UMA模块的操作，从而将比特复原，给下一次反复使用。

\sphinxAtStartPar
\sphinxstylestrong{MAJ单元}

\sphinxAtStartPar
  MAJ 单元包含三个输入:  \(a_{i}, b_{i}, c_{i}\) , 以及三个输出:  \(c_{i+1}\) , \(a_{i} \oplus b_{i}\) , \(a_{i} \oplus c_{i}\) 。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.17}.png}\hspace*{\fill}}

\begin{center}图4.7.17 MAJ单元
\end{center}
\sphinxAtStartPar
  那么， \(c_{i+1}\) 在这里被定义为三个输入两两相乘相加的结果，通过转换可以得到如下等价形式:
\begin{equation*}
\begin{split}\begin{aligned} c_{i+1} &=a_{i} b_{i} \oplus b_{i} c_{i} \oplus c_{i} a_{i} \\ &=a_{i} \oplus a_{i} a_{i} \oplus a_{i} b_{i} \oplus b_{i} c_{i} \oplus c_{i} a_{i} \\ &=a_{i} \oplus\left(a_{i} \oplus c_{i}\right)\left(a_{i} \oplus b_{i}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{量子逻辑门}

\sphinxAtStartPar
  在量子计算，特别是量子线路的计算模型里面，一个量子逻辑门是一个基本的、操作一个小数量量子位元的量子线路。它是量子线路的基础，就像传统逻辑门跟一般数位线路之间的关系，与多数传统逻辑门不同，量子逻辑门是可逆的； 然而，传统的计算可以只使用可逆的门表示。

\sphinxAtStartPar
\(CNOT\) 门，对应两个输入 \(a\) ， \(b\) ； \(CNOT\) 门具备这样的操作关系，如图4.7.18：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.18}.png}\hspace*{\fill}}

\begin{center}图4.7.18 CNOT门
\end{center}
\sphinxAtStartPar
  其中输入a为控制位，b为受控位；a不发生变化，如a为1时，b发生改变，得到结果为 \(a \oplus b\) 。

\sphinxAtStartPar
   \(Toffoli\) 门，对应的是两个控制位分别是 \(a\) , \(b\) ，那么  \(c\) 为受控位；输出的分别是  \(a\) ,  \(b\) , \(c \oplus a b_{}\) 。如图4.7.19：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.19}.png}\hspace*{\fill}}

\begin{center}图4.7.19 Toffoli门
\end{center}
\sphinxAtStartPar
  基于这样基本的一个构造方式，给定三个输入；然后从上到下，逐个去实现，最后可以完整的推导出MAJ模块的实际构造情况，如图4.7.20所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{4.7.20}.png}\hspace*{\fill}}

\begin{center}图4.7.20 MAJ模块的实际构造
\end{center}
\sphinxAtStartPar
  输出结果与MAJ模块输出相同：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.21}.png}\hspace*{\fill}}

\begin{center}图4.7.21 输出结果
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{UMA单元}

\sphinxAtStartPar
  UMA单元同样需要  \(CNOT\) 门和  \(Toffoli\) 门来实现构造，不过UMA单元使用MAJ单元的输出作为输入，如图4.7.22：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.22}.png}\hspace*{\fill}}

\begin{center}图4.7.22 UMA单元
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.23}.png}\hspace*{\fill}}

\begin{center}图4.7.23 CNOT门和Toffoli门
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.24}.png}\hspace*{\fill}}

\begin{center}图4.7.24 UMA单元使用MAJ单元的输出作为输入
\end{center}
\sphinxAtStartPar
  最后可以完整的推导出UMA模块的实际构造情况，输出结果如图4.7.25：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.25}.png}\hspace*{\fill}}

\begin{center}图4.7.25 输出结果
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子加法器电路}

\sphinxAtStartPar
  从上述的两个模块中，可以把完整的时序电路绘画出来，如图4.7.26：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen]{{4.7.26}.png}\hspace*{\fill}}

\begin{center}图4.7.26 完整的时序电路
\end{center}
\sphinxAtStartPar
  量子加法器电路其实是可以优化的，可以采用更少的逻辑门来实现相同的结果。在上图中，如果要完成  \(n\) 位的加法器，则需要长度为 \(6n+1\) 的时序电路。

\sphinxAtStartPar
\sphinxstylestrong{快速傅里叶变换（FFT）}

\sphinxAtStartPar
  快速傅里叶变换是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法。如图4.7.27所示，傅里叶变换是一种积分变换，将信号从频域转换到时域的表示。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.27}.png}\hspace*{\fill}}

\begin{center}图4.7.27 傅里叶变换
\end{center}
\sphinxAtStartPar
  傅里叶变换可以将一个时域信号转换成在不同频率下对应的振幅及相位，其频谱就是时域信号在频域下的表现，而逆傅里叶变换可以将频谱再转换回时域的信号。

\sphinxAtStartPar
  例：在图4.7.28的两个区域中，存在哪些联系和关系？

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{4.7.28}.png}\hspace*{\fill}}

\begin{center}图4.7.28 两个区域
\end{center}
\sphinxAtStartPar
  时域中的周期和频率中的周期成反比关系; 如果函数在时域中具有周期  \(r\) ，则变换函 数在频域中具有  \(\frac{1}{r}\) 的周期变化。

\sphinxAtStartPar
  那么，快速傅里叶变换在数学上的表达形式为：
\begin{equation*}
\begin{split}y_{k}=\sum_{j=0}^{N-1} e^{\frac{2 \pi i k j}{N}} x_{j}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中  \(\mathrm{x}_{\mathrm{j}}\) 是输入，  \(\mathrm{y}_{\mathrm{k}}\) 是输出；由此可见，如果用量子计算中的一些相位门来表达傅里叶变换，以  \(e\) 为底，在量子计算中的表达是:
\begin{equation*}
\begin{split}\left[\begin{array}{cc} 1 & 0 \\ 0 & e^{i \theta} \end{array}\right]\left[\begin{array}{c} \alpha_{0} \\ \alpha_{1} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{量子傅里叶变换（QFT）}

\sphinxAtStartPar
  量子傅里叶变换(quantum Fourier transform)是一种离散傅里叶变换，将原式分解成更为简单的多个幺正矩阵的积。

\sphinxAtStartPar
  量子傅里叶变换实际上是作用在  \(C^{2 n}\) 空间上的离散傅立叶变换。离散傅立叶变换是作用在复  \(\mathrm{N}\) 维欧氏空间  \(C^{N}\) 上的一个酉变换，当输入为复向量  \(\left(x_{0}, x_{1}, \cdots, x_{N-1}\right)\) 时，其输出为复向量  \(\left(y_{0}, y_{1}, \cdots, y_{N-1}\right)\) ,其中:
\begin{equation*}
\begin{split}y_{k}=\frac{1}{\sqrt{N}} \sum_{i=0}^{N-1} x_{j} e^{\frac{2 \pi j i k}{N}}(k=0,1, L, N-1)\end{split}
\end{equation*}
\sphinxAtStartPar
  由上式得出：
\begin{equation*}
\begin{split}\left(y_{0}, y_{1}, \cdots, y_{N-1}\right)=\left(x_{0}, x_{1}, \cdots, x_{N-1}\right)\left[\begin{array}{cccc} 1 & 1 & \cdots & 1 \\ 1 & e^{\frac{2 \pi j}{N}} & \cdots & e^{\frac{2 \pi(N-1) j}{N}} \\ \vdots & \vdots & \ddots & \vdots \\ 1 & e^{\frac{2 \pi(N-1) j}{N}} & \cdots & \mathrm{e}^{\frac{2 \pi(N-1)^{2}j}{N}} \end{array}\right] \frac{1}{\sqrt{N}}\end{split}
\end{equation*}
\sphinxAtStartPar
  量子傅里叶变换，在量子力学的方式上，表达形式为：
\begin{equation*}
\begin{split}\sum_{j} \alpha_{j}|j\rangle \rightarrow \sum_{k} \tilde{\alpha}_{k}|k\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  其中  \(\tilde{\alpha}_{\mathrm{k}}\) 的定义形式为:
\begin{equation*}
\begin{split}\tilde{\alpha}_{k}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} e^{2 \pi i j k / N} \alpha_{j}\end{split}
\end{equation*}
\sphinxAtStartPar
  由此可见，量子傅里叶变换是可逆的，而且是一个酉变化。

\sphinxAtStartPar
例，假设输入一个  \(|10\rangle\) ，通过傅里叶变换之后，得出 \(|00\rangle\) , \(|01\rangle\) , \(|10\rangle\) , \(|11\rangle\) 的叠加态，就到了基底的叠加态。如图 4.7.29 所示:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.29}.png}\hspace*{\fill}}

\begin{center}图4.7.29 傅里叶变换
\end{center}
\sphinxAtStartPar
  如果以线性算子的方式来理解量子傅里叶变换，那就是被定义为一个酉矩阵，表达形式是：
\begin{equation*}
\begin{split}\mathrm{QFT}=\frac{1}{\sqrt{M}}\left(\begin{array}{cccccc} 1 & 1 & 1 & 1 & \cdots & 1 \\ 1 & \omega & \omega^{2} & \omega^{3} & \cdots & \omega^{M-1} \\ 1 & \omega^{2} & \omega^{4} & \omega^{6} & \cdots & \omega^{2 M-2} \\ \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & \omega^{M-1} & \omega^{2 M-2} \omega^{3 M-3} & \cdots& \cdots & \omega^{(M-1)(M-1)} \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  例，假设  \(M=4\) ，  \(\omega^{0}=1\) ， \(\omega^{1}=i\) ，  \(\omega^{2}=-1\) ， \(\omega^{3}=-i\) ，分别求出 0,1,2,3 。
\begin{equation*}
\begin{split}\frac{1}{2}(|0\rangle+|1\rangle+|2\rangle+|3\rangle)=\frac{1}{2}\left(\begin{array}{l} 1 \\ 1 \\ 1 \\ 1 \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  进行傅里叶变换，得出：
\begin{equation*}
\begin{split}|\hat{f}\rangle=\frac{1}{4}\left(\begin{array}{cccc} 1 & 1 & 1 & 1 \\ 1 & i & -1 & -i \\ 1 & -1 & 1 & -1 \\ 1 & -i & -1 & i \end{array}\right)\left(\begin{array}{l} 1 \\ 1 \\ 1 \\ 1 \end{array}\right)=\left(\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  最终的得出状态被映射成 1 ， 0 ， 0 ， 0 。假设得知最终状态，进行逆变换验证:
\begin{equation*}
\begin{split}\begin{array}{l} \frac{1}{4}\left(\begin{array}{cccc} 1 & 1 & 1 & 1 \\ 1 & i & -1 & -i \\ 1 & -1 & 1 & -1 \\ 1 & -i & -1 & i \end{array}\right)\left(\begin{array}{l} 1 \\ 1 \\ 1 \\ 1 \end{array}\right)=\left(\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right) \\ \frac{1}{2}\left(\begin{array}{cccc} 1 & 1 & 1 & 1 \\ 1 & i & -1 & -i \\ 1 & -1 & 1 & -1 \\ 1 & -i & -1 & i \end{array}\right)\left(\begin{array}{l} 1 \\ 0 \\ 0 \\ 0 \end{array}\right)=\left(\begin{array}{l} 1 \\ 1 \\ 1 \\ 1 \end{array}\right) \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  结果可以从输出态1，0，0，0又转换为输入态1，1，1，1；那如果用不同的输入重复计算的时候，其结果如图4.7.30所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.30}.png}\hspace*{\fill}}

\begin{center}图4.7.30 结果
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{量子傅里叶的量子计算的符号}
\begin{equation*}
\begin{split}\begin{array}{c}j=j_{1} j_{2} \cdots j_{n}=j_{1} 2^{n-1}+j_{2} 2^{n-2}+\cdots+j_{n} \\0 . j_{l} j_{l+1} \cdots j_{m}=\frac{j_{l}}{2}+\frac{j_{l+1}}{4}+\cdots+\frac{j_{m}}{2^{m-l+1}}\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  例，假设令  \(j=2\) ，使用二进制表达为 \(10\) ， \(j_{1}=1\) , \(j_{2}=0\) , 表达形式如下:
\begin{equation*}
\begin{split}j=j_{1} j_{2} \cdots j_{n}=j_{1}{2^{n-1}}+j_{2}{2^{n-2}}+\cdots+j_{n}\end{split}
\end{equation*}
\sphinxAtStartPar
  假设令  \(j=0.5\) ，使用二进制表达为  \(0.10\) ; 表达形式为：
\begin{equation*}
\begin{split}0 . j_{l} j_{l+1} \cdots j_{m}=\frac{j_{l}}{2}+\frac{j_{l+1}}{4}+\cdots+\frac{j_{m}}{2^{m-l+1}}\end{split}
\end{equation*}
\sphinxAtStartPar
  通过证明可以迭代执行量子傅里叶变换为:
\begin{equation*}
\begin{split}\begin{array}{c} \left|j_{1} \cdots j_{n}\right\rangle \\ \frac{\left(|0\rangle+e^{2 \pi i 0 . j_{n}}|1\rangle\right)\left(|0\rangle+e^{2 \pi i 0 . j_{n-1} j_{n}}|1\rangle \cdots|0\rangle+e^{2 \pi i 0 . j_{1} j_{2} \cdots j_{n}}|1\rangle\right.}{2^{n / 2}} \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  如果，给定输入状态，以二进制表示的  \(\mathrm{j}{1}\) 到  \(\mathrm{j}{\mathrm{n}}\) , 可以将状态变换。通过这个表达式, 可以转换为相位门的表达方式。 \(CR\) 量子门在控制位为 \(|1\rangle\) 时做控制相位变换操作, 受控运算符的矩阵形式为:
\begin{equation*}
\begin{split}\hat{R}_{k}=\left(\begin{array}{cc} 1 & 0 \\ 0 & e^{2 \pi i / 2^{k}} \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  那么，通过一系列受控 \(R\) 门实现量子傅里叶变换，它的线路图如图4.7.31所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.31}.png}\hspace*{\fill}}

\begin{center}图4.7.31 线路图
\end{center}
\sphinxAtStartPar
  在第一个比特位上，总共会有 \(n-1\) 个控制位；状态也被置于叠加态。例如，6比特的量子云平台绘图形式如图4.7.32：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.32}.png}\hspace*{\fill}}

\begin{center}图4.7.32 6比特的量子云平台绘图形式
\end{center}
\sphinxAtStartPar
  控制位从  \(\frac{\pi}{2}\) 开始，受控位为  \(\frac{\pi}{2}\) 、 \(\frac{\pi}{4}\) 、 \(\frac{\pi}{8}\) 、 \(\frac{\pi}{16}\) 、 \(\frac{\pi}{32} \ldots\) (数字依赖于输入比特的数量)。其表 达形式为:
\begin{equation*}
\begin{split}\hat{R}_{k}=\left(\begin{array}{cc} 1 & 0 \\ 0 & e^{2 \pi i / 2^{k}} \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  如果初始化都是0，则控制不工作。线路等价于对所有比特做H门操作。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.33}.png}\hspace*{\fill}}

\begin{center}图4.7.33 H门操作
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{PyQPanda演示} 

\noindent{\hspace*{\fill}\sphinxincludegraphics{{4.7.34}.png}\hspace*{\fill}}

\begin{center}图4.7.34 PyQPanda演示
\end{center}

\subsection{4.7.4 算法原理}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:id3}}
\sphinxAtStartPar
\sphinxstylestrong{算法原理概述}

\sphinxAtStartPar
  从时间复杂度上比较：使用传统计算机，解决素数分解的最佳复杂度如图4.7.35所示：（n，表示素数乘积的位数）

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250\sphinxpxdimen]{{4.7.35}.png}\hspace*{\fill}}

\begin{center}图4.7.35 解决素数分解的最佳复杂度
\end{center}
\sphinxAtStartPar
  Shor算法则可以将复杂度大幅降低，如图4.7.36所示:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250\sphinxpxdimen]{{4.7.36}.png}\hspace*{\fill}}

\begin{center}图4.7.36 复杂度大幅降低
\end{center}
\sphinxAtStartPar
  由此可见，shor算法提供了超多项式执行加速；复杂度的降低，同时使RSA加密算法处在危险中。

\sphinxAtStartPar
  Shor算法的思想，是将分解问题转化为寻找模指数电路的周期问题，构建模指数电路，通过逆QFT找到模指数电路的周期。

\sphinxAtStartPar
  Shor 算法的核心电路主要包含傅里叶变换 (QFT)，模指线路 \(U_{\mathrm{f}}\) 计算函数，以及逆傅里叶变换  \(\left(\mathrm{QFT}^{-1}\right)\) 。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.37}.png}\hspace*{\fill}}

\begin{center}图4.7.37 Shor算法的核心电路
\end{center}
\sphinxAtStartPar
  模指线路 \(U_{\mathrm{f}}\) 计算函数：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.37.1}.png}\hspace*{\fill}}

\sphinxAtStartPar
  线路图总览：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.38}.png}\hspace*{\fill}}

\begin{center}图4.7.38 本源量子Shor算法实施线路图
\end{center}
\sphinxAtStartPar
  n取决于N的比特位编码个数；比如分解15的时候，实际上会用4个比特位去表示。

\sphinxAtStartPar
\sphinxstylestrong{问题转化}

\sphinxAtStartPar
  假设分解的数为 \(\mathrm{N}\) ，任取  \(a \in[2, N-1]\) , 满足  \(\mathrm{a}\) 和  \(\mathrm{N}\) 互质,且
\begin{equation*}
\begin{split}\begin{array}{l}a^{r}=1 \bmod N \quad \text { (其中 } \mathrm{r} \text { 为偶数) } \\\left(a^{\frac{r}{2}}+1\right)\left(a^{\frac{r}{2}}-1\right)=k N\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  如果
\begin{equation*}
\begin{split}a^{\frac{r}{2}} \neq-1 \bmod N, a^{\frac{r}{2}} \neq 1 \bmod N\end{split}
\end{equation*}
\sphinxAtStartPar
  得到  \(\mathrm{N}\) 的两个因子  \(p_{1}\) 和  \(p_{2}\)
\begin{equation*}
\begin{split}p_{1}=\text{gcd}\left(a^{\frac{r}{2}}+1, N\right) \text { 和 } p_{2}=\text{gcd}\left(a^{\frac{r}{2}}-1, N\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  在上述转化中，有个特殊的情况需要考虑;

\sphinxAtStartPar
  如果 \(N=p^{m}\) ，则无法用该方法进行转化，所以在算法开始之前，还需做如下判定: 判断 \(\sqrt[k]{N} \in Z\) 是否为真，其中  \(k \leq \log {2} N{\circ}\)

\sphinxAtStartPar
\sphinxstylestrong{Shor算法电路框架}

\sphinxAtStartPar
  Shor算法电路框架总共包括四个板块，分别是模指模块、常数模乘、常数模加、以及加法器的构造。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.39}.png}\hspace*{\fill}}

\begin{center}图4.7.39 Shor算法电路框架
\end{center}
\sphinxAtStartPar
  那么，构建量子加法器，它是作为模指底层的核心组件，通过加法器的构造来构建常数模加，它是将问题转换为常数模加，借用辅助比特完成操作；再由常数模加来构建常数模乘，将模指问题转换为可求解的模常数模块；再由常数模乘来完成最终的模指模块，该模块就是为问题解决的模块。

\sphinxAtStartPar
  Shor算法的量子线路图，如图4.7.40所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.40}.png}\hspace*{\fill}}

\begin{center}图4.7.40 Shor算法的量子线路图
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{模指模块}

\sphinxAtStartPar
  QFT和模指数电路 \(f(x)=a^{x} \bmod N\)

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.41}.png}\hspace*{\fill}}

\begin{center}图4.7.41 QFT和模指数电路
\end{center}
\sphinxAtStartPar
  \(\mathrm{N}\) 对应的二进制长度为 \(n\) ，输入的 \(x\) 的位数 \(m\) 不固定，一般为 \(2 n\) 位，即  \(m=2 n\) ; 考虑  \(\left[\log _{2} N\right]\) 是分解数  \(\mathrm{N}\) 所需要表示的比特数。

\sphinxAtStartPar
\sphinxstylestrong{常数模乘}

\sphinxAtStartPar
  模指:  \(f(x)=a^{x} \bmod N\) ， \(\mathrm{x}\) 的二进制表达方式如下:
\begin{equation*}
\begin{split}\mathrm{x}=\left(\mathrm{x}_{2 \mathrm{n}-1}, \cdots, x_{1}, \mathrm{x}_{0}\right)=\sum_{i=0}^{2 n-1} x_{i} \times 2^{i}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中
\begin{equation*}
\begin{split}X_{i},(i=0 \ldots 2 n-1)\end{split}
\end{equation*}
\sphinxAtStartPar
\(\mathrm{f}(\mathrm{x})\) 可以写成
\begin{equation*}
\begin{split}f(x)=\prod_{i=0}^{t-1} a^{2^{i} x_{i}} \bmod N=a^{x_{i} \times \sum_{i}^{2 n-1} a^{i}} \bmod N\end{split}
\end{equation*}
\sphinxAtStartPar
  即：
\begin{equation*}
\begin{split}\left(\mathrm{a}^{2^{0}} \bmod N\right)^{x_{0}} \cdot\left(a^{2^{1}} \bmod N\right)^{x_{1}} \cdots\left(a^{2^{2 n-1}} \bmod N\right)^{x_{2 n-1}} \bmod N\end{split}
\end{equation*}
\sphinxAtStartPar
  如图4.7.42：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.42}.png}\hspace*{\fill}}

\begin{center}图4.7.42 常数模指
\end{center}
\sphinxAtStartPar
  假设有电路 \(U|y\rangle\rightarrow|Cy \ mod\ N)\) , 取 \(C\) 为 \(a^{2^i}\) , \(i=0\) , \(1\) , \(\ldots\) , \(2 n-1\) , 将 \(|y\rangle\) 的初态设为 \(|1\rangle\) , 然后依次经过 \(C_{i} U_{i}\) 门 : ( 常数模乘 )
\begin{equation*}
\begin{split}|1\rangle \rightarrow\left|a^{x_{i} \times \sum_{i}^{2 n-1} a^{i}}\right\rangle \sim \sim\left|a^{x} \bmod N\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  如图4.7.43：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.43}.png}\hspace*{\fill}}

\begin{center}图4.7.43 常数模乘
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{线路框架}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.44}.png}\hspace*{\fill}}

\begin{center}图4.7.44 线路框架
\end{center}
\sphinxAtStartPar
  首先在  \(|x\rangle\) 上加 \(Q F T\) 构成叠加态，同时将 \(2^{2 n-1}\) 个  \(x\) 输入电路，用  \(Q F T^{-1}\) 分析经过模 指电路后的态的周期性，从而得到 \(f(x)\) 的周期；

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.45}.png}\hspace*{\fill}}

\begin{center}图4.7.45 线路说明
\end{center}
\sphinxAtStartPar
  这里总共有 \(2 \mathrm{n}\) 个控制  \(\mathrm{U}\) 块。每个输入量子比特都控制着下方的模  \(\mathrm{N}\) 乘法器  \(\mathrm{CU}_{\mathrm{a}^{2^{i}}}\) ，注意这里设其常数为 \(a^{2^{i}}\) 。例: \(U|y\rangle \rightarrow|Cy \mod N\rangle\) 使用同样的方法，用二进制表示  \(y=\sum_{i=0}^{n-1} y_{i} \times 2^{i}\) ,同理  \(y_{i}\) 做控制位，将所需问题转化为加法  \(C_{i}-U(A D D)\) :

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.46}.png}\hspace*{\fill}}

\begin{center}图4.7.46 转换成一组常数模加
\end{center}\begin{equation*}
\begin{split}|y\rangle|z\rangle \rightarrow|y\rangle\left|z+C \times 2^{i}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  首先,  \(|z\rangle\) 初态置为 \(|0\rangle\) , 经过一连串 \(C_{i}-A D D\) 得到
\begin{equation*}
\begin{split}|y\rangle|0\rangle \rightarrow|y\rangle|C y \ \bmod N\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  再通过交换操作：
\begin{equation*}
\begin{split}|y\rangle|C y \bmod N\rangle \rightarrow|C y \bmod N\rangle|y\rangle\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.47}.png}\hspace*{\fill}}

\begin{center}图4.7.47 将常数模加中的辅助比特回收
\end{center}
\sphinxAtStartPar
  最终目标:
\begin{equation*}
\begin{split}|C y \bmod N\rangle|y\rangle \rightarrow|C y \bmod N\rangle|0\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  整个过程：
\begin{equation*}
\begin{split}|y\rangle|0\rangle \rightarrow|C y \bmod N\rangle|0\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  如图4.7.48：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.48}.png}\hspace*{\fill}}

\begin{center}图4.7.48 整个过程
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{常数模加}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.49}.png}\hspace*{\fill}}

\begin{center}图4.7.49 常数模加
\end{center}
\sphinxAtStartPar
  常数模加输入的比特： \(2N+2\) 个量子比特；其中底部两个辅助比特，分别是：初始进位辅助比特；进位判断辅助比特。

\sphinxAtStartPar
\sphinxstylestrong{内部结构分析}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{4.7.50}.png}\hspace*{\fill}}

\begin{center}图4.7.50 内部结构分析
\end{center}
\sphinxAtStartPar
  常数模加内部包含的三个模块，分别是绑定数据 \(\left(\mathrm{B}\left(2^{n}-N+C\right)\right)\) ；进位器（Carrier）；加法器（Adder）。

\sphinxAtStartPar
  1、绑定数据，将  \(\mathrm{N}\) 个初始化为 0 的输入比特绑定为 \(|a\rangle\) , 绑定关系为  \(\left(\mathrm{B}\left(2^{n}-N+C\right)\right)\) ， 其中  \(\mathrm{N}\) 是分解数，  \(\mathrm{C}\) 是常数，  \(2^{n}\) 是按分解数所需的量子比特数。如图4.7.52：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.51}.png}\hspace*{\fill}}

\begin{center}图4.7.51 绑定数据
\end{center}
\sphinxAtStartPar
  2、进位器（Carrier）如图4.7.53：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.52}.png}\hspace*{\fill}}

\begin{center}图4.7.52 进位器（Carrier）
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.53}.png}\hspace*{\fill}}

\begin{center}图4.7.53 翻转操作CNOT门
\end{center}
\sphinxAtStartPar
  3、加法器（Adder）由MAJ和UMA模块组成。如图4.7.54：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{4.7.54}.png}\hspace*{\fill}}

\begin{center}图4.7.54 加法器（Adder）
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{常数模加的工作机制：}

\sphinxAtStartPar
  1. 先进行数据绑定。

\sphinxAtStartPar
  2. 开始先用进位器来判断，是否有进位，如果有，执行第一个模块，带常数的加法器，反之，只是常数绑定的加法器。最后，为了不浪费量子比特，需要比特置零，方便反复使用。

\sphinxAtStartPar
  3. 绿色辅助比特加常数，判断是否大于N.如果大于N，问题就转化为绿色线（定义为a） \(a+c\ mod\ N\) 的问题，就可以导出模加。

\sphinxAtStartPar
  态的演化

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=650\sphinxpxdimen]{{4.7.55}.png}\hspace*{\fill}}

\begin{center}图4.7.55 态的演化
\end{center}
\sphinxAtStartPar
  首先，给定  \(Q=2^{t}, t=2 n\)  (量子比特数), \(f(x)=\mathrm{a}^{x} \bmod N\) ， 周期为  \(\mathrm{r}\) 。

\sphinxAtStartPar
  初态为:  \(|\varphi\rangle=\frac{1}{\sqrt{Q}} \sum_{i=0}^{Q-1}|i\rangle|1\rangle\) , 经过  \(\mathrm{H}\) 门操作后，态就变成了叠加态;再和辅助比特作用;  \(|1\rangle\)  是十进制的  \(1\) ; 初始化为  \(0,0,0,0,1\) 。

\sphinxAtStartPar
  之后，经过模指线路后：
\begin{equation*}
\begin{split}|\varphi\rangle=\frac{1}{\sqrt{Q}}(|0\rangle|f(0)\rangle+|r\rangle|f(0)\rangle+\ldots+|m r\rangle|f(0)\rangle\end{split}
\end{equation*}\begin{equation*}
\begin{split}+|1\rangle|f(1)\rangle+|1+r\rangle|f(1)\rangle+\ldots+|1+m r\rangle|f(1)\rangle\end{split}
\end{equation*}\begin{equation*}
\begin{split}+|2\rangle|f(2)\rangle+|2+r\rangle|f(2)\rangle+\ldots+|2+m r\rangle|f(2)\rangle\end{split}
\end{equation*}\begin{equation*}
\begin{split}\ldots \ +|r-1\rangle|f(r-1)\rangle+|r-1+r\rangle|f(r-1)\rangle+\ldots+|r-1+m r\rangle|f(r-1)\rangle)\end{split}
\end{equation*}\begin{equation*}
\begin{split}=\frac{1}{\sqrt{Q}} \sum_{i=0}^{r-1} \sum_{j=0}^{m}|i+j r\rangle|f(i)\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  假设定义 \(\mathrm{r} \times \mathrm{m} \approx \mathrm{Q}\) ，M则可能是一个大的值；由上述演化可得出，经过模指线路，态呈现一种周期性的规律。

\sphinxAtStartPar
  上半部分做 \(Q F T^{-1}\) 后：
\begin{equation*}
\begin{split}\begin{array}{c} |i+j r\rangle \rightarrow \frac{1}{\sqrt{Q}} \sum_{k=0}^{Q-1} w^{k(i+j r)}|k\rangle \ w=e^{\frac{-2 \pi{i}}{Q}} \ |\varphi\rangle=\frac{1}{Q} \sum_{i=0}^{r-1} \sum_{j=0}^{m} \sum_{k=0}^{Q-1} w^{k(i+j r)}|k\rangle|f(i)\rangle \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  得出共  \(r \times Q\) 个态。

\sphinxAtStartPar
  此时  \(|k\rangle|f(i)\rangle\) 的复振幅:
\begin{equation*}
\begin{split}F_{k}=\frac{1}{Q} \sum_{j=0}^{m} w^{k(i+j r)}=\frac{1}{Q} w^{k i} \frac{1-w^{m k r}}{1-w^{k r}}\end{split}
\end{equation*}
\sphinxAtStartPar
  此时测量  \(|\mathrm{k}\rangle\) 态的概率为:
\begin{equation*}
\begin{split}\begin{array}{c} P_{k}=\sum_{i=0}^{r-1}\left|F_{k}\right|^{2}=\frac{r}{Q^{2}} \times\left|\frac{1-w^{m k r}}{1-w^{k r}}\right|^{2} \\ w=e^{\frac{-2 \pi i}{Q}} \\ \left|\frac{1-w^{m k r}}{1-w^{k r}}\right|^{2}=\frac{1-\cos (m \theta)}{1-\cos (\theta)} \\ \theta=\frac{k \times r}{Q} \times 2 \pi \\ P_{k}=\frac{r}{Q^{2}} \times \frac{1-\cos (m \theta)}{1-\cos (\theta)} \\ \quad \theta=2 \pi \times s \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\mathrm{S}\) 为整数时， \(\mathrm{P}_{\mathrm{k}}\) 取最大值
\begin{equation*}
\begin{split}P_{k \max }=\frac{r}{Q^{2}} \times m^{2} \approx \frac{1}{r}, m \times r \approx Q\end{split}
\end{equation*}
\sphinxAtStartPar
  由此可知，可以通过测量概率找到  \(\mathrm{r}\) 的关系。

\sphinxAtStartPar
  最后测量的 \(|k\rangle\) ,测量结果满足  \(\theta=\frac{k \times r}{Q}\) 为整数或接近整数，根据  \(\frac{k}{Q} \sim \sim \frac{s}{r}\) 对  \(\frac{k}{Q}\) 做连分数分解，得到  \(r`的值，即得到  :math:`f(x)=a^{x} \bmod N\) 的周期。通过模拟，假设  \(\mathrm{m}=50\) ， \(\frac{1-\cos (m \times \theta)}{1-\cos (\theta)}\) 的演算如图 4.7.57:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{4.7.56}.png}\hspace*{\fill}}

\begin{center}图4.7.56  \(\mathrm{m}=50\) ，  \(\frac{1-\cos (m \times \theta)}{1-\cos (\theta)}\) 的演算
\end{center}
\sphinxAtStartPar
  由上图可知，它已经有了相应的值，那这些值就是最终要选取的值。

\sphinxAtStartPar
\sphinxstylestrong{确认周期}

\sphinxAtStartPar
  连分数的分解,采用层层分解的形式，如图4.7.57：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{4.7.57}.png}\hspace*{\fill}}

\begin{center}图4.7.57 层层分解
\end{center}
\sphinxAtStartPar
\(\frac{k}{Q}\) 是  \(\frac{c}{r}\) 的近似，将  \(\frac{k}{Q}\) 通过连分数方法发现  \(\mathrm{r}\) 。例，假设 \(\mathrm{N}=77\) ，求  \(\mathrm{r}\) 的值。
\begin{equation*}
\begin{split}N=11 \times 7 \text {,取 } f(x)=3^{x} \bmod 77, r=30\end{split}
\end{equation*}
\sphinxAtStartPar
  Shor 算法中上部分取 14 (即  \(2 \times 7=14\) ) 个量子比特;
\begin{equation*}
\begin{split}\begin{array}{c} Q=2^{14}, \text { 最后经过 } \mathrm{QFT} \text { 后有 } \\ p_{k}=\frac{1}{Q \times m} \times \frac{1-\cos (m \theta)}{1-\cos (\theta)} \\ \theta=\exp \left(\frac{2 \pi \times k r}{Q}\right), m \times r \sim Q, p_{k \max }=\frac{1}{m} \\ \frac{k}{Q} \rightarrow \frac{0}{r}, \frac{1}{r}, \frac{2}{r} \ldots \frac{r-1}{r} \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  上述可知，由连分数的分解，最终得到 \(\frac{r-1}{r}\) , 可以确定  \(\mathrm{r}\) 的值。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=650\sphinxpxdimen]{{4.7.58}.png}\hspace*{\fill}}

\begin{center}图4.7.58 连分数逼近
\end{center}
\sphinxAtStartPar
   如图4.7.58可知，K值是预计测量的值，通过计算，再使用连分数的逼近关系，可以得出的结果是 \(r=30\) ，满足我们的条件。


\subsection{4.7.5 pyQPanda中的示例}
\label{\detokenize{rst/4.7Shor_u5206_u89e3_u7b97_u6cd5:pyqpanda}}
\sphinxAtStartPar
  导入依赖的库

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{}绘图}
\PYG{l+m+mf}{3.}\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m} \PYG{c+c1}{\PYGZsh{}数学}
\end{sphinxVerbatim}

\sphinxAtStartPar
  绘制柱状图

\sphinxAtStartPar
  绘制数据图所需，直接复制使用即可：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} 绘制柱状图}
\PYG{l+m+mf}{2.}\PYG{k}{def} \PYG{n+nf}{plotBar}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{n}{fig}\PYG{o}{.}\PYG{n}{set\PYGZus{}size\PYGZus{}inches}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{n}{fig}\PYG{o}{.}\PYG{n}{set\PYGZus{}dpi}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{n}{rects} \PYG{o}{=}  \PYG{n}{ax}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{k}{for} \PYG{n}{rect} \PYG{o+ow}{in} \PYG{n}{rects}\PYG{p}{:}
\PYG{l+m+mf}{10.}        \PYG{n}{height} \PYG{o}{=} \PYG{n}{rect}\PYG{o}{.}\PYG{n}{get\PYGZus{}height}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{11.}        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{rect}\PYG{o}{.}\PYG{n}{get\PYGZus{}x}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rect}\PYG{o}{.}\PYG{n}{get\PYGZus{}width}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{height}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{height}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ha}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{center}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{va}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bottom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{font.sans\PYGZhy{}serif}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Arial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{l+m+mf}{14.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Origin Q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Times}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{16.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{States}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  重新组织数据quick\_measure的数据

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{reorganizeData}\PYG{p}{(}\PYG{n}{measure\PYGZus{}qubits}\PYG{p}{,} \PYG{n}{quick\PYGZus{}meausre\PYGZus{}result}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{xdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{3.}    \PYG{n}{ydata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{quick\PYGZus{}meausre\PYGZus{}result}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{n}{xdata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{l+m+mf}{7.}        \PYG{n}{ydata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{quick\PYGZus{}meausre\PYGZus{}result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{k}{return} \PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}
\end{sphinxVerbatim}

\sphinxAtStartPar
  用辗转相除法求最大公约数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{gcd}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{n}\PYG{p}{:}
\PYG{l+m+mf}{3.}        \PYG{k}{return} \PYG{n}{m}
\PYG{l+m+mf}{4.}    \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{k}{return} \PYG{n}{gcd}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{m}\PYG{o}{\PYGZpc{}}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  量子加法器MAJ模块

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} a,b,c是单个量子比特, 其中a是辅助比特}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} a \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} c xor a}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} b \PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZbs{}\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} c xor b}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{} c \PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ((c xor a) and (c xor b)) xor c = R}
\PYG{l+m+mf}{6.}\PYG{c+c1}{\PYGZsh{}}
\PYG{l+m+mf}{7.}\PYG{k}{def} \PYG{n+nf}{MAJ}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Toffoli}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  量子加法器UMA模块

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} a,b,c是单个量子比特}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{}}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} a \PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ((a and b) xor c) xor a}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} b \PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZbs{}\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} (((a and b) xor c) xor a) xor b}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{} c \PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} (a and b) xor c}
\PYG{l+m+mf}{6.}\PYG{c+c1}{\PYGZsh{}}
\PYG{l+m+mf}{7.}\PYG{c+c1}{\PYGZsh{} 以MAJ模块的输出作为输入的话，MAJ中辅助比特a保持不变，}
\PYG{l+m+mf}{8.}\PYG{c+c1}{\PYGZsh{} MAJ中的加项c比特保持不变，MAJ中的加项b比特保存的是b+c的结果}
\PYG{l+m+mf}{9.}\PYG{c+c1}{\PYGZsh{}}
\PYG{l+m+mf}{10.}\PYG{c+c1}{\PYGZsh{} c xor a \PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} a}
\PYG{l+m+mf}{11.}\PYG{c+c1}{\PYGZsh{} c xor b \PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZbs{}\PYGZhy{}\PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} c xor b xor a}
\PYG{l+m+mf}{12.}\PYG{c+c1}{\PYGZsh{} R       \PYGZhy{}\PYGZhy{}o\PYGZhy{}\PYGZhy{}\PYGZhy{}x\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} c}
\PYG{l+m+mf}{13.}\PYG{k}{def} \PYG{n+nf}{UMA}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{14.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Toffoli}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  量子加法器UMA模块

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} a 和 b 是一组量子比特表示特定的数，这里我们假设 a 和 b 的长度相同}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} c 是一个辅助比特}
\PYG{l+m+mf}{3.}\PYG{k}{def} \PYG{n+nf}{MAJ2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{4.}    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{!=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{k}{raise} \PYG{n+ne}{RuntimeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a and b must be equal, but not equal to 0!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{n}{nbit} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  量子加法器 由MAJ和UMA模块组成，不考虑进位项

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} a 和 b 是一组量子比特表示特定的数，这里我们假设 a 和 b 的长度相同}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} c 是一个辅助比特}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} 注意：a 中保存的是 a+b 的结果, b 保持不变}
\PYG{l+m+mf}{4.}\PYG{k}{def} \PYG{n+nf}{Adder}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{5.}    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{!=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{k}{raise} \PYG{n+ne}{RuntimeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a and b must be equal, but not equal to 0!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{n}{nbit} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{13.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nbit}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{16.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{UMA}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{UMA}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{19.}
\PYG{l+m+mf}{20.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  判断是否有进位

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} a 和 b 是一组量子比特表示特定的数，这里我们假设 a 和 b 的长度相同}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} c 是一个辅助比特}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} carry 是一个用来保存进位项的辅助比特}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} 注：经过该模块后 a, b, c 对应的比特都保持不变，只有进位比特 carry 有可能会被改变}
\PYG{l+m+mf}{5.}\PYG{k}{def} \PYG{n+nf}{isCarry}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{carry}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{6.}    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{!=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{k}{raise} \PYG{n+ne}{RuntimeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a and b must be equal, but not equal to 0!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{carry}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{13.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{MAJ2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  用量子比特来绑定经典数据

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} 这里假定所有的比特都初始化为0态}
\PYG{l+m+mf}{2.}\PYG{k}{def} \PYG{n+nf}{bindData}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{3.}    \PYG{n}{check\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{k}{if} \PYG{p}{(}\PYG{n}{data} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{check\PYGZus{}value}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{k}{raise} \PYG{n+ne}{RuntimeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data \PYGZgt{}= check\PYGZus{}value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{9.}    \PYG{k}{while} \PYG{p}{(}\PYG{n}{data} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{10.}        \PYG{k}{if} \PYG{p}{(}\PYG{n}{data} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{11.}            \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}        \PYG{n}{data} \PYG{o}{=} \PYG{n}{data} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{14.}        \PYG{n}{i} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  常数模加

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} qa 是一组绑定经典数据的比特，并返回计算的结果}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} C 表示待加的常数}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} M 表示模数}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} qb 表示一组辅助比特}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{} qs1 表示两个辅助比特，其中 qs1[0] 表示进位辅助比特， qs1[1] 表示MAJ模块用到的辅助比特}
\PYG{l+m+mf}{6.}\PYG{c+c1}{\PYGZsh{} 注：该模块会将所有使用到的辅助比特进行还原}
\PYG{l+m+mf}{7.}\PYG{k}{def} \PYG{n+nf}{constModAdd}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{q\PYGZus{}num} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{)}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{n}{tmp\PYGZus{}value} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{q\PYGZus{}num}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{M} \PYG{o}{+} \PYG{n}{C}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{isCarry}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{19.}    \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{20.}    \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Adder}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{22.}    \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{23.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}circ}\PYG{p}{)}
\PYG{l+m+mf}{24.}
\PYG{l+m+mf}{25.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}    \PYG{n}{tmp2\PYGZus{}circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{28.}    \PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{C}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{29.}    \PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Adder}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{30.}    \PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{C}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{31.}    \PYG{n}{tmp2\PYGZus{}circ} \PYG{o}{=} \PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{32.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp2\PYGZus{}circ}\PYG{p}{)}
\PYG{l+m+mf}{33.}
\PYG{l+m+mf}{34.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}    \PYG{n}{tmp\PYGZus{}value} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{q\PYGZus{}num}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{C}
\PYG{l+m+mf}{37.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{38.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{isCarry}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{39.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{bindData}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}value}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{40.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{41.}
\PYG{l+m+mf}{42.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  辗转相除法求模逆

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{modreverse}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{3.}        \PYG{k}{raise} \PYG{n+ne}{RecursionError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c is zero!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{k}{return} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{n}{m1} \PYG{o}{=} \PYG{n}{m}
\PYG{l+m+mf}{9.}    \PYG{n}{quotient} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{10.}    \PYG{n}{quo} \PYG{o}{=} \PYG{n}{m} \PYG{o}{/}\PYG{o}{/} \PYG{n}{c}
\PYG{l+m+mf}{11.}    \PYG{n}{remainder} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZpc{}} \PYG{n}{c}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{quotient}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{quo}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{while} \PYG{p}{(}\PYG{n}{remainder} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{16.}        \PYG{n}{m} \PYG{o}{=} \PYG{n}{c}
\PYG{l+m+mf}{17.}        \PYG{n}{c} \PYG{o}{=} \PYG{n}{remainder}
\PYG{l+m+mf}{18.}        \PYG{n}{quo} \PYG{o}{=} \PYG{n}{m} \PYG{o}{/}\PYG{o}{/} \PYG{n}{c}
\PYG{l+m+mf}{19.}        \PYG{n}{remainder} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZpc{}} \PYG{n}{c}
\PYG{l+m+mf}{20.}        \PYG{n}{quotient}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{quo}\PYG{p}{)}
\PYG{l+m+mf}{21.}
\PYG{l+m+mf}{22.}    \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{quotient}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{23.}        \PYG{k}{return} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{quo}
\PYG{l+m+mf}{24.}
\PYG{l+m+mf}{25.}    \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{quotient}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{26.}        \PYG{k}{return} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{quotient}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{quotient}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{27.}
\PYG{l+m+mf}{28.}    \PYG{n}{rev1} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{29.}    \PYG{n}{rev2} \PYG{o}{=} \PYG{n}{quotient}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{30.}    \PYG{n}{reverse\PYGZus{}list} \PYG{o}{=} \PYG{n}{quotient}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{31.}    \PYG{n}{reverse\PYGZus{}list}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{32.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{reverse\PYGZus{}list}\PYG{p}{:}
\PYG{l+m+mf}{33.}        \PYG{n}{rev1} \PYG{o}{=} \PYG{n}{rev1} \PYG{o}{+} \PYG{n}{rev2} \PYG{o}{*} \PYG{n}{i}
\PYG{l+m+mf}{34.}        \PYG{n}{temp} \PYG{o}{=} \PYG{n}{rev1}
\PYG{l+m+mf}{35.}        \PYG{n}{rev1} \PYG{o}{=} \PYG{n}{rev2}
\PYG{l+m+mf}{36.}        \PYG{n}{rev2} \PYG{o}{=} \PYG{n}{temp}
\PYG{l+m+mf}{37.}
\PYG{l+m+mf}{38.}    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{quotient}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{39.}        \PYG{k}{return} \PYG{n}{rev2}
\PYG{l+m+mf}{40.}
\PYG{l+m+mf}{41.}    \PYG{k}{return} \PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{n}{rev2}
\end{sphinxVerbatim}

\sphinxAtStartPar
  常数模乘

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} qa 是一组绑定经典数据的比特，并返回计算的结果}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} const\PYGZus{}num 表示待乘的常数}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} M 表示模数}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} qs1常数模乘使用的辅助比特}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{} qs2常数模加使用的辅助比特}
\PYG{l+m+mf}{6.}\PYG{c+c1}{\PYGZsh{} qs3 表示两个辅助比特，其中 qs1[0] 表示进位辅助比特， qs1[1] 表示MAJ模块用到的辅助比特}
\PYG{l+m+mf}{7.}\PYG{c+c1}{\PYGZsh{} 注：该模块会将所有使用到的辅助比特进行还原}
\PYG{l+m+mf}{8.}\PYG{k}{def} \PYG{n+nf}{constModMul}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{const\PYGZus{}num}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{9.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{q\PYGZus{}num} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{q\PYGZus{}num}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{15.}        \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{const\PYGZus{}num} \PYG{o}{*} \PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZpc{}}\PYG{n}{M}
\PYG{l+m+mf}{16.}        \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{constModAdd}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{,} \PYG{n}{tmp}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}        \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{18.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}circ}\PYG{p}{)}
\PYG{l+m+mf}{19.}
\PYG{l+m+mf}{20.}    \PYG{c+c1}{\PYGZsh{}state swap}
\PYG{l+m+mf}{21.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{q\PYGZus{}num}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{22.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{23.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{24.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{25.}
\PYG{l+m+mf}{26.}    \PYG{n}{Crev} \PYG{o}{=} \PYG{n}{modreverse}\PYG{p}{(}\PYG{n}{const\PYGZus{}num}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}
\PYG{l+m+mf}{27.}
\PYG{l+m+mf}{28.}    \PYG{n}{tmp2\PYGZus{}circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{29.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{q\PYGZus{}num}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{30.}        \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{Crev}\PYG{o}{*} \PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
\PYG{l+m+mf}{31.}        \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{tmp} \PYG{o}{\PYGZpc{}} \PYG{n}{M}
\PYG{l+m+mf}{32.}        \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{33.}        \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{constModAdd}\PYG{p}{(}\PYG{n}{qs1}\PYG{p}{,} \PYG{n}{tmp}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{34.}        \PYG{n}{tmp\PYGZus{}circ} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}circ}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{35.}        \PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}circ}\PYG{p}{)}
\PYG{l+m+mf}{36.}
\PYG{l+m+mf}{37.}    \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp2\PYGZus{}circ}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{38.}
\PYG{l+m+mf}{39.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  常数模指

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} qa 是一组控制比特}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} qb 保存计算结果}
\PYG{l+m+mf}{3.}\PYG{c+c1}{\PYGZsh{} base 表示指数基底}
\PYG{l+m+mf}{4.}\PYG{c+c1}{\PYGZsh{} M 表示模数}
\PYG{l+m+mf}{5.}\PYG{c+c1}{\PYGZsh{} qs1常数模乘使用的辅助比特}
\PYG{l+m+mf}{6.}\PYG{c+c1}{\PYGZsh{} qs2常数模加使用的辅助比特}
\PYG{l+m+mf}{7.}\PYG{c+c1}{\PYGZsh{} qs3 表示两个辅助比特，其中 qs1[0] 表示进位辅助比特， qs1[1] 表示MAJ模块用到的辅助比特}
\PYG{l+m+mf}{8.}\PYG{k}{def} \PYG{n+nf}{constModExp}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{base}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{9.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{cqnum} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{base}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cqnum}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{16.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{constModMul}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{,} \PYG{n}{temp}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qa}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}        \PYG{n}{temp} \PYG{o}{=} \PYG{n}{temp} \PYG{o}{*} \PYG{n}{temp}
\PYG{l+m+mf}{18.}        \PYG{n}{temp} \PYG{o}{=} \PYG{n}{temp} \PYG{o}{\PYGZpc{}} \PYG{n}{M}
\PYG{l+m+mf}{19.}
\PYG{l+m+mf}{20.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  量子傅利叶变换

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{qft}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{circ} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{qnum} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}
\PYG{l+m+mf}{5.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{qnum}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{7.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qnum}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}            \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{p}{(}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{qnum}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{11.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{12.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{13.}        \PYG{n}{circ}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{n}{qnum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{n}{circ}
\end{sphinxVerbatim}

\sphinxAtStartPar
  Shor算法主体代码

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} base 表示指数基底}
\PYG{l+m+mf}{2.}\PYG{c+c1}{\PYGZsh{} M 表示待分解的数}
\PYG{l+m+mf}{3.}\PYG{k}{def} \PYG{n+nf}{shorAlg}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{4.}    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{base} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{base} \PYG{o}{\PYGZgt{}} \PYG{n}{M} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{k}{raise}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Invalid base!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gcd}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}        \PYG{k}{raise}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Invalid base! base and M must be mutually prime}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{binary\PYGZus{}len} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{11.}    \PYG{k}{while} \PYG{n}{M} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{binary\PYGZus{}len} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{n}{binary\PYGZus{}len} \PYG{o}{=} \PYG{n}{binary\PYGZus{}len} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{machine} \PYG{o}{=} \PYG{n}{init\PYGZus{}quantum\PYGZus{}machine}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU\PYGZus{}SINGLE\PYGZus{}THREAD}\PYG{p}{)}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{n}{qa} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{binary\PYGZus{}len}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{17.}    \PYG{n}{qb} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{binary\PYGZus{}len}\PYG{p}{)}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}    \PYG{n}{qs1} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{binary\PYGZus{}len}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 常数模乘使用的辅助比特}
\PYG{l+m+mf}{20.}    \PYG{n}{qs2} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{binary\PYGZus{}len}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 常数模加使用的辅助比特}
\PYG{l+m+mf}{21.}    \PYG{n}{qs3} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 模加进位需要使用到的辅助比特}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{24.}
\PYG{l+m+mf}{25.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{26.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{single\PYGZus{}gate\PYGZus{}apply\PYGZus{}to\PYGZus{}all}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{qa}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}第一个QFT}
\PYG{l+m+mf}{27.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{constModExp}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{qb}\PYG{p}{,} \PYG{n}{base}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{qs1}\PYG{p}{,} \PYG{n}{qs2}\PYG{p}{,} \PYG{n}{qs3}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{28.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{qft}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{29.}
\PYG{l+m+mf}{30.}    \PYG{n}{directly\PYGZus{}run}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\PYG{l+m+mf}{31.}    \PYG{n}{result} \PYG{o}{=} \PYG{n}{quick\PYGZus{}measure}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{l+m+mf}{32.}
\PYG{l+m+mf}{33.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\PYG{l+m+mf}{34.}
\PYG{l+m+mf}{35.}    \PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata} \PYG{o}{=} \PYG{n}{reorganizeData}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{result}\PYG{p}{)}
\PYG{l+m+mf}{36.}    \PYG{n}{plotBar}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}
\PYG{l+m+mf}{37.}
\PYG{l+m+mf}{38.}    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\sphinxAtStartPar
  主程序

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{base} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{l+m+mf}{3.}    \PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{l+m+mf}{4.}    \PYG{n}{shorAlg}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=450\sphinxpxdimen]{{4.7.59}.png}\hspace*{\fill}}

\begin{center}图4.7.59 运行结果
\end{center}
\sphinxstepscope


\section{5.1 利用QPanda测试量子系统噪声}
\label{\detokenize{rst/5.1_u5229_u7528QPanda_u6d4b_u8bd5_u91cf_u5b50_u7cfb_u7edf_u566a_u58f0:qpanda}}\label{\detokenize{rst/5.1_u5229_u7528QPanda_u6d4b_u8bd5_u91cf_u5b50_u7cfb_u7edf_u566a_u58f0::doc}}
\sphinxAtStartPar
  近些年来，量子计算机芯片包含的量子比特数和量子比特质量不断提升，可以预计，不远的将来会出现包含数百个量子比特，且量子比特质量足够高的量子计算机芯片，称之为NISQ装置。如何用NISQ装置解决具体的实际问题是一个研究热点，比如VQE,QAOA都是有应用前景的NISQ量子算法。NISQ装置中量子比特数还不允许纠错编码，所以NISQ装置是一种噪声容忍装置，在NISQ装置中运行的量子算法都会受到噪声的影响。NISQ量子算法需要对量子噪声有一定的免疫性，需要在含噪声的环境中研究NISQ量子算法。QPanda中包含噪声量子虚拟机，可以模拟带噪声的量子线路，测试量子算法在噪声影响下的性能变化，从而辅助NISQ量子算法的开发。首先对量子噪声做一简单介绍。

\sphinxAtStartPar
\sphinxstylestrong{量子噪声}

\sphinxAtStartPar
  量子计算机不是一个孤立系统，在运行的时候，不可避免会和环境产生耦合，从而影响量子计算机的运行过程，通常用噪声来描述环境对量子计算机的影响。 量子系统的噪声可以用一组算符和  \(\mathrm{K}=\{\mathrm{K}{1}, \mathrm{~K}{2}, \ldots, \mathrm{K}{\mathrm{s}}\}\) 描述： \(\{\mathrm{K}{1}, \mathrm{~K}{2}, \ldots, \mathrm{K}{\mathrm{s}}\}\) 也被称为Kraus算子，  \(\mathrm{K}_{\mathrm{i}}\) 需要满足关系式
\begin{equation*}
\begin{split}\sum_{\mathbf{i}} K_{i}^{\dagger} K_{i}=I\end{split}
\end{equation*}
\sphinxAtStartPar
  在噪声影响下，量子态的演化方式为:
\begin{equation*}
\begin{split}\rho \rightarrow \sum_{\mathrm{i}} K_{i} \rho K_{i}^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  下面列举一些常见噪声的表示形式：

\sphinxAtStartPar
  弛豫噪声:
\begin{equation*}
\begin{split}\mathrm{K}_{1}=\left[\begin{array}{cc} 1 & 0 \\ 0 & \sqrt{1-p} \end{array}\right], \mathrm{K}_{2}=\left[\begin{array}{cc} 0 & \sqrt{p} \\ 0 & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  比特翻转噪声:
\begin{equation*}
\begin{split}\mathrm{K}_{1}=\left[\begin{array}{cc} \sqrt{1-p} & 0 \\ 0 & \sqrt{1-p} \end{array}\right], \mathrm{K}_{2}=\left[\begin{array}{cc} 0 & \sqrt{p} \\ \sqrt{p} & 0 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  退相位噪声:
\begin{equation*}
\begin{split}\mathrm{K}_{1}=\left[\begin{array}{cc} \sqrt{1-p} & 0 \\ 0 & \sqrt{1-p} \end{array}\right], \mathrm{K}_{2}=\left[\begin{array}{cc} \sqrt{p} & 0 \\ 0 & -\sqrt{p} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  退极化噪声:
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{K}_{1}=\sqrt{1-\frac{3}{4} p}\left[\begin{array}{ll} 1 & 0 \\ 0 & 1 \end{array}\right], \mathrm{K}_{2}=\frac{\sqrt{p}}{2}\left[\begin{array}{ll} 0 & 1 \\ 1 & 0 \end{array}\right] \\ &\mathrm{K}_{3}=\frac{\sqrt{p}}{2}\left[\begin{array}{cc} 0 & -i \\ -i & 0 \end{array}\right], \mathrm{K}_{4}=\frac{\sqrt{p}}{2}\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{噪声虚拟机}

\sphinxAtStartPar
  QPanda包含带噪声的量子虚拟机，噪声量子虚拟机可以模拟带噪声的量子线路，我们可以定义各种不同的量子噪声，用噪声量子虚拟机执行对应的含噪声量子线 路。下面介绍QPanda中量子噪声虚拟机的执行原理。 加入噪声后，量子线路中演化的量子态变成混态，所以需要用密度矩阵来描述量子态。与纯态相比，模拟混态演化需要更多的资源，不管是时间复杂度还是空间复杂度，都是纯态演化所需资源的平方量级。为节省资源，在QPanda中，用另外一种方式实现了噪声量子虚拟机，即借助蒙特卡洛方法， 演化过程中还是用态矢来 描述量子态。下面以实现一个噪声量子逻辑门的过程来说明QPandan噪声量子虚拟机的实现原理。

\sphinxAtStartPar
  首先，假设输入态是一个纯态, 用  \(|\phi\rangle\) 表示，要实现的量子逻辑门用  \(\mathrm{U}\) 表示，量子噪声为 \(\mathrm{~K}{1}\) ,  \(\mathrm{~K}{2}\) , \(\ldots\) , \(\mathrm{~K}{s}\) 。含噪声的  \(\mathrm{U}\) 门实现步骤如下: 计算 \(\mathrm{p}{\mathrm{i}}=\left\langle\phi\left|K_{i}^{\dagger} K_{i}\right| \phi\right\rangle\) , \(\mathrm{i}=1\) , \(2\) , :math:` ldots` , \(\mathrm{s} \cdot\) 由噪声的定义，我们可以得到  \(\sum_{\mathrm{i}} p_{i}=1\) 。 生成  \([0, 1)\) 区间均匀分布的随机数  \(\mathrm{r}\) ， 根据上式的计算结果找到下标  \(l\) 满足
\begin{equation*}
\begin{split}\sum_{i=1}^{l-1} p_{i} \leq r \leq \sum_{i=1}^{l} p_{i}\end{split}
\end{equation*}
\sphinxAtStartPar
假设 \(\sum_{i=1}^{0} p_{i}=0\) 。  \(|\phi\rangle\) 的演化公式表示为:
\begin{equation*}
\begin{split}|\phi\rangle \rightarrow \mathrm{U} \frac{1}{\sqrt{\mathrm{P}_{1}}} K_{l}|\phi\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  当以上操作只执行一次时，得到的结果是错误的，但是，当执行以上步骤多次，然后对得到的执行结果做统计分析，就可以得到准确的输出态，假设执行了 \(\mathrm{N}\) 次， 得到了  \(\mathrm{N}\) 个输出态 \(\left|\phi_{1}\right\rangle,\left|\phi_{2}\right\rangle, \ldots ,\left|\phi_{N}\right\rangle\) , 那么最后的输出态可以表示为:
\begin{equation*}
\begin{split}\rho^{\prime}=\frac{1}{\mathrm{~N}} \sum_{n=1}^{N}\left|\phi_{i}\right\rangle\left\langle\phi_{i}\right|\end{split}
\end{equation*}
\sphinxAtStartPar
\(\mathrm{N}\) 个输出态 \(\left|\phi_{1}\right\rangle,\left|\phi_{2}\right\rangle, \ldots\left|\phi_{N}\right\rangle\) 在集合 \(\{\left|\psi_{\mathrm{i}}\right\rangle=\mathrm{U} \frac{1}{\sqrt{\mathrm{P_i}}} K_{i}|\phi\rangle \mid \mathrm{i}=1,2, \ldots, \mathrm{s}\}\) ，假设 \(\mathrm{N}\) 个态中 \(\left|\psi_{\mathrm{i}}\right\rangle\) 出现的次数为 \(\mathrm{M}_{\mathrm{i}}\) ，那么 \(\rho^{\prime}\) 可表示为
\begin{equation*}
\begin{split}\rho^{\prime}=\frac{1}{\mathrm{~N}} \sum_{n=1}^{s} \frac{M_{n}}{p_{n}} U K_{n}|\phi\rangle\langle\phi| K_{n}^{\dagger} U^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  当  \(\mathrm{N} \gg 1\) 时，  \(\mathrm{M}{\mathrm{i}} \cong \mathrm{N} p{i}\) , 从而可以得到
\begin{equation*}
\begin{split}\rho^{\prime} \cong \sum_{n=1}^{s} U K_{n}|\phi\rangle\langle\phi| K_{n}^{\dagger} U^{\dagger}=\rho_{\text {out }}\end{split}
\end{equation*}
\sphinxAtStartPar
  即当 \(\mathrm{N}\) 足够大时，  \(\rho^{\prime}\) 近似等于  \(|\phi\rangle\) 经过噪声量子逻辑门 \(\mathrm{U}\) 后的输出态 \(\rho\) 。

\sphinxAtStartPar
  当执行噪声量子线路时，量子线路由一系列量子逻辑门构成, 每个量子逻辑门都执行上面的步骤，执行多次量子线路，即可得到输出量子态密度矩阵的近似表达式，量子线路执行次数越多，得到的结果越准确。

\sphinxAtStartPar
  通过上述方法， \(QPanda\) 中橾声量子虚拟机就可以用态矢来表示混态演化过程，通过多次运行量子线路得到噪声量子线路输出态的密度矩阵。

\sphinxAtStartPar
\sphinxstylestrong{噪声QAOA测试}

\sphinxAtStartPar
  前面的章节已经介绍过QAOA，QAOA是一种经典\sphinxhyphen{}量子混合算法，提供了一种解决组合优化问题的方法。QAOA运行在NISQ装置上，无法避免噪声的干扰，所以研究噪声对QAOA性能的影响是一项很重要的工作。下面介绍噪声对QAOA性能影响的一些研究进展。

\sphinxAtStartPar
  首先，如何构建含噪声的QAOA，前面章节可知QAOA可以用VQNet实现，目前VQNet可以和QPanda中噪声量子虚拟机结合，执行含噪声的QAOA。这里选取的问题还是最大分割问题。

\sphinxAtStartPar
\sphinxstylestrong{理论模型}

\sphinxAtStartPar
  考虑一种特殊的噪声，可以表示为 \(\mathrm{K}=\{\mathrm{a}{0} \mathrm{I}, \mathrm{a}{1} \mathrm{~K}{1}, \ldots, \mathrm{a}{\mathrm{s}} \mathrm{K}{\mathrm{s}}\}\) ，即  \(\mathrm{K}\) 的Kraus算子中一项是单位阵乘以常数 \(a_0\) ，这里 \(\mathrm{a}{i}, i=0,1, \ldots, s\) 都是非负实数，比如，比特翻转噪声，退相位噪声，退极化噪声都属于这种类型的噪声。

\sphinxAtStartPar
\sphinxstylestrong{噪声对损失函数的影响}

\sphinxAtStartPar
  假设输入态是一个纯态 \(\left|\phi_{\text {in }}\right\rangle\) ，经过一个带噪声 \({K}\) 的量子逻辑门 \(\mathrm{U}\) 后，输出态 \(\rho_{\text {out }}\) 可以写为：
\begin{equation*}
\begin{split}\rho_{\text {out }}^{\text {noise }}= (1-p) U |\phi_{\text {in }}\rangle\ \langle\phi_{\text {in }}| \ U^{\dagger}+\sum_{i} U K_{i}|\phi_{\text {in }}\rangle\langle\phi_{\text {in }}|\ K_{i}^{\dagger} U^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  这里定义 \({1}-\mathrm{p}=\mathrm{a}{0}^{2}\)  ， 不带噪声时，理想的输出态是 \(\rho{\text {uut }}^{\text {ideal }}=U\left|\phi_{\text {in }}\right\rangle\left\langle\phi_{\text {in }}\right| U^{\dagger}\) , 所以 \(\rho_{\text {out }}^{\text {noise }}\) 可进一步表示为
\begin{equation*}
\begin{split}\rho_{\text {out }}^{\text {noise }}=(1-p) { \rho }^{\text {ideal }}+\sum_{i} U K_{i}\left|\phi_{\text {in }}\right\rangle\left\langle\phi_{\text {in }}\right| K_{i}^{\dagger} U^{\dagger}\end{split}
\end{equation*}
\sphinxAtStartPar
  可以看到，在 \(\rho_{\text {out }}^{\text {noise }}\) 中， \(\rho_{\text {out }}^{\text {ideal }}\) 所占的比例是 \(1-\mathrm{p}\) 。更进一步的考虑，如果经过一个包含 \(\mathrm{m}\) 个量子逻辑门的量子线路，带噪声的输出态 \(\rho_{\text {out }}^{\text {noise }}\) 与理想输出态 \(\rho_{\text {out }}^{\text {ideal }}\) 的关系为
\begin{equation*}
\begin{split}\rho_{\text {out }}^{\text {noise }}=(1-\mathrm{p})^{m} \rho_{\text {out }}^{\text {ideal }}\end{split}
\end{equation*}
\sphinxAtStartPar
  特别的，比例因子 \(\mathrm{P}=(1-\mathrm{p})^{m}\) 是最坏的情况，对某些特殊的量子态，并不会受到某种噪声的影响，比特 \(|\phi\rangle=|0\rangle\) 不会受到退相位噪声的影响，所以带噪声的输出态 \(\rho_{\text {out }}^{\text {noise }}\) 与理想输出态 \(\rho_{\text {out }}^{\text {ideal }}\) 的关系重新写为
\begin{equation*}
\begin{split}\rho_{\text {out }}^{\text {noise }}=(1-p)^{\alpha m} \rho_{\text {out }}^{\text {ideal }}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\alpha\) 表示一个常数，与量子线路结构和噪声模型相关。

\sphinxAtStartPar
​ 下面开始介绍噪声对QAOA量子线路的影响。在QAOA中，QAOA步数 \(n\) 与QAOA量子线路包含的量子逻辑门数目线性相关，对一个步数为 \(n\) 的QAOA量子线路 \(\mathrm{U}(\vec{\gamma}, \vec{\beta})\) , 如果没有噪声，经过 \(\mathrm{U}(\vec{\gamma}, \vec{\beta})\) 后，输出态为
\begin{equation*}
\begin{split}\left|\phi_{\text {out }}^{\text {ideal }}\right\rangle=\mathrm{U}(\vec{\gamma}, \vec{\beta})\left|\phi_{\text {in }}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  QAOA中，损失函数定义为目标哈密顿量 \(\mathrm{H}_{\mathrm{p}}\) 的期望，在理想情况下，损失函数可表示为
\begin{equation*}
\begin{split}f^{\text {ideal }}(n)=\left\langle\phi_{\text {out }}^{\text {ideal }}\left|H_{p}\right| \phi_{\text {out }}^{\text {ideal }}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  当  \(Q A O A\) 量子线路包含噪声 \(N\) 时，输出态为
\begin{equation*}
\begin{split}\rho_{\text {out }}^{\text {noise }}=(1-p)^{\alpha m}\left|\phi_{\text {out }}^{\text {ideal }}\right\rangle\langle\phi_{\text {out }}^{\text {ideal }}|+\sum_{i} p_{i}| \psi_{i}\rangle\left\langle\psi_{i}\right|\end{split}
\end{equation*}
\sphinxAtStartPar
\(\left|\psi_{\mathrm{i}}\right\rangle\) 是由噪声产生的，每个 \(\left|\psi_{\mathrm{i}}\right\rangle\) 无规律的，另外在实际中，每个 \(\mathrm{p}_{\mathrm{i}}\) 都会很小，满足：
\begin{equation*}
\begin{split}\sum_{i} p_{i}=1-(1-p)^{\alpha n}\end{split}
\end{equation*}
\sphinxAtStartPar
  当量子线路比较复杂时， \(\left|\psi_{\mathrm{i}}\right\rangle\) 个数会很多，求和项 \(\sum_{i} p_{i}\left|\psi_{i}\right\rangle\left\langle\psi_{i}\right|\) 会趋于一个统计平均值。比如，在最大分割问题中，一种有 \(2^{\mathrm{n}}\) 种方案，每条边  \(\mathrm{C}{\mathrm{ij}}\) 会出现 \(2^{\mathrm{n}}\) 次， 所以所有方案的平均结果为 \(\mathrm{A}=-\sum{\mathrm{i}, \mathrm{j}} \frac{c_{i j}}{2}\) , 从而 \(\sum_{i} p_{i}\left|\psi_{i}\right\rangle\left\langle\psi_{i}\right|\) 的统计平均值为 \(\left(1-(1-p)^{\alpha n}\right) \mathrm{A}\) ，从而带噪声的情况下， \(QAOA\) 损失函数可以写为：
\begin{equation*}
\begin{split}f^{\text {noise }}(n)=(1-p)^{a n} f^{\text {ideal }}(n)+\left(1-(1-p)^{a n}\right) \mathrm{A}\end{split}
\end{equation*}
\sphinxAtStartPar
当 \(\mathrm{np}\) 足够小时， \(f^{\text {noise }}(n)\) 可以近似为
\begin{equation*}
\begin{split}f^{\text {noise }}(n) \cong(1-\alpha n p) f^{\text {ideal }}(n)+\alpha n p A\end{split}
\end{equation*}
\sphinxAtStartPar
  从上面的式子，可以发现，噪声并没有改变  \(\mathrm{QAOA}\) 参数空间的整体形状，只是将参数空间磨平，比例因子为 \((1-p)^{\alpha n}\)

\sphinxAtStartPar
\sphinxstylestrong{噪声对损失函数梯度的影响}

\sphinxAtStartPar
  QAOA是一种经典\sphinxhyphen{}量子混合算法，其中参数优化过程是一个经典过程。我可以用典型的经典算法来优化QAOA量子线路的参数，比如Nelder\sphinxhyphen{}Mead算法，Powell算 法， Adagrad算法等。当使用梯度相关的优化算法时，需要计算损失函数的梯度。量子噪声对损失函数有影响，所以也会对损失函数的梯度产生影响。下面描述量 子噪声对损失函数的梯度 会有怎样的影响。

\sphinxAtStartPar
  QAOA量子线路包含两种参数： \(\vec{\gamma}\) 和 \(\vec{\beta}\) ，分别表示问题哈密顿量 \(\mathrm{H}{\mathrm{p}}\) 和驱动哈密顿量 \(\mathrm{H}{\mathrm{d}}\) 的系数， \(\mathrm{QAOA}\) 步数为 \(\mathrm{n}\) 时， \(\vec{\gamma}\) 和  \(\vec{\beta}\) 都是 \(\mathrm{n}\) 维向量。 VQNet中损失函数对 \(\vec{\gamma}\) 和 \(\vec{\beta}\) 的偏导如下式所示
\begin{equation*}
\begin{split}\begin{aligned} &\frac{\partial f(\vec{\gamma}, \vec{\beta})}{\partial \gamma_{k}}=\sum_{i, j}-2 C_{i j} \frac{f(\vec{\gamma}, \vec{\beta})_{k i j}^{+}-f(\vec{\gamma}, \vec{\beta})_{k i j}^{-}}{2} \\ &\frac{\partial f(\vec{\gamma}, \vec{\beta})}{\partial \beta_{k}}=\sum_{i=1}^{\ell}-2 \frac{f(\vec{\gamma}, \vec{\beta})_{k i}^{+}-f(\vec{\gamma}, \vec{\beta})_{k i}^{-}}{2} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  第一个式子中 \(f(\vec{\gamma}, \vec{\beta}){k i j}^{+}\) 表示将  \(Q A O A\) 量子线路中与边  \(C{\mathrm{ij}}\) 关联的参数  \(\gamma_{\mathrm{k}}\) 改变为  \(\gamma_{\mathrm{k}}+\frac{\pi}{2}\) , 别的参数不变, 然后运行量子线路得到的损失函数， \(f(\vec{\gamma}, \vec{\beta}){k i j}^{-}\) 表示将对应 位置的参数 \(\gamma{\mathrm{k}}\) 改变为 \(\gamma{\mathrm{k}}-\frac{\pi}{2}\)  ，别的参数不变，然后运行量子线路得到的损失函数。同理，在第二个式子中， \(f(\vec{\gamma}, \vec{\beta}){k i}^{+}\) 和  \(f(\vec{\gamma}, \vec{\beta}){k i}^{-}\) 分别表示将第 \(\mathrm{i}\) 个比特上面包含  \(\beta_{\mathrm{k}}\) 的量子逻辑门的参数  \(\gamma{\mathrm{k}}\) 改变为  \(\gamma_{\mathrm{k}}+\frac{\pi}{2}\) 和  \(\gamma_{\mathrm{k}}-\frac{\pi}{2}\) ，别的参数不变，运行量子线路得到的损失函数。具体的公式推导可从VQNet文献中得到。

\sphinxAtStartPar
  从上面两个公式，可以看出损失函数的梯度是一系列量子线路参数不同的损失函数的线性组合，从量子噪声对损失函数的影响公式中，可以推出量子噪声对损失函 数梯度的影响如下式所示:
\begin{equation*}
\begin{split}\frac{\partial f(\vec{\gamma}, \vec{\beta})^{\text {noise }}}{\partial \theta_{k}}=(1-p)^{\alpha n} \frac{\partial f(\vec{\gamma}, \vec{\beta})^{\text {ideal }}}{\partial \theta_{k}}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\theta_{\mathrm{k}} \in{\vec{\gamma}, \vec{\beta}}\) ，可以看出，包含噪声的 \(Q A O A\) 量子线路得到的损失函数对线路参数 \(\theta_{\mathrm{k}}\) 的偏导与理想情况下损失函数对线路参数 \(\theta_{\mathrm{k}}\) 的偏导之间成比例，比例因子为 \((1-p)^{a n}\) 。

\sphinxAtStartPar
  随着噪声参数变大，损失函数对参数偏导的绝对值变小, 换句话说，损失函数梯度的绝对值随噪声参数和 \(QAOA\) 步数的增加而变小, 这从另外一个角度说明了噪声 会使 \(\mathrm{QAOA}\) 参数空间变平。另一方面，可以看出噪声不会改变损失函数梯度的方向，所以噪声只会影响 \(\mathrm{QAOA}\) 参数优化过程的优化速度，并不会改变参数优化结果，理论上，当噪声参数 \(p\) 与  \(Q A O A\) 步数  \(n\) 的乘积比较小时，噪声  \(Q A O A\) 优化得到的量子线路参数与理想最优量子线路参数一致。

\sphinxAtStartPar
\sphinxstylestrong{测试示例}

\sphinxAtStartPar
  用QPanda噪声虚拟机和VQNet构建 \(\mathrm{QAQA}\) ，数模模拟几种噪声对 \(\mathrm{QAQA}\) 的影响，来验证上一节提出的模型。

\sphinxAtStartPar
\sphinxstylestrong{最大分割问题选取}

\sphinxAtStartPar
  选择最大分割问题作为测试问题，整个测试过程测试问题是固定的，最大分割问题对应的图如图5.1.1所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{5.1.1}.png}\hspace*{\fill}}

\begin{center}图5.1.1 最大分割图
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{理想结果}

\sphinxAtStartPar
  首先演示理想情况下QAOA对这个问题的执行结果，QAOA步数为 \(n=1 \sim 4\) ，得到的损失函数优化过程如图5.1.2所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.2}.png}\hspace*{\fill}}

\begin{center}图5.1.2 理想QAOA损失函数优化过程
\end{center}
\sphinxAtStartPar
从图5.1.2可以看出，理想情况下，随着QAOA步数的增加，QAOA的性能不断提升，QAOA步数与优化后损失函数的关系如图5.1.3所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.3}.png}\hspace*{\fill}}

\begin{center}图5.1.3 QAOA性能与步数的关系
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{噪声对损失函数的影响}

\sphinxAtStartPar
  首先，测试噪声对QAOA损失函数的影响，选取3中不同的噪声：退相位噪声，比特翻转噪声和退极化噪声。在前面的章节已经介绍过，这三种噪声都包含一个参数  \(\mathrm{p}\) ，选取 \(\mathrm{p}\) 的范围为 \([0.0001,0.02]\) ，很多NISQ装置中这些橾声的参数处于这个区间，另外更关注  \(\mathrm{p}\) 比较小的区间，所以通过如下公式在区间 \([0.0001,0.02]\) 中取11个点:
\begin{equation*}
\begin{split}\mathrm{p}_{\mathrm{i}}=0.0001 * 200^{0.1 \times \mathrm{i}}, \mathrm{i}=0,1,2, \ldots, 10\end{split}
\end{equation*}
\sphinxAtStartPar
  在接下来的测试中，对QAOA的损失函数简单做了变形，  \(Q A O A\) 损失函数是问题哈密顿量  \(\mathrm{H}{\mathrm{p}}\) 的期望，前面的章节已经介绍过，对最大分割问题， \(\mathrm{H}{\mathrm{p}}\) 可表示为
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{p}}=-\sum_{i, j} C_{i j} \frac{1-Z_{i} Z_{j}}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  为便于分析，丟弃  \(\mathrm{H}{\mathrm{p}}\) 中的常数项，并将其变为原来的两倍，这种变化不会对 \(\mathrm{QAOA}\) 的执行产生影响，变换后的 \(\mathrm{H}{\mathrm{p}}^{\prime}\) 可表示为
\begin{equation*}
\begin{split}\mathrm{H}_{\mathrm{p}}^{\prime}=\sum_{i, j} C_{i j} Z_{i} Z_{j}\end{split}
\end{equation*}
\sphinxAtStartPar
  则损失函数为:  \(\mathrm{f}(\vec{\gamma}\) , \(\vec{\beta})=\left\langle\mathrm{H}_{\mathrm{p}}^{\prime}\right\rangle\) 。

\sphinxAtStartPar
  在测试过程中，固定QAOA量子线路的参数，测试损失函数与噪声参数的关系，具体测试结果如图5.1.4所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.4a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.4b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.4c}.png}\hspace*{\fill}}

\begin{center}(c)退极化噪声
\end{center}
\begin{center}图 5.1.4 不同步数下噪声参数与损失函数关系曲线
\end{center}
\sphinxAtStartPar
  定义  \(\mathrm{y}=\frac{\mathrm{f}(\vec{\gamma} \vec{\beta})^{\text {noise}}}{\mathrm{f}(\vec{\gamma} \vec{\beta})^{\text {ideal}}}\) , 根据理论模型可得到 \(\mathrm{y}\) 与噪声参数 \(\mathrm{p}\) 及  \(\mathrm{QAOA}\) 步数  \(\mathrm{n}\) 的关系可表示为
\begin{equation*}
\begin{split}\mathrm{y}=(1-\mathrm{p})^{\alpha \mathrm{n}}\end{split}
\end{equation*}
\sphinxAtStartPar
  用上面的公式对实验数据进行拟合，可以得到3种噪声对应的 3 个常数 \(\alpha\) ；
\begin{equation*}
\begin{split}\begin{aligned} &\alpha_{\text {dephasing }}=16.051 \\ &\alpha_{\text {bitflip }}=16.247 \\ &\alpha_{\text {depolarizing }}=18.846 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\alpha\) 越大，说明对应噪声对  \(Q A O A\) 影响越大，可以看出退极化噪声对  \(Q A O A\) 影响最大。 下面考虑噪声参数  \(\mathrm{p}\) 和  \(\mathrm{QAOA}\) 步数  \(\mathrm{n}\) 比较小的实验数据，选取满足 \(\mathrm{np}<0.02\) 的实验数据，当 \(\mathrm{np}\) 比较小时， \(\mathrm{y} \cong 1-\alpha \mathrm{np}\) ，令  \(\mathrm{x}=\mathrm{np}\) ，得到  \(\mathrm{y}\) 与  \(\mathrm{x}\) 关系如图  \(5.1.5\) 所示，其中 “  \(x\) “点是实验数据，红线是斜率分别等于得到的3个拟合参数的直线，可以看出，当  \(\mathrm{np}\) 比较小时，噪声损失函数与理想损失函数的比特因子  \(\mathrm{y}\) 与  \(\mathrm{np}\) 成线性关系。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.5a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.5b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.5c}.png}\hspace*{\fill}}

\begin{center}(c)退极化噪声
\end{center}
\begin{center}图5.1.5 \(\mathrm{np}\) 比较小的区间噪声对QAOA损失函数的影响
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{噪声对损失函数的影响}

\sphinxAtStartPar
  现在测试噪声对损失函数梯度的影响，噪声对损失函数的影响公式为：
\begin{equation*}
\begin{split}\frac{\partial f(\vec{\gamma}, \vec{\beta})^{\text {noise }}}{\partial \theta_{k}}=(1-p)^{\alpha n} \frac{\partial f(\vec{\gamma}, \vec{\beta})^{\text {ideal }}}{\partial \theta_{k}}\end{split}
\end{equation*}
\sphinxAtStartPar
  在这个测试中，固定 \(QAOA\) 量子线路的参数，测试损失函数对各参数的偏导与噪声参数的关系，  \(\mathrm{QAOA}\) 的步数  \(\mathrm{n}\) 的区间还是  \(1 \sim 4\) ， 噪声参数  \(\mathrm{p}\) 的选择方法与之前的 测试一致。为了减小统计误差，选取理想参数优化过程中梯度最大的量子线路参数序列作为测试参数。损失函数对各 \(\mathrm{QAOA}\) 量子线路参数的偏导与噪声参数的关系 如图5.1.6所示，图中只包含 \(\mathrm{QAOA}\) 步数  \(\mathrm{n}=4\) 的情况， \(\mathrm{n}=1, 2, 3\) 的情况与 \(\mathrm{n}=4\) 的情况类似，所以没有列出。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{5.1.6a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{5.1.6b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{5.1.6c}.png}\hspace*{\fill}}

\begin{center}退极化噪声
\end{center}
\begin{center}(c)图5.1.6 噪声对损失函数梯度的影响
\end{center}
\sphinxAtStartPar
  选取满足如下两个条件的数据: 一个条件还是 \(\mathrm{np}<0.02\) ，另一个条件是 \(\left|\frac{\partial \mathrm{f}(\vec{\gamma} \vec{\beta})}{\partial \theta_{\mathrm{k}}}\right|>C, \theta_{k} \in{\vec{\gamma}, \vec{\beta}} \quad \mathrm{C}\) 是一个常数，在这个测试中选择  \(\mathrm{C}=2.5\) 。 定义
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{y}=\frac{\partial \mathrm{f}{(\vec{\gamma}, \vec{\beta})^{noise}}}{\partial \theta_{\mathrm{k}}} / {\frac{\partial \mathrm{f}(\vec{\gamma}, \vec{\beta})^{\text {ideal }}}{\partial \theta_{\mathrm{k}}}} \\ &\mathrm{x}=\mathrm{np} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  可以得到
\begin{equation*}
\begin{split}y \cong 1-\alpha x\end{split}
\end{equation*}
\sphinxAtStartPar
  将实验数据用上式拟合，拟合图像如图5.1.7所示，得到 3 个常数 \(\alpha\) ：
\begin{equation*}
\begin{split}\alpha_{\text {dephasing }}=15.705, \alpha_{\text {bitflip }}=16.014, \alpha_{\text {depolarizing }}=17.213\end{split}
\end{equation*}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.7a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.7b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.7c}.png}\hspace*{\fill}}

\begin{center}(c)退极化噪声
\end{center}
\begin{center}退极化噪声
\end{center}
\begin{center}图5.1.7 噪声对损失函数梯度的影响数据拟合图像
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{噪声对QAOA的影响}

\sphinxAtStartPar
  接下来测试噪声对QAOA运行过程及运行结果的影响，在不同噪声及不同参数下运行QAOA，得到优化后的QAOA量子线路参数和损失函数。测试的噪声类型及噪声参数区间与之前的测试一致。测试数据如图5.1.8所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.8a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.8b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.8c}.png}\hspace*{\fill}}

\begin{center}(c)退极化噪声
\end{center}
\begin{center}图5.1.8 噪声与QAOA优化损失函数的关系
\end{center}
\sphinxAtStartPar
  首先，分析噪声参数对 \(Q A O A\) 优化后的参数的影响，用欧式空间距离的均方根来描述两组参数的距离 \(\mathrm{d}\) ， 用公式表示如下:
\begin{equation*}
\begin{split}\mathrm{d}=\sqrt{\frac{\left|\vec{\gamma}^{\text {noise }}-\vec{\gamma}^{\text {ideal }}\right|^{2}+\left|\vec{\beta}^{\text {noise }}-\vec{\beta}^{\text {ideal }}\right|^{2}}{2 n}}\end{split}
\end{equation*}
\sphinxAtStartPar
  噪声参数与距离的测试数据如图5.1.9所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=900\sphinxpxdimen]{{5.1.9}.png}\hspace*{\fill}}

\begin{center}图5.1.9. 噪声参数与距离的关系图 (a), (b), (c)分别表示退相位噪声，比特翻转噪声和退极化噪声
\end{center}
\sphinxAtStartPar
  由此发现，当 \(\mathrm{np}\) 比较小时，噪声 \(\mathrm{QAQA}\) 优化后的参数与理想优化参数很接近，两组参数之间的距离主要来源于统计误差和优化算法的截止条件。前面已经得到噪 声会磨平 \(\mathrm{QAQA}\) 参数空间，所以含噪声的 \(\mathrm{QAQA}\) 损失函数娣度会比较小，梯度小的时候计算出来的梯度的相对误差会比较大，所以含噪声的 \(\mathrm{OAOA}\) 在优化到理想最优参数附近时，参数优化方向的可靠性会降低，导致无法优化到最优参数。另外一方面，在测试中，设置优化截止条件为  \(\left|\frac{\ g r a d i e n t}{\mathrm{n}}\right|<\mathrm{C}\) ， \(\mathrm{C}\) 表示一个常数，取  \(\mathrm{C}=0.05\) ，这也是噪声  \(\mathrm{QAQA}\) 优化参数与理葙最优参数产生距离的一个原因。可以预计，当计算损失函数时，运行  \(\mathrm{QAQA}\) 线路的次数  \(\mathrm{M} \rightarrow \infty\) ，优化截止条件中的  \(\mathrm{C} \rightarrow 0\) ， 当  \(\mathrm{np}\) 比较小时，噪声  \(\mathrm{QAOA}\) 优化后的参数与理想优化参数是一样的。

\sphinxAtStartPar
  对满足 \(\mathrm{np}<0.02\) 条件的实验数据进行拟合，与之前的测试一样，定义:
\begin{equation*}
\begin{split}\mathrm{y}=\frac{\mathrm{f}(\vec{\gamma}, \vec{\beta})^{\text {noise }}}{\mathrm{f}(\vec{\gamma}, \vec{\beta})^{i d e a l}}, \mathrm{x}=\mathrm{np}\end{split}
\end{equation*}
\sphinxAtStartPar
  可以得到:
\begin{equation*}
\begin{split}y \cong 1-\alpha x\end{split}
\end{equation*}
\sphinxAtStartPar
  用上面的公式对实验数据进行拟合，可以得到3种噪声对应的3个常数 \(\alpha\) ：
\begin{equation*}
\begin{split}\begin{aligned} &\alpha_{\text {dephasing }}=24.133 \\ &\alpha_{\text {bitflip }}=24.245 \\ &\alpha_{\text {depolarizing }}=28.708 \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  拟合图像如图5.1.10所示，其中“x”点是实验数据，红线是斜率分别等于得到的3个拟合参数的直线，可以看出，当 \(\mathrm{np}\) 比较小时，噪声损失函数与理想损失函数的比特因子 \(\mathrm{y}\) 与 \(\mathrm{np}\) 成线性关系。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.10a}.png}\hspace*{\fill}}

\begin{center}(a)退相位噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.10b}.png}\hspace*{\fill}}

\begin{center}(b)比特翻转噪声
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{5.1.10c}.png}\hspace*{\fill}}

\begin{center}(c)退极化噪声
\end{center}
\begin{center}图5.1.10 噪声对QAOA运行结果的影响数据拟合图像
\end{center}
\sphinxAtStartPar
  另一方面，发现这一节中得到的拟合常数 \(\alpha\) 明显比前两节的拟合常数  \(\alpha\) 大， 原因是噪声  \(Q A O A\) 优化参数与理想  \(Q A O A\) 优化参数之间存在距离，这个距离随着 \(\mathrm{np}\) 的增 加而增加，导致  \(y\) 值随着  \(\mathrm{np}\) 变化的斜率更大，即  \(\alpha\) 更大。

\sphinxAtStartPar
\sphinxstylestrong{总结}

\sphinxAtStartPar
  在这节中，介绍了噪声对NISQ量子算法性能影响的研究进展，讨论了一种特殊的噪声对 \(QAOA\) 的影响，提出了噪声对  \(Q A O A\) 影响的模型，并通过数值模拟验证了模型的正确性，为  \(Q A O A\) 在真实量子芯片上运行提供的参考。 这一研究领域还有很多开放性的问题，比如，本节介绍的方案只适用于一种噪声，即可以表示为 \(\mathrm{K}=\{\mathrm{a}{0} \mathrm{I}, \mathrm{a}{1} \mathrm{~K}{1}, \mathrm{a}{2} \mathrm{~K}{2}, \ldots, \mathrm{a}{s} \mathrm{~K}_{\mathrm{s}}\}\) 的噪声，所以一种任意的噪声对  \(NISQ\) 会有怎样的影响还是一个开放性的问题，另外噪声对别的 \(NISQ\) 算法的影响也是一个开放性的问题。   噪声对NISQ量子算法影响的研究是一个重要的研究方向，可以为  \(\mathrm{NISO}\) 装置，  \(NISQ\) 量子算法提供借鉴作用，需要研究人员不断去探索新的进展。

\sphinxstepscope


\section{5.2 量子机器学习}
\label{\detokenize{rst/5.2_u91cf_u5b50_u673a_u5668_u5b66_u4e60:id1}}\label{\detokenize{rst/5.2_u91cf_u5b50_u673a_u5668_u5b66_u4e60::doc}}
\sphinxAtStartPar
  从《2001：太空漫游》中HAL9000的惊鸿一瞥，到大卫·杰洛德在《When HARLIE Was One》中对何为人类的探讨，再到近年《心理测量者》等对交由AI管理的反乌托邦社会的存在的合理性的思考，半个余世纪以来，伴随着计算机科学的飞速发展，人工智能成为了最引人注目的方向之一。这或许是千百年来人类“造物”畅想和现实最接近的一次。诸多科幻作品中描绘的足以撼动现代文明根基的新一代智慧生命的诞生可能离21世纪还很遥远，但如Siri、Cortana这般具备自我学习功能的程序已经深入到普通人的生活之中。

\sphinxAtStartPar
  而机器学习正是实现人工智能的重要途径，其关注于通过经验自动改进的计算机算法的研究。换言之，我们期冀通过某些算法使计算机“学会”自行分析某一类数据中的规律，并利用获得的规律对未知数据进行预测。常见的机器学习算法可以分为监督学习、无监督学习和强化学习三类。监督学习从给定目标的训练集中学习得到某个函数，并通过函数对未知数据进行预测，本节着重讨论的分类器便是一例。无监督学习与监督学习相比，训练集不进行人为的目标标注，常见的有聚类算法。强化学习同样没有目标标注，而会对输入有着具有延时性的某种奖惩反馈，算法会随着环境的变动而逐步调整其行为，监督学习与无监督学习的数据之间是独立的，而强化学习存在前后依赖关系。Q\sphinxhyphen{}Learning是典型的强化学习算法。

\sphinxAtStartPar
  如前文所言，量子计算机有着不容小觑的并行计算能力，而对于机器学习，强大的算力正是其需要的。这样，两者便有了结合的前提。本书其他章节介绍的变分本征求解器（VQE）、量子近似优化算法（QAOA算法）等便是其中的代表。包括上述在内的诸多目前被广泛讨论的量子机器学习算法都属于量子\sphinxhyphen{}经典混合算法的范畴。令量子计算机处理其擅长的部分，其余工作交给经典计算机，是一个较为现实的方案。

\sphinxAtStartPar
  接下来以监督学习中的分类问题为例进行讨论。

\sphinxAtStartPar
  鸢尾花数据集是机器学习中常用的数据集，由三种各50组鸢尾花样本构成。每个样本包含4个特征，分别为萼片(sepals)及花瓣(petals)的长和宽。我们要做的是从中抽取一部分样本对量子分类器进行训练，学习完成后，将剩余的样本用于分类测试，并期望预测的成功率尽可能高。图5.2.1，介绍了一种算法结构。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=700\sphinxpxdimen]{{5.2.1}.png}\hspace*{\fill}}

\begin{center}图5.2.1  一种算法结构
\end{center}
\sphinxAtStartPar
  1. 将经典的鸢尾花数据 \(X_{i}\) 输入到某个带参数 \(\vec{\theta}\) 的量子线路  \(Q C\) 中，其中  \(\vec{\theta}\) 的初始值为  \(\vec{\theta}\) 。

\sphinxAtStartPar
  2. 经测量操作线路输出向量  \(\vec{a}\) ，通过某个映射  \(g(\vec{a})\) 得到对数据  \(X_{i}\) 的分类预测  \(y_{i}\)  。

\sphinxAtStartPar
  3. 将分类预测  \(y_{i}\) 与训练集中给定的真实分类结果  \(Y_{i}\) 进行对比，并计算损失函数  \(f[y_{i}(\vec{\theta})\) , \(Y_{i}]\) 。

\sphinxAtStartPar
  4. 返回第一步，将剩余的鸢尾花数据  \(X_{i^{'}}\) 依次输入到线路  \(Q C\) 中，得到对应的 \(f[y_{i}(\vec{\theta})\) , \(Y_{i}^{\prime}]\) ，并计算总代价函数  \(\sum_{i \in S e t} f[y_{i}(\vec{\theta})\) , \(Y_{i}] / \mid Set \mid\) 。

\sphinxAtStartPar
  5. 利用经典计算机对代价函数进行最小化，重复更新线路中的参数  \(\theta_{j}(j=1, \ldots , n)\) ，直到优化到截止条件 。

\sphinxAtStartPar
  这个算法的核心在于量子线路  \(Q C\) 的设计，首先我们需要考虑如何将经典数据输入到 \(Q C\) 中。常用的编码方式有两种，分别是编码到线路参数与编码到态振幅上。 对于本题而言，每个样本 \(X_{i}\) 都有4个特征。如果采取第一种方式，我们可以将每个特征分别编码到一个量子比特的初态上。例如图5.2.2：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps459}.jpg}\hspace*{\fill}}

\begin{center}图5.2.2 第一种编码方式
\end{center}
\sphinxAtStartPar
 如果采取第二种编码方式，希望得到量子态：
\begin{equation*}
\begin{split}\left|\varphi\left(X_{i}\right)\right\rangle=X_{i 0}|00\rangle+X_{i 1}|01\rangle+X_{i 2}|10\rangle+X_{i 3}|11\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  显而易见，这种编码方式能更好地节约量子比特。但与此同时，它的制备过程也更加复杂，如图5.2.3：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps461}.jpg}\hspace*{\fill}}

\begin{center}图5.2.3 第二种编码方式
\end{center}
\sphinxAtStartPar
  其中
\begin{equation*}
\begin{split}\begin{aligned} &\theta_{1}=2 \sin ^{-1}\left(\sqrt{X_{i 2}^{2}+X_{i 3}^{2}} / \sqrt{X_{i 0}^{2}+X_{i 1}{ }^{2}+X_{i 2}{ }^{2}+X_{i 3}{ }^{2}}\right) \\ &\theta_{2}=2 \sin ^{-1}\left(X_{i 1} / \sqrt{X_{i 0}^{2}+X_{i 1}^{2}}\right) \\ &\theta_{3}=2 \sin ^{-1}\left(X_{i 3} / \sqrt{X_{i 2}^{2}+X_{i 3}^{2}}\right) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
事实上，对于包含  \(m\) 个特征的数据来说，采用第一种方案我们需要 \(0(m)\) 个量子比特和 \(0(1)\) 的线路深度，采用第二种方案我们需要 \(0(\log m)\) 个量子比特和  \(O(m)\) 的线路深度。

\sphinxAtStartPar
  成功将经典数据编码到量子态后，需要考虑利用已有的量子比特或外加部分辅助比特设计量子线路。在设计线路时要尽快将量子比特纠缠起来。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps470}.jpg}\hspace*{\fill}}

\begin{center}图5.2.4 一种较为常用的线路设计
\end{center}
\sphinxAtStartPar
  图5.2.4是一种较为常用的线路设计。我们知道，所谓的各种量子门，本质上都是对态进行酉变换。（注意：当引入辅助比特时，线路对总的量子态依然进行酉变换 操作，但对于待测量部分的变换末必是酉的。）所以，将经典数据  \(X_{i}\) 编码到初态并利用含参数 \(\vec{\theta}\) 的量子线路进行操作的全过程就是对  \(X_{i}\) 进行了映射，只不过这种 映射与经典函数映射不同，发生在欧式空间与希尔伯特空间之间。但这种映射依然可以理解为一个形如 \(h_{\vec{\theta}}\left(X_{i}\right)\) 的函数，与经典的机器学习类似。 考虑将经典数据  \(X_{i}\) 映射到量子态  \(\left|\psi\left(X_{i}\right)\right\rangle\) 上，经过线路  \(U(\vec{\theta})\) ，在  \({z}\) 方向上进行测量，得到比特串 \(\vec{\ a_{k}}\) 的概率
\begin{equation*}
\begin{split}p_{i k}=\langle\psi\left(X_{i}\right)|\ U^{\dagger}(\vec{\theta}) | a_{k}\rangle\langle a_{k}|U(\vec{\theta})| \psi\left(X_{i}\right)\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  希望每次测量后与真实分类结果 \(Y_{i}\) 对应的  \(\vec{\ a_{a(i)}}\) 中的元素（换言之，任取 \(\vec{a} \in\{\vec{\ a_{a(i)}}\}\) ，满足  \(Y_{i}=g(\vec{a})\) ) 出现的概率尽可能大，这样才能更加准确地进行分类预测。虽然我们很难直接从量子线路中读取到相关的概率分布，但可以通过多次测量，利用 \(\vec{\ a_{k}}\) 出现的频率  \(n_{k} / N\) 对概率  \(p_{i k}\) 进行估计。这样，待办事项转化为对线路重复测量，选取出现总频数 \(N_{j}=\sum_{\vec{\ a_{k}} \in\{\tilde{a_{j}}\}} n_{k}\) 最高的比特串组 \(\{\vec {a_{j}}\}\) ，得到与之对应的分类预测 \(y^{j}\) ，记为  \(y_{i}\) 。 显然，对尚末完成优化过程的分类器而言，其关于样本  \(X_{i}\) 的分类预测  \(y_{i}\) 并不能时常与真实的分类结果  \(Y_{i}\) 对应。可以以如下方式构造损失函数（方法不唯一）：
\begin{equation*}
\begin{split}\text{Loss}(i)=f\left[y_{i}(\vec{\theta}), Y_{i}\right]=p\left(y_{i} \neq Y_{i}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
  设  \(Y_{i}=y^{\alpha(i)}\) ，其余两类分别为  \(y^{\beta(i)}\) 与  \(y^{\gamma(i) \text { }}\) 则
\begin{equation*}
\begin{split}\mathrm{p}\left(y_{i} \neq Y_{i}\right)=\mathrm{p}\left[N_{\alpha(i)}^{i}<\max \left(N_{\beta(i)}^{i}, N_{\gamma(i)}^{i}\right)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  记
\begin{equation*}
\begin{split}N_{i}=N_{\alpha(i)}^{i}+N_{\beta(i)}^{i}+N_{\gamma(i)}^{i}=N_{\alpha(i)}^{i}+2 \max \left(N_{\beta(i)}^{i}, N_{\gamma(i)}^{i}\right)+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|\end{split}
\end{equation*}
\sphinxAtStartPar
  有
\begin{equation*}
\begin{split}\begin{aligned} &\mathrm{p}\left(y_{i} \neq Y_{i}\right)=p\left[N_{\alpha(i)}^{i}<\frac{N_{i}+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|}{3}\right]\\ &=\sum_{j=0}^\frac{N_{i}+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|}{3}\ C_{N_{i}}^{j} p_{i \alpha}{ }^{j}\left(1-p_{i \alpha}\right)^{N_{i}-j} \\ &\approx \int_{-\infty}^{\frac{N_{i}+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|}{3}} \frac{1}{\sqrt{2 \pi N_{i} p_{i \alpha}\left(1-p_{i \alpha}\right)}} e^{-\frac{\left(x-N_{i} p_{i \alpha}\right)^{2}}{2 N_{i} p_{i \alpha}\left(1-p_{i \alpha}\right)}} \mathrm{dx} \\ &=\frac{1}{2}+\frac{1}{2} \text{erf}\left[\frac{N_{i}+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|-3 N_{a(i)}^{i}}{3 \sqrt{2 N_{\alpha(i)}^{i}\left(1-N_{\alpha(i)}^{i} / N_{i}\right)}}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  取一阶近似，
\begin{equation*}
\begin{split}\begin{aligned} &p\left(y_{i} \neq Y_{i}\right) \approx \frac{1}{1+\exp \left[-\frac{4\left(N_{i}+\left|N_{\beta(i)}^{i}-N_{\gamma(i)}^{i}\right|-3 N_{\alpha(i)}^{i}\right)}{3 \sqrt{2 \pi N_{i c}\left(1-N_{\alpha(i)}^{i} / N_{i}\right)}}\right]} \\ &=S\left[\frac{4 \sqrt{2}}{3 \sqrt{\pi}} \sqrt{N_{i}} \frac{\max \left(\left\{N_{i}\right\} \backslash\left\{N_{\alpha(i)}^{i}\right\}\right)-N_{\alpha(i)}^{i}}{\sqrt{N_{\alpha(i)}^{i}\left(N_{i}-N_{\alpha(i)}^{i}\right)}}\right] \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中
\begin{equation*}
\begin{split}S(x)=\frac{1}{1+e^{-x}}\end{split}
\end{equation*}
\sphinxAtStartPar
  为  \(Sigmoid\) 函数，常用于机器学习中。 计算总代价函数
\begin{equation*}
\begin{split}\begin{array}{r} &\text { Cost }=\frac{1}{|\text{Set}|} \sum_{i \in Set} S\left[\frac{4 \sqrt{2}}{3 \sqrt{\pi}} \sqrt{N_{i}} \frac{\max \left(\left\{N_{i}\right\} \backslash\left\{N_{a(i)}^{i}\right\}\right)-N_{\alpha(i)}^{i}}{\sqrt{N_{\alpha(i)}^{i}\left(N_{i}-N_{\alpha(i)}^{i}\right)}}\right] \\ &\approx \frac{1}{|S e t|} \sum_{i \in S e t} S\left[\sqrt{N_{i}} \frac{\max \left(\left\{N_{i}\right\} \backslash\left\{N_{\alpha(i)}^{i}\right\}\right)-N_{\alpha(i)}^{i}}{\sqrt{N_{\alpha(i)}^{i}\left(N_{i}-N_{\alpha(i)}^{i}\right)}}\right] \end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \(N_{i}\) 为某一组参数 \(\vec{\theta}\) 下 ，对样本 \(X_{i}\) 输入到线路后，进行的有效的重复测量次数， \(N_{\alpha(i)}^{i}\) 为测量得到 \(Y_{i}\) 的次数，而 \(\mid Set\mid\) 是数据集的大小。 总代价函数是参数 \(\vec{\theta}\) 与数据集 \(\{X_{i}, Y_{i}\}\) 的函数，利用经典计算机对其采取最小化并不断对参数进行更新，直到优化到截止条件。我们完成了对分类器的训练过程。 当我们需要对新的数据进行预测或测试时，利用参数优化到 \(\vec{\theta}\) 的 \(Q C\) 执行训练过程的前两步即可。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps520}.jpg}\hspace*{\fill}}

\begin{center}图5.2.5 分类器的训练过程
\end{center}
\sphinxAtStartPar
  1. 将待分类的鸢尾花数据 \(X_{i}\) 输入到训练完成的量子线路  \(Q C\) 中，其中  \(\vec{\theta}\) 的值为  \(\vec{\theta^{'}}\) 。

\sphinxAtStartPar
  2. 经测量操作线路输出向量 \(\vec{a}\) ，通过映射  \(g\) 得到对数据  \(X_{i}\) 的分类预测  \(y_{i}\) 。

\sphinxAtStartPar
  实䟠出真知，让我们看看实际效果如何。

\sphinxAtStartPar
  从数据集中随机挑选120组数据进行训练，采取第一类编码方式，利用本节介绍的线路设计方窣，线路深度为4层。优化方法为Powell法。比特串与分类预测的对 应关系如下：

\sphinxAtStartPar
  1.  \(0001、0010、0100、1000\) ：山鸢尾

\sphinxAtStartPar
  2.  \(1110、1101、1011、0111\) : 杂色鸢尾;

\sphinxAtStartPar
  3.  \(0011、0110、1100、1001\)：维吉尼亚鸢尾。

\sphinxAtStartPar
  最终将代价函数优化到0.045，利用剩余30组数据进行测试。结果如图5.2.6。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{5.2.6}.png}\hspace*{\fill}}

\begin{center}图5.2.6 结果
\end{center}
\sphinxAtStartPar
  可见，对于新数据的预测成功率保持在较高的水准，训练过程不存在过拟合的情况。不过同时我们也能看到，杂色鸢尾与维吉尼亚鸢尾之间似乎比其与山鸢尾之间更不易区分。这是否与我们分类器的设计有关？该问题就留待读者朋友自行思考了。（提示：请关注比特串与分类预测的对应关系。）

\sphinxAtStartPar
  本节以机器学习中常见的鸢尾花数据集分类问题为例，介绍了量子分类器的基本模型。但如同经典分类算法一样，实际操作中可能需要考虑核函数构造等更加复杂的问题，囿于篇幅所限，不在这里一一赘述。如果您日后打算更加深入地探究相关问题，请务必牢记，尽管与经典函数有着诸多不同，但量子线路的作用依然是为数据提供了某种映射操作，这是量子分类器能够生效的核心原因。当您希望针对某一问题进行改进时，不妨关注线路映射的空间。

\sphinxAtStartPar
  不止于此，乃至更广阔的量子机器学习迄今依然是一个值得进入的研究领域，一方面，诸如量子分类器、量子生成对抗网络等在内的有价值的算法还在不断涌现，另一方面，仍有许多像“复杂数据集如何映射”的有趣问题尚待解决。这个领域欢迎更多志同道合的朋友共同探索新的进展。

\sphinxAtStartPar
  本节用到的鸢尾花分类器的Python代码示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda}\PYG{n+nn}{.}\PYG{n+nn}{Algorithm}\PYG{n+nn}{.}\PYG{n+nn}{hamiltonian\PYGZus{}simulation} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{3.}\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{minimize}
\PYG{l+m+mf}{4.}\PYG{k+kn}{import} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{datasets} \PYG{k}{as} \PYG{n+nn}{datasets}
\PYG{l+m+mf}{5.}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{l+m+mf}{6.}\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{l+m+mf}{7.}\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{partial}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}\PYG{k}{def} \PYG{n+nf}{initial\PYGZus{}state}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{10.}    \PYG{n}{qcir}\PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{k}{for} \PYG{n}{qubit} \PYG{o+ow}{in} \PYG{n}{qubitlist}\PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{n}{qcir}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{13.}    \PYG{n}{qcir}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{4.3}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{3.6}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{14.}        \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{2.4}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{15.}        \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{5.9}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{16.}        \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{2.4}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{17.}    \PYG{k}{return} \PYG{n}{qcir}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}\PYG{k}{def} \PYG{n+nf}{Uloc}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{theta\PYGZus{}y}\PYG{p}{,} \PYG{n}{theta\PYGZus{}z}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{20.}    \PYG{n}{qcir}\PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{22.}        \PYG{n}{qcir}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{23.}            \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{k}{return} \PYG{n}{qcir}
\PYG{l+m+mf}{25.}
\PYG{l+m+mf}{26.}\PYG{k}{def} \PYG{n+nf}{Uent}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{27.}    \PYG{n}{qcir}\PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{28.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{29.}        \PYG{n}{qcir}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubitlist}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{30.}    \PYG{n}{qcir}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubitlist}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{31.}    \PYG{k}{return} \PYG{n}{qcir}
\PYG{l+m+mf}{32.}
\PYG{l+m+mf}{33.}\PYG{k}{def} \PYG{n+nf}{Meas}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{34.}    \PYG{n}{freq\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{35.}    \PYG{k}{if} \PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{l+m+mf}{36.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{result}\PYG{p}{:}
\PYG{l+m+mf}{37.}            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0001}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0010}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0100}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{38.}                \PYG{n}{freq\PYGZus{}y}\PYG{o}{+}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{39.}    \PYG{k}{if} \PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{40.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{result}\PYG{p}{:}
\PYG{l+m+mf}{41.}            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1110}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1101}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1011}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0111}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{42.}                \PYG{n}{freq\PYGZus{}y}\PYG{o}{+}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{43.}    \PYG{k}{if} \PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
\PYG{l+m+mf}{44.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{result}\PYG{p}{:}
\PYG{l+m+mf}{45.}            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0011}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0110}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1100}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{n}{i} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{46.}                \PYG{n}{freq\PYGZus{}y}\PYG{o}{+}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{47.}    \PYG{k}{return} \PYG{n}{freq\PYGZus{}y}
\PYG{l+m+mf}{48.}
\PYG{l+m+mf}{49.}\PYG{k}{def} \PYG{n+nf}{loss}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{50.}    \PYG{n}{freq\PYGZus{}total} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{51.}    \PYG{n}{freq} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{52.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{53.}        \PYG{n}{freq}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Meas}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{54.}        \PYG{n}{freq\PYGZus{}total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Meas}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
\PYG{l+m+mf}{55.}    \PYG{n}{freq\PYGZus{}without\PYGZus{}y} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{)}
\PYG{l+m+mf}{56.}    \PYG{k}{del} \PYG{n}{freq\PYGZus{}without\PYGZus{}y}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}
\PYG{l+m+mf}{57.}    \PYG{n}{loss\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{freq\PYGZus{}total}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{freq\PYGZus{}without\PYGZus{}y}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{freq}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{freq\PYGZus{}total} \PYG{o}{\PYGZhy{}} \PYG{n}{freq}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{freq}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{58.}    \PYG{k}{return} \PYG{n}{loss\PYGZus{}value}
\PYG{l+m+mf}{59.}
\PYG{l+m+mf}{60.}\PYG{k}{def} \PYG{n+nf}{cost}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{61.}    \PYG{n}{cost\PYGZus{}value}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{62.}    \PYG{n}{theta\PYGZus{}y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{63.}    \PYG{n}{theta\PYGZus{}z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{64.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{65.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{66.}            \PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{*} \PYG{n}{qubit\PYGZus{}num} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{j}\PYG{p}{]}
\PYG{l+m+mf}{67.}            \PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{*} \PYG{n}{qubit\PYGZus{}num} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{68.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{69.}        \PYG{n}{init}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU}\PYG{p}{)}
\PYG{l+m+mf}{70.}        \PYG{n}{qubitlist} \PYG{o}{=} \PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}
\PYG{l+m+mf}{71.}        \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{72.}        \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{initial\PYGZus{}state}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{73.}            \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uloc}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{74.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{depth}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{75.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uent}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{76.}                \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uloc}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{77.}        \PYG{n}{directly\PYGZus{}run}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\PYG{l+m+mf}{78.}        \PYG{n}{result} \PYG{o}{=} \PYG{n}{quick\PYGZus{}measure}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2000}\PYG{p}{)}
\PYG{l+m+mf}{79.}        \PYG{n}{cost\PYGZus{}value} \PYG{o}{+}\PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}
\PYG{l+m+mf}{80.}        \PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{81.}    \PYG{n}{cost\PYGZus{}value} \PYG{o}{/}\PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{82.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cost\PYGZus{}value}\PYG{p}{)}
\PYG{l+m+mf}{83.}    \PYG{k}{return} \PYG{n}{cost\PYGZus{}value}
\PYG{l+m+mf}{84.}
\PYG{l+m+mf}{85.}\PYG{k}{def} \PYG{n+nf}{binding}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{86.}    \PYG{k}{return} \PYG{n}{partial}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{y}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{o}{=}\PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{o}{=}\PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{o}{=}\PYG{n}{label\PYGZus{}class}\PYG{p}{)}
\PYG{l+m+mf}{87.}
\PYG{l+m+mf}{88.}\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{89.}    \PYG{n}{y\PYGZus{}predict} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{90.}    \PYG{n}{theta\PYGZus{}y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{91.}    \PYG{n}{theta\PYGZus{}z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{92.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{depth}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{93.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{94.}            \PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{*} \PYG{n}{qubit\PYGZus{}num} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{j}\PYG{p}{]}
\PYG{l+m+mf}{95.}            \PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{*} \PYG{n}{qubit\PYGZus{}num} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{96.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{97.}        \PYG{n}{init}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU}\PYG{p}{)}
\PYG{l+m+mf}{98.}        \PYG{n}{qubitlist} \PYG{o}{=} \PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}num}\PYG{p}{)}
\PYG{l+m+mf}{99.}        \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{100.}        \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{initial\PYGZus{}state}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{101.}            \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uloc}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,}\PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{102.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{depth}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{103.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uent}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{)}\PYG{p}{)} \PYGZbs{}
\PYG{l+m+mf}{104.}                \PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{Uloc}\PYG{p}{(}\PYG{n}{qubitlist}\PYG{p}{,} \PYG{n}{theta\PYGZus{}y}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta\PYGZus{}z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{105.}        \PYG{n}{directly\PYGZus{}run}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\PYG{l+m+mf}{106.}        \PYG{n}{result} \PYG{o}{=} \PYG{n}{quick\PYGZus{}measure}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qubitlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2000}\PYG{p}{)}
\PYG{l+m+mf}{107.}        \PYG{n}{freq}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{108.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{109.}            \PYG{n}{freq}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Meas}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{110.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{111.}            \PYG{k}{if} \PYG{n}{freq}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{==} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{112.}                \PYG{n}{y\PYGZus{}predict}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}
\PYG{l+m+mf}{113.}                \PYG{k}{break}
\PYG{l+m+mf}{114.}        \PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{115.}    \PYG{k}{return} \PYG{n}{y\PYGZus{}predict}
\PYG{l+m+mf}{116.}
\PYG{l+m+mf}{117.}\PYG{k}{def} \PYG{n+nf}{success\PYGZus{}rate}\PYG{p}{(}\PYG{n}{predict\PYGZus{}Y}\PYG{p}{,} \PYG{n}{test\PYGZus{}Y}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{118.}    \PYG{n}{success}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{119.}    \PYG{n}{fail}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{120.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{predict\PYGZus{}Y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{121.}        \PYG{k}{if} \PYG{p}{(}\PYG{n}{predict\PYGZus{}Y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{test\PYGZus{}Y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{122.}            \PYG{n}{success}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{l+m+mf}{123.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{124.}            \PYG{n}{fail}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{l+m+mf}{125.}    \PYG{k}{return} \PYG{n}{success}\PYG{p}{,}\PYG{n}{fail}
\PYG{l+m+mf}{126.}
\PYG{l+m+mf}{127.}\PYG{k}{def} \PYG{n+nf}{data\PYGZus{}shuffle\PYGZus{}and\PYGZus{}make\PYGZus{}train\PYGZus{}test}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{label}\PYG{p}{,} \PYG{n}{train\PYGZus{}percentage} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{128.}    \PYG{n}{n\PYGZus{}data} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{label}\PYG{p}{)}
\PYG{l+m+mf}{129.}    \PYG{n}{permutation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{130.}    \PYG{n}{n\PYGZus{}train} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{n\PYGZus{}data} \PYG{o}{*} \PYG{n}{train\PYGZus{}percentage}\PYG{p}{)}
\PYG{l+m+mf}{131.}    \PYG{n}{n\PYGZus{}test} \PYG{o}{=} \PYG{n}{n\PYGZus{}data} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}train}
\PYG{l+m+mf}{132.}    \PYG{n}{train\PYGZus{}permutation} \PYG{o}{=} \PYG{n}{permutation}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{n\PYGZus{}train}\PYG{p}{]}
\PYG{l+m+mf}{133.}    \PYG{n}{test\PYGZus{}permutation} \PYG{o}{=} \PYG{n}{permutation}\PYG{p}{[}\PYG{n}{n\PYGZus{}train}\PYG{p}{:}\PYG{p}{]}
\PYG{l+m+mf}{134.}    \PYG{k}{return} \PYG{n}{data}\PYG{p}{[}\PYG{n}{train\PYGZus{}permutation}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{p}{[}\PYG{n}{train\PYGZus{}permutation}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{test\PYGZus{}permutation}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{p}{[}\PYG{n}{test\PYGZus{}permutation}\PYG{p}{]}
\PYG{l+m+mf}{135.}
\PYG{l+m+mf}{136.}\PYG{n}{qubit\PYGZus{}num} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{l+m+mf}{137.}\PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{l+m+mf}{138.}\PYG{n}{label\PYGZus{}class}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{l+m+mf}{139.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{load\PYGZus{}iris}\PYG{p}{(}\PYG{n}{return\PYGZus{}X\PYGZus{}y}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{l+m+mf}{140.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{label}\PYG{p}{,} \PYG{n}{test\PYGZus{}d} \PYG{p}{,} \PYG{n}{test\PYGZus{}l} \PYG{o}{=} \PYG{n}{data\PYGZus{}shuffle\PYGZus{}and\PYGZus{}make\PYGZus{}train\PYGZus{}test}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{label}\PYG{p}{)}
\PYG{l+m+mf}{141.}\PYG{n}{theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{qubit\PYGZus{}num} \PYG{o}{*} \PYG{n}{depth}\PYG{p}{)}
\PYG{l+m+mf}{142.}\PYG{n}{result} \PYG{o}{=} \PYG{n}{minimize}\PYG{p}{(}\PYG{n}{binding}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{label}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{,} \PYG{n}{method} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Powell}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{143.}
\PYG{l+m+mf}{144.}\PYG{n}{y\PYGZus{}predict} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{145.}\PYG{n}{theta} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{x}
\PYG{l+m+mf}{146.}\PYG{n}{y\PYGZus{}predict} \PYG{o}{=} \PYG{n}{test}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,} \PYG{n}{test\PYGZus{}d}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}num}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{label\PYGZus{}class}\PYG{p}{)}
\PYG{l+m+mf}{147.}\PYG{n}{success}\PYG{p}{,} \PYG{n}{fail} \PYG{o}{=} \PYG{n}{success\PYGZus{}rate}\PYG{p}{(}\PYG{n}{y\PYGZus{}predict}\PYG{p}{,} \PYG{n}{test\PYGZus{}l}\PYG{p}{)}
\PYG{l+m+mf}{148.}\PYG{n}{print}\PYG{p}{(}\PYG{n}{test\PYGZus{}l}\PYG{p}{)}
\PYG{l+m+mf}{149.}\PYG{n}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y\PYGZus{}predict}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{150.}\PYG{n}{print}\PYG{p}{(}\PYG{n}{success}\PYG{o}{/}\PYG{p}{(}\PYG{n}{success}\PYG{o}{+}\PYG{n}{fail}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{5.3 使用单振幅和部分振幅量子虚拟机}
\label{\detokenize{rst/5.3_u4f7f_u7528_u5355_u632f_u5e45_u548c_u90e8_u5206_u632f_u5e45_u91cf_u5b50_u865a_u62df_u673a:id1}}\label{\detokenize{rst/5.3_u4f7f_u7528_u5355_u632f_u5e45_u548c_u90e8_u5206_u632f_u5e45_u91cf_u5b50_u865a_u62df_u673a::doc}}

\subsection{5.3.1 单振幅量子虚拟机}
\label{\detokenize{rst/5.3_u4f7f_u7528_u5355_u632f_u5e45_u548c_u90e8_u5206_u632f_u5e45_u91cf_u5b50_u865a_u62df_u673a:id2}}
\sphinxAtStartPar
  目前可以通过量子计算的相关理论，用经典计算机实现模拟量子虚拟机。 量子虚拟机的模拟主要有全振幅与单振幅两种解决方案，其主要区别在于，全振幅一次模拟计算就能算出量子态的所有振幅，单振幅一次模拟计算只能计算出 \(2^N\) 个振幅中的一个。

\sphinxAtStartPar
  然而全振幅模拟量子计算时间较长，计算量随量子比特数指数增长，在现有硬件下，无法模拟超过49量子比特。通过单振幅量子虚拟机技术可以模拟超过49比特，同时模拟速度有较大提升，且算法的计算量不随量子比特数指数提升。

\sphinxAtStartPar
\sphinxstylestrong{使用介绍}

\sphinxAtStartPar
  QPanda2中设计了 SingleAmplitudeQVM 类用于运行单振幅模拟量子计算，同时提供了相关接口，它的使用也很简单。

\sphinxAtStartPar
  首先构建一个单振幅量子虚拟机：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{machine} \PYG{o}{=} \PYG{n}{new} \PYG{n}{SingleAmplitudeQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  然后必须使用 SingleAmplitudeQVM::init() 初始化量子虚拟机环境：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  接着进行量子程序的构建、装载工作：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{auto} \PYG{n}{qlist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{auto} \PYG{n}{clist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}\PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{8.}\PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  最后调用计算接口，设计多种返回值的接口用于满足不同的计算需求，具体见示例所述：

\sphinxAtStartPar
\sphinxstylestrong{实例}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{machine}  \PYG{o}{=} \PYG{n}{new} \PYG{n}{SingleAmplitudeQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{prog}  \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}    \PYG{n}{auto} \PYG{n}{qlist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{n}{auto} \PYG{n}{clist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{prog}  \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{14.}    \PYG{n}{prog}  \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{15.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{16.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{17.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{18.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{19.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{20.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{21.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{22.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}
\PYG{l+m+mf}{23.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}
\PYG{l+m+mf}{24.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{25.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{26.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{27.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{28.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}
\PYG{l+m+mf}{29.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}
\PYG{l+m+mf}{30.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{31.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{32.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{33.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}
\PYG{l+m+mf}{34.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{35.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+m+mf}{36.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}  \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{37.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{38.}
\PYG{l+m+mf}{39.}    \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{40.}    \PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getProbDict}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{41.}    \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{42.}    \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{43.}    \PYG{n}{delete}\PYG{p}{(}\PYG{n}{machine}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{44.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{45.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  getProbDict()接口表示输出计算后的量子态概率，输出结果用map容器保存，key为量子态对应的字符串，value为对应的概率，上述程序的计算结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0}\PYG{l+m+mf}{.00166709}
\PYG{l+m+mf}{2.0}\PYG{l+m+mf}{.00166709}
\end{sphinxVerbatim}

\sphinxAtStartPar
  若使用其他接口：

\sphinxAtStartPar
  · getProbDict(qvec,std::string) ,使用示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QVec} \PYG{n}{qvec}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{qvec}\PYG{o}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getProbDict}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{val} \PYG{p}{:} \PYG{n}{res}\PYG{p}{)}
\PYG{l+m+mf}{6.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{7.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0000000000} \PYG{p}{:} \PYG{l+m+mf}{0.0016671}
\PYG{l+m+mf}{2.0000000001} \PYG{p}{:} \PYG{l+m+mf}{0.0016671}
\PYG{l+m+mf}{3.0000000010} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{4.0000000011} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{5.0000000100} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{6.0000000101} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{7.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
 · pMeasureBinindex(std::string) ,使用示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pMeasureBinindex}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过二进制形式下标测量指定振幅，结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{p}{(}\PYG{l+m+mf}{0.0408301}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.80626e\PYGZhy{}18}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  · pMeasureDecindex(std::string) ,使用示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{PMeasure\PYGZus{}bin\PYGZus{}index}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过十进制形式下标测量指定振幅，结果输出如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0}\PYG{l+m+mf}{.00166709}
\end{sphinxVerbatim}


\subsection{5.3.2 部分振幅量子虚拟机}
\label{\detokenize{rst/5.3_u4f7f_u7528_u5355_u632f_u5e45_u548c_u90e8_u5206_u632f_u5e45_u91cf_u5b50_u865a_u62df_u673a:id3}}
\sphinxAtStartPar
  目前用经典计算机模拟量子虚拟机的主流解决方案有全振幅与单振幅两种。除此之外，还有部分振幅量子虚拟机，该方案能在更低的硬件条件下，实现更高的模拟效率。 部分振幅算法的基本思想是将大比特的量子计算线路图拆分成若干个小比特线路图，具体数量视线路扶持情况而定。

\sphinxAtStartPar
\sphinxstylestrong{使用介绍}

\sphinxAtStartPar
  QPanda2中设计了 PartialAmplitudeQVM 类用于运行部分振幅模拟量子计算，同时提供了相关接口，它的使用很简单。

\sphinxAtStartPar
  首先构建一个部分振幅量子虚拟机:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{machine} \PYG{o}{=} \PYG{n}{new} \PYG{n}{PartialAmplitudeQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  然后必须使用 PartialAmplitudeQVM::init() 初始化量子虚拟机环境:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  接着进行量子程序的构建、装载工作:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{auto} \PYG{n}{qlist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{auto} \PYG{n}{clist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}\PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{8.}\PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  最后调用计算接口，设计多种返回值的接口用于满足不同的计算需求，具体见示例所述：

\sphinxAtStartPar
\sphinxstylestrong{实例}

\sphinxAtStartPar
  以下示例展示了部分振幅量子虚拟机接口的使用方式:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{USING\PYGZus{}QPANDA}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{machine} \PYG{o}{=} \PYG{n}{new} \PYG{n}{PartialAmplitudeQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{10.}    \PYG{n}{auto} \PYG{n}{qlist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{11.}    \PYG{n}{auto} \PYG{n}{clist} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{14.}    \PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{15.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{16.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{17.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{18.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{19.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{20.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{21.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{22.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{23.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{24.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{25.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{26.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{27.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{l+m+mf}{28.}         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CR}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{PI} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{29.}
\PYG{l+m+mf}{30.}    \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{directlyRun}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{31.}    \PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getProbDict}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{32.}    \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000000}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{33.}    \PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{34.}    \PYG{n}{delete}\PYG{p}{(}\PYG{n}{machine}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{35.}    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{36.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  上述程序的计算结果如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.0016671}
\PYG{l+m+mf}{2.} \PYG{l+m+mf}{0.0016671}
\end{sphinxVerbatim}

\sphinxAtStartPar
  若使用其他接口：

\sphinxAtStartPar
  · PMeasure\_bin\_index(std::string) ,使用示例:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{PMeasure}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{val} \PYG{p}{:}\PYG{n}{res}\PYG{p}{)}
\PYG{l+m+mf}{3.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{4.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.00166709}
\end{sphinxVerbatim}

\sphinxAtStartPar
  · getProbDict(qvec,std::string) ,使用示例:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QVec} \PYG{n}{qvec}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{for\PYGZus{}each}\PYG{p}{(}\PYG{n}{qlist}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qlist}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{n}{Qubit} \PYG{o}{*}\PYG{n}{val}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{qvec}\PYG{o}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getProbDict}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{val} \PYG{p}{:} \PYG{n}{res}\PYG{p}{)}
\PYG{l+m+mf}{6.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{7.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{val}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0000000000} \PYG{p}{:} \PYG{l+m+mf}{0.0016671}
\PYG{l+m+mf}{2.0000000001} \PYG{p}{:} \PYG{l+m+mf}{0.0016671}
\PYG{l+m+mf}{3.0000000010} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{4.0000000011} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{5.0000000100} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\PYG{l+m+mf}{6.0000000101} \PYG{p}{:} \PYG{l+m+mf}{0.000286029}
\end{sphinxVerbatim}

\sphinxAtStartPar
  · pmeasure\_bin\_index(std::string) ,使用示例:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pmeasure\PYGZus{}bin\PYGZus{}index}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0000000001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过二进制形式下标测量指定振幅，结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{p}{(}\PYG{l+m+mf}{0.0408301}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.80626e\PYGZhy{}18}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
  · pmeasure\_dec\_index(std::string) ,使用示例:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{auto} \PYG{n}{res} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pmeasure\PYGZus{}dec\PYGZus{}index}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  通过十进制形式下标测量指定振幅，结果输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.33681e\PYGZhy{}18}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0408301}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{5.4 将量子程序编译到不同的量子芯片上}
\label{\detokenize{rst/5.4_u5c06_u91cf_u5b50_u7a0b_u5e8f_u7f16_u8bd1_u5230_u4e0d_u540c_u7684_u91cf_u5b50_u82af_u7247_u4e0a:id1}}\label{\detokenize{rst/5.4_u5c06_u91cf_u5b50_u7a0b_u5e8f_u7f16_u8bd1_u5230_u4e0d_u540c_u7684_u91cf_u5b50_u82af_u7247_u4e0a::doc}}
\sphinxAtStartPar
  任何的量子程序，最终是要放到量子计算机中去运行的。和量子虚拟机相比，在量子计算机中运行有几个重要的区别：

\sphinxAtStartPar
\sphinxstylestrong{支持的逻辑门}

\sphinxAtStartPar
  量子芯片中往往不一定允许执行所有的酉变换，对于单比特门来说，通常只支持一个子集。由于这个定理: 任何的两个不同方向的旋转 \({U}{\bar{x}}(\theta)=e^{i \vec{\sigma x} \theta}\) 和  \(\mathrm{U}{\bar{y}}(\theta)=e^{i \vec{\sigma} \bar{y} \theta}\) ， 一定能通过依次施加不同角度的旋转操作，构成任何的单比特上的酉变换。因此，量子计算机中若支持两个方向的旋转操作， 即可实现任意的单门。

\sphinxAtStartPar
  QPanda中提供了一个配置量子计算机中支持逻辑门的方式。通过配置，可以将任意的量子程序编译到支持的量子逻辑门中。

\sphinxAtStartPar
\sphinxstylestrong{量子芯片拓扑结构}

\sphinxAtStartPar
  编写量子程序，或者设计量子算法时，往往在任意两个比特之间都有可能出现逻辑门的连接。然而，对于实际的量子芯片，有可能这种连接关系是受限的。例如量子比特在芯片上以网格式排列，只有最近邻（nearest neighbor）的量子比特之间才允许进行操作。那么，对于原有的量子程序，我们必须将所有不支持操作的量子逻辑门进行变换，或者对量子比特进行重新映射。

\sphinxAtStartPar
  QPanda中提供了一个配置量子芯片拓扑结构的方式。

\sphinxAtStartPar
  指令集

\sphinxAtStartPar
  量子指令集是由各公司定义的量子计算机控制指令集，它适配于量子软件开发包，一般可以用于直接控制该公司的量子计算机。QPanda中通用的量子程序表示方式是QProg类，它提供的是一种对量子程序的抽象通用表述形式。QPanda提供一系列函数，将QProg类映射到不同的量子指令集上，包括QRunes，QASM，Quil……

\sphinxAtStartPar
  配置支持的逻辑门

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}    \PYG{o}{\PYGZlt{}}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rx}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Ry}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RZ}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{S}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{7.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{H}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{8.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{X1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{9.}     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{10.}     \PYG{o}{\PYGZlt{}}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{11.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CNOT}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{12.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CZ}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{13.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate}  \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ISWAP}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{14.}     \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{15.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  在QPanda中，指令集的配置是通过QPandaConfig.xml中QGate元素来配置的。

\sphinxAtStartPar
  QGate中的元素介绍：

\sphinxAtStartPar
  SingleGate: 单量子逻辑门配置，是QGate的子元素

\sphinxAtStartPar
  DoubleGate: 双量子逻辑门配置， 是QGate的子元素

\sphinxAtStartPar
  Gate: 内容配置支持的量子逻辑门，属性time配置量子逻辑门的时钟周期，是DoubleGate和SingleGate的子元素。

\sphinxAtStartPar
  示例：一个量子芯片支持单门RX、RY和双门CNOT，RX、RY的时钟周期均为2，CNOT的时钟周期为5。下面我们就配置这个量子芯片支持的逻辑门。

\sphinxAtStartPar
  首先，打开QPandaConfig.xml文件，找到QGate元素，可以看到QGate元素的子元素SingleGate和DoubleGate，并删除SingleGate和DoubleGate元素中所有的内容。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}        \PYG{o}{\PYGZlt{}}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}        \PYG{o}{\PYGZlt{}}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  然后，分别向SingleGate和DoubleGate 元素中添加Gate元素（Gate元素的内容为量子逻辑门，属性值time为逻辑门的时钟周期）。在SingleGate元素中添加两个Gate子元素，属性time均为2，内容分别为RX、RY。在DoubleGate元素中添加一个Gate子元素，属性time为5，内容为CNOT。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}        \PYG{o}{\PYGZlt{}}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}        \PYG{o}{\PYGZlt{}}\PYG{n}{Gate} \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RX}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}            \PYG{o}{\PYGZlt{}}\PYG{n}{Gate} \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RY}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{SingleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.}        \PYG{o}{\PYGZlt{}}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{7.}            \PYG{o}{\PYGZlt{}}\PYG{n}{Gate} \PYG{n}{time} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CNOT}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Gate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{8.}        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{DoubleGate}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{9.} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QGate}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  配置量子芯片拓扑结构

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}      \PYG{o}{\PYGZlt{}}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}          \PYG{o}{\PYGZlt{}}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}              \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{7.}               \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{8.}               \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{9.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{10.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{11.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{12.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{13.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{14.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{15.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{16.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{17.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{18.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{19.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{20.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{21.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{22.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{23.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{24.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{25.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{26.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{27.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{28.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{29.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{30.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{31.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{32.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{33.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{34.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{35.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{36.}                \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{37.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{38.}                  \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{39.}                \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{40.}          \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{41.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  在QPanda中，量子芯片拓扑结构是通过QPandaConfig.xml中Metadata元素来配置的。

\sphinxAtStartPar
\sphinxstylestrong{Metadata中的元素介绍}

\sphinxAtStartPar
  QubitCount：量子比特的个数，是metadata的子元素。

\sphinxAtStartPar
  QubitMatrix：量子比特拓扑图，是metadata的子元素。

\sphinxAtStartPar
  Qubit：量子比特配置，属性QubitNum表示量子比特序号，是QubitMatrix的子元素。

\sphinxAtStartPar
  AdjacentQubit：内容是边的权重，属性QubitNum是指与其父元素Qubit连接的量子比特序号。

\sphinxAtStartPar
  例如图5.4.1，将下面的量子拓扑结构配置到QPandaConfig.xml中，圆圈表示量子比特，圆圈里的值表示量子比特序号，线条表示是否连接，线条上数值的值表示权重。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{5.4.1}.png}\hspace*{\fill}}

\begin{center}图5.4.1 将量子拓扑结构配置到QPandaConfig.xml中
\end{center}
\sphinxAtStartPar
  首先，找到Metadata元素，并删除其QubitMatrix中的所有内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}    \PYG{o}{\PYGZlt{}}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZlt{}}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  然后， 根据拓扑图向QPandaConfig.xml中添加配置。先配置量子比特的个数。例子中的量子比特个数为4个：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}    \PYG{o}{\PYGZlt{}}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZlt{}}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  再配置拓扑结构，添加第一个量子比特的拓扑配置，在QubitMatrix下添加Qubit子元素，其属性QubitNum的值为1，第一个量子比特与第二个量子比特和第三个量子比特连接，其权重都是1，所以Qubit会有两个AdjacentQubit子元素，第一个AdjacentQubit元素的属性QubitNum的值是2，第二个AdjacentQubit元素的属性QubitNum的值是3，其内容都是1，将第一个量子比特的拓扑配置添加到配置中：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}    \PYG{o}{\PYGZlt{}}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZlt{}}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}    \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{7.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{8.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{9.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
  以此类推，将后面的几个量子比特拓扑结构添加到配置中：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZlt{}}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{2.}    \PYG{o}{\PYGZlt{}}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{4}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitCount}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZlt{}}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{4.}     \PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{5.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{6.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{7.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{8.}\PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{9.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{10.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{11.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{12.}\PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{13.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{14.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{15.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{16.}\PYG{o}{\PYGZlt{}}\PYG{n}{Qubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{17.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{18.}        \PYG{o}{\PYGZlt{}}\PYG{n}{AdjacentQubit} \PYG{n}{QubitNum} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AdjacentQubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{19.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Qubit}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{20.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{QubitMatrix}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mf}{21.}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Metadata}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{转换到不同的指令集}

\sphinxAtStartPar
  将量子程序编译到不同的量子芯片实际上就是可以将量子程序编译成的量子芯片对应的指令集，QPanda2当前支持将量子程序编译成QUIL指令集、IBM的QASM指令集、本源量子的QRunes指令集。

\sphinxAtStartPar
  QUIL指令集是采用“指令+参数列表的设计方法”，一个简单的例子如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{X} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{2.}\PYG{n}{Y} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{3.}\PYG{n}{CNOT} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{4.}\PYG{n}{H} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{5.}\PYG{n}{RX}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.141593}\PYG{p}{)} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{6.}\PYG{n}{MEASURE} \PYG{l+m+mi}{1} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
  QASM具有C和汇编语言的元素，语句用分号分隔，忽略空格，同时语言是区分大小写的。注释以一对前斜线开始，并以新的行结束。一个简单的QASM指令集如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{OPENQASM} \PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{include} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{qelib1.inc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{qreg} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{creg} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{5.}
\PYG{l+m+mf}{6.}\PYG{n}{x} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{7.}\PYG{n}{h} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{n}{tdg} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{9.}\PYG{n}{sdg} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{10.}\PYG{n}{cx} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{11.}\PYG{n}{cx} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{12.}\PYG{n}{u1}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{)} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{13.}\PYG{n}{u2}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{pi}\PYG{p}{)} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{14.}\PYG{n}{u3}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{pi}\PYG{p}{)} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{15.}\PYG{n}{cz} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{16.}\PYG{n}{ccx} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{17.}\PYG{n}{cu3}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{pi}\PYG{p}{)} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{18.}\PYG{n}{measure} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{19.}\PYG{n}{measure} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  如何利用QPanda2将量子程序转化为想要的指令集呢？可以使用下面的方法，首先利用QPanda2构建一个量子程序：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{QProg} \PYG{n}{prog}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{auto} \PYG{n}{qubits} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{auto} \PYG{n}{cbits}  \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}\PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{X}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{6.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{Y}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{7.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{8.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{RX}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{3.14}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{Measure}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cbits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  然后调用QPanda2的工具接口，完成转换，比如转化为QUIL指令集可以调用下面的接口：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string} \PYG{n}{instructions} \PYG{o}{=} \PYG{n}{convert\PYGZus{}qprog\PYGZus{}to\PYGZus{}quil}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{qvm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  得到转化后的QUIL指令集：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{X} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{2.}\PYG{n}{Y} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{3.}\PYG{n}{H} \PYG{l+m+mi}{2}
\PYG{l+m+mf}{4.}\PYG{n}{RX}\PYG{p}{(}\PYG{l+m+mf}{3.140000}\PYG{p}{)} \PYG{l+m+mi}{3}
\PYG{l+m+mf}{5.}\PYG{n}{MEASURE} \PYG{l+m+mi}{0} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
  转化为QASM指令集与转化为QUIL指令集的方法类似，可以调用下面的接口：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string} \PYG{n}{instructions} \PYG{o}{=} \PYG{n}{convert\PYGZus{}qprog\PYGZus{}to\PYGZus{}qasm}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{qvm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
  得到转化后的QASM指令集：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{openqasm} \PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{l+m+mf}{2.}\PYG{n}{qreg}  \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{creg} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{4.}\PYG{n}{x} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{5.}\PYG{n}{y} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{6.}\PYG{n}{h} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{7.}\PYG{n}{rx}\PYG{p}{(}\PYG{l+m+mf}{3.140000}\PYG{p}{)}  \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{l+m+mf}{8.}\PYG{n}{measure} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstepscope


\section{1.1 概述}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id1}}\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401::doc}}
\sphinxAtStartPar
  对于不具有任何高等数学基础背景的读者，本节将从集合与映射、向量空间、矩阵与矩阵的运算、矩阵的特征、矩阵的函数以及线性算子与矩阵表示等相对简单易懂的数学开始讲起，以便各位循序渐进理解量子计算的数学原理。


\section{1.2 集合与映射}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id2}}

\subsection{1.2.1 集合的概念}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id3}}
\sphinxAtStartPar
  当提到中国古代四大发明时，大家一般会想到造纸术、印刷术、指南针和火药；当提到中国的四大名著时，大家会想起吴承恩的《西游记》、罗贯中的《三国演义》、曹雪芹的《红楼梦》、施耐庵的《水浒传》。生活中有很多类似于四大发明、四大名著的称呼，比如：世界上的所有国家、彩虹的颜色、三原色等等，这些称呼都有一个共同的特点，就是将具有明确地相同特性的事物放在一起的统称。

\sphinxAtStartPar
  在数学上，把具有某种特征事物的总体称为集合（set）,组成该集合的事物称为该集合的元素（element）{[}1,5{]}。比如，中国的四大名著，就可以称为一个集合，《西游记》则是其中的一个元素。有时为了方便与简洁，在数学上会引进一些符号来表示一些数学名称，这就使得数学上了一个台阶，当通过练习知道这些符号代表的内在含义时，就很方便地去推导以及交流。

\sphinxAtStartPar
  但是这种符号表示的简化也为后来学习者或多或少带来了一些障碍。因为当没有介绍过某个概念，突然看到一个符号表示，智力再好也不可能知道它代表的含义。比如世界上第一个人发明“※”表示太阳，但他没有告诉你，这符号“※”表示太阳,而是给你画出这个符号“※”，问你这是什么时，这个问题换着任何人都不可能回答，除非是发明者，因为只有他一个人知道这个符号代表的含义，当人们都开始用这个符号“※”表示太阳时，这就极大地方便人们之间的交流，因为这符号写起来相对简单些。如果过仅有部分人知道，还可以作为密码来使用，从某种意义上来说，数学也是一门符号化的语言。所以，在学习数学的时候，首先要弄明白符号背后的含义是什么。

\sphinxAtStartPar
  下面，引进大写的拉丁字母A、B、C等符号来表示集合，用小写的拉丁字母a、b、c等符号表示集合的元素，需要注意的是有的时候拉丁字母不够多或者不方便时，也会引进其他的符号表示元素。比如用B这个符号表示四大名著，用 \(b_1\) 表示《西游记》、 \(b_2\) 表示《三国演义》、 \(b_3\) 表示《红楼梦》、 \(b_4\) 表示《水浒传》。 \(b_1\) 是B的元素，在数学上，通常说 \(b_1\) 属于B，记做 \({b_1} \in B\) 。假设，h表示《海底两万里》，h就不是集合B的元素，就说h不属于B，记做 \({h} \notin B\) 。

\sphinxAtStartPar
  像四大名著这样的集合有有限个元素，称为有限集；也可以通过列举法来表示这个集合。例如，可以将C的元素一一列举出来写在大括号里面
\begin{equation*}
\begin{split}C=\left\{c_{1}, c_{2}, c_{3}, c_{4}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  如果遇到像自然数集（自然数组成的集合）有无限多个元素该如何来表示呢？通常称有无限多个元素的集合为无限集，好在自然数集有了0和1，其他的数就都知道了；也可以通过列举法来列举出有限个，其余的用省略号代替。自然数集 \(N\) 用列举法表示为
\begin{equation*}
\begin{split}N=\{0,1,2, \cdots, n, \cdots\}\end{split}
\end{equation*}
\sphinxAtStartPar
  同样地，用列举法可以表示正整数集（所有正整数组成的集合）
\begin{equation*}
\begin{split}N^{+}=\{1,2,3, \cdots, n, \cdots\}\end{split}
\end{equation*}
\sphinxAtStartPar
  整数集（所有整数组成的集合）
\begin{equation*}
\begin{split}Z=\{\cdots,-n, \cdots, -2,-1,0,1,2, \cdots, n, \cdots\}\end{split}
\end{equation*}
\sphinxAtStartPar
  那像有理数集（所有有理数组成的集合）就不能用列举法来表示了，因为任意两个有理数之间一定还存在有理数（比如这两个有理数之间的中间值）。将有理数的性质描述出来写在大括号中：
\begin{equation*}
\begin{split}Q=\left\{q \mid q=\frac{m}{n}, m \in Z, n \in N^{+} \text {且 } m, n \text { 互质 }\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  这种将用元素具有的性质来表示的方法叫描述法。若集合 \(A\) 由具有某种性质 \(\Gamma\) 的元素 \(a\) 组成，则描述法的一般形式为
\begin{equation*}
\begin{split}A=\{a \mid a \text { 具有性质 } \Gamma\}\end{split}
\end{equation*}
\sphinxAtStartPar
  同样地，可以用描述法来表示无理数集
\begin{equation*}
\begin{split}P=\left\{p \mid p \neq \frac{m}{n}, \forall m \in Z, \forall n \in N^{+} \text {且 } m, n \text { 互质 }\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中符号 \(\forall\) 表示任意的。

\sphinxAtStartPar
​  同时，也可以用自然语言描述法来描述集合，比如，实数集R是所有有理数和无理数组成的集合。

\sphinxAtStartPar
​  在量子计算中常常会用到复数集
\begin{equation*}
\begin{split}C=\left\{c \mid c=a+b i, a, b \in R, i^{2}=-1\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  其中 \({c}= {a}+ {bi}\) 表示复数（complex number）,实部 \(a\) 和虚部 \(b\) 都是实数， \(i\) 在这里表示一个符号并且满足 \(i^{2}=-1\) 。 有时，用有序数对 \((a,b)\) 来表示复数 \({a}+b {i}\) 。

\sphinxAtStartPar
  两个复数 \(c_{1}=a_{1}+b_{1} i\) 和 \(c_{2}=a_{2}+b_{2} i\) 相等的充要条件是实部和虚部分别对应相等，即
\begin{equation*}
\begin{split}c_{1}=c_{2} \Leftrightarrow a_{1}=a_{2}, b_{1}=b_{2}\end{split}
\end{equation*}
\sphinxAtStartPar
​  两个复数 \(c_{1}=a_{1}+b_{1} i\) 和 \(c_{2}=a_{2}+b_{2} i\) 做和相当于实部和虚部分别对应做和，即
\begin{equation*}
\begin{split}c_{1}+c_{2}=\left(a_{1}+a_{2}\right)+\left(b_{1}+b_{2}\right) i\end{split}
\end{equation*}
\sphinxAtStartPar
​  两个复数 \(c_{1}=a_{1}+b_{1} i\) 和 \(c_{2}=a_{2}+b_{2} i\) 做差相当于实部和虚部分别对应做差，即
\begin{equation*}
\begin{split}c_{1}-c_{2}=\left(a_{1}-a_{2}\right)+\left(b_{1}-b_{2}\right) i\end{split}
\end{equation*}
\sphinxAtStartPar
  两个复数 \(c_{1}=a_{1}+b_{1} i\) 和 \(c_{2}=a_{2}+b_{2} i\) 乘法被定义为
\begin{equation*}
\begin{split}\begin{aligned} &c_{1} c_{2}=\left(a_{1}+b_{1} i\right)\left(a_{2}+b_{2} i\right) \\ &=a_{1}\left(a_{2}+b_{2} i\right)+b_{1} i\left(a_{2}+b_{2} i\right) \\ &=a_{1} a_{2}+a_{1} b_{2} i+b_{1} i a_{2}+b_{1} i b_{2} i \\ &=a_{1} a_{2}+a_{1} b_{2} i+b_{1} a_{2} i+b_{1} b_{2} i^{2} \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  因为 \(i^{2}=-1\) ，因此
\begin{equation*}
\begin{split}\left(a_{1}+b_{1} i\right)\left(a_{2}+b_{2} i\right)=\left(a_{1} a_{2}-b_{1} b_{2}\right)+\left(a_{1} b_{2}+b_{1} a_{2}\right) i\end{split}
\end{equation*}
\sphinxAtStartPar
  比如
\begin{equation*}
\begin{split}\begin{aligned} &(1-2 i)(-3+4 i)=1 \cdot(-3+4 i)+(-2 i)(-3+4 i) \\ &=1 \cdot(-3)+1 \cdot 4 i+(-2 i) \cdot(-3)+(-2 i) \cdot(4 i) \\ &=-3+4 i+6 i+8 \\ &=5+10 i \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
  在给出两个复数除法的定义之前，先定义复数 \(c=a+b i\) 的复共轭（complex conjugate）为
\begin{equation*}
\begin{split}\bar{c}=a-b i\end{split}
\end{equation*}
\sphinxAtStartPar
  或
\begin{equation*}
\begin{split}c^{*}=a-b i\end{split}
\end{equation*}
\sphinxAtStartPar
  由复数的乘法，可知
\begin{equation*}
\begin{split}c \bar{c}=(a+b i)(a-b i)=a^{2}+b^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
  那么根据复共轭的定义，两个复数） \(c_{1}=a_{1}+b_{1} i\) 和 \(c_{2}=a_{2}+b_{2} i\) 除法被定义为
\begin{equation*}
\begin{split}\frac{c_{1}}{c_{2}}=\frac{c_{1} \bar{c}_{2}}{c_{2} \bar{c}_{2}}=\frac{\left(a_{1}+b_{1} i\right)\left(a_{2}-b_{2} i\right)}{\left(a_{2}+b_{2} i\right)\left(a_{2}-b_{2} i\right)}=\frac{\left(a_{1} a_{2}+b_{1} b_{2}\right)+\left(b_{1} a_{2}-a_{1} b_{2}\right) i}{a_{2}^{2}+b_{2}^{2}}\end{split}
\end{equation*}
\sphinxAtStartPar
  比如，将 \(\frac{1+2 i}{3-4 i}\) 写成 \(a+b i\) 的形式为
\begin{equation*}
\begin{split}\frac{1+2 i}{3-4 i}=\frac{1+2 i}{3-4 i} \cdot \frac{3+4 i}{3+4 i}=\frac{-5+10 i}{3^{2}+4^{2}}=-\frac{1}{5}+\frac{2}{5} i\end{split}
\end{equation*}

\subsection{1.2.2 集合的关系}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id4}}
\sphinxAtStartPar
​  把集合看成一个对象，那么集合之间有什么关系呢？集合是由元素组成，因此还要从元素进行分析。

\sphinxAtStartPar
​  假设有两个集合 \(S_{1}\) 和 \(S_{2}\) ，如果集合 \(S_{1}\) 的元素都是集合 \(S_{2}\) 的元素，那么称 \(S_{1}\) 是 \(S_{2}\) 的子集，记作 \(S_{1} \subseteq S_{2}\) （读作 \(S_{1}\) 包含于 \(S_{2}\) ）或 \(S_{2} \supseteq S_{1}\) （读作 \(S_{2}\) 包含 \(S_{1}\) ）。比如无理数集就是实数集的子集，因为无理数集中的每一个元素都在实数集中。

\sphinxAtStartPar
​  如果两个集合中的元素都相同，那么称这两个集合相等，即是说，如果集合 \(S_{1}\) 与集合 \(S_{2}\) 互为子集，那么就称集合 \(S_{1}\) 与 \(S_{2}\) 相等,记作 \(S_{1}=S_{2}\) 。例如，偶数集 \(S_{1}\) 与集合 \(S_{2}=\{n \mid n % m=0, m \in Z, n \in Z, m=2\}\) 相等。注：这里的\%表示取余运算（取余运算是指n除以m得到的余数）。

\sphinxAtStartPar
​  如果 \(S_{1} \subseteq S_{2}\) 且 \(S_{1} \neq S_{2}\) ，那么称 \(S_{1}\) 是 \(S_{2}\) 的真子集，记作 \(S_{1} \subset S_{2}\) （读作 \(S_{1}\) 真包含于 \(S_{2}\) ）或 \(S_{1} \subset S_{2}\) （读作 \(S_{2}\) 真包含 \(S_{1}\) ）。比如， \(Q \subset R\) 。

\sphinxAtStartPar
  通常，没有元素的集合称为空集，记作 \(\varnothing\) 。比如，由既是有理数又是无理数的实数为元素组成的集合。


\subsection{1.2.3 集合的运算}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id5}}
\sphinxAtStartPar
​  类似于数的运算，集合也有运算规则。由于集合是具有共同特征事物的全体，因此会用到将两个集合  \(S_{1}\) 与  \(S_{2}\) 共同的部分提取出来，这就是取两个集合的交集。换句话说，由所有既属于  \(S_{1}\) 又属于  \(S_{2}\) 的元素组成的集合称为  \(S_{1}\) 与  \(S_{2}\) 的交集（简称交），记作  \(S_{1} \cap S_{2}\) 。用描述法表示为
\begin{equation*}
\begin{split}S_{1} \cap S_{2}=\left\{\mathrm{s} \mid \mathrm{s} \in S_{1} \text { 且 } \mathrm{s} \in S_{2}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  比如，有理集  \(Q\) 与无理数集  \(P\) 的交集，  \(Q \cap P=\varnothing\) .

\sphinxAtStartPar
  由所有属于  \(S_{1}\) 或者属于  \(S_{2}\) 的元素组成的集合称为  \(S_{1}\) 与  \(S_{2}\) 的并集 (简称并)，记作  \(S_{1} \cup S_{2}\) ，即
\begin{equation*}
\begin{split}S_{1} \cup S_{2}=\left\{s \mid s \in S_{1} \text { 或 } s \in S_{2}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  比如，有理集  \(Q\) 与无理数集  \(P\) 的并集
\begin{equation*}
\begin{split}Q \cup P=\mathrm{R}\end{split}
\end{equation*}
\sphinxAtStartPar
  由所有属于  \(S_{1}\) 而不属于  \(S_{2}\) 的元素组成的集合称为  \(S_{1}\) 与  \(S_{2}\) 的差集 (简称差)，记作  \(S_{1} \backslash S_{2}\) ，即
\begin{equation*}
\begin{split}S_{1} \backslash S_{2}=\left\{s \mid s \in S_{1} \text { 且 } s \notin S_{2}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
  比如，有理集  \(Q\) 与无理数集  \(P\) 的差集
\begin{equation*}
\begin{split}Q \backslash P=Q\end{split}
\end{equation*}
\sphinxAtStartPar
  差集的一种特殊情况：当  \(S_{1}\) 为所研究问题的最大集合时，所要研究的其他集合  \(S_{2}\) 都是  \(S_{1}\) 的子集，称集合  \(S_{1}\) 为全集，称  \(S_{1} \backslash S_{2}\) 为  \(S_{2}\) 的补集或余集，记作  \(S_{2}^{c}\) 。

\sphinxAtStartPar
  比如，在复数集  \(C\) 中，实数集  \(R\) 的补集为
\begin{equation*}
\begin{split}R^{c}=\{x \mid x=a+b \cdot i, a \in R, b \in R \text { 且 } b \neq 0\}\end{split}
\end{equation*}
\sphinxAtStartPar
​  除了集合之间的交、并和差运算之外, 还有一种常用的生成新集合的方式\sphinxhyphen{}直积或笛卡尔 (Descartes) 积。设  \(X\) 、 \(Y`\) 是任意两个集合, 在集合X中任意取一个元素  \(x\) , 在集合Y中任意取一个元素y, 组成一个有序对  \((\mathrm{x}, \mathrm{y})\) ，再把这样大的有序对作为新的元素，它们全体组成集合称为集合  \(\mathrm{X}\) 与集合  \(\mathrm{Y}\) 的直积，记作  \(X \times Y\) , 即
\begin{equation*}
\begin{split}X \times Y=\{(x, y) \mid x \in X \text { 且 } y \in Y\}\end{split}
\end{equation*}
\sphinxAtStartPar
  比如，  \(C \times C=\{(x, y) \mid x \in C\) , \(y \in C}\` 为复平面上全体点的集合，  :math:`C \times C\) 常记为  \(C^{2}\) 。


\subsection{1.2.4 集合的运算法则}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id6}}
\sphinxAtStartPar
​  类似于数的运算法则，集合也有自己的运算法则。集合的交、并和补运算满足以下法则。

\sphinxAtStartPar
假设有任意的三个集合  \(X\) 、 \(Y\) 、 \(Z\) ， 则有以下法则：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
\sphinxAtStartPar
交换律  \(X \cup Y=Y \cup X\) ,  \(\quad X \cap Y=Y \cap X\) ;

\item {} 
\sphinxAtStartPar
结合律  \((X \cup Y) \cup Z=X \cup(Y \cup Z)\) , \((X \cap Y) \cap Z=X \cap(Y \cap Z)\) ;

\item {} 
\sphinxAtStartPar
分配律  \((X \cup Y) \cap Z=(X \cap Z) \cup(Y \cap Z)\) ， \((X \cap Y) \cup Z=(X \cup Z) \cap(Y \cup Z)\) ;

\item {} 
\sphinxAtStartPar
对偶律  \((X \cup Y)^{c}=X^{c} \cap Y^{c}\) , \((X \cap Y)^{c}=X^{c} \cup Y^{c}\) .

\end{enumerate}

\sphinxAtStartPar
  若对这些规则的证明感兴趣, 可以通过集合相等的定义来证明。


\subsection{1.2.5 映射}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78401:id7}}
\sphinxAtStartPar
​  上面讲述了集合, 然而有的集合之间并不是完全孤立的，而是有对应关系的。比如，中国四大名著的作者组成的集合A与四大名著B之间存在对应关系。

\sphinxAtStartPar
​  ​将这种普遍的共性抽象出来，设 \(D\) 、 \(E\) 是两个非空集合，如果存在一个对应法则  \(\mathrm{f}\) , 使得对  \(\mathrm{D}\) 中每个元素  \(x\) , 按照对应法则  \(f\) , 在E中有唯一确定的元素  \(y\) 与  \(x\) 对应，则称 \(f\) 为从  \(D\) 到 \(E\) 的映射  \([1, 3]\), 记作
\begin{equation*}
\begin{split}f: D \rightarrow E\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中y称为元素  \(x\) 在映射  \(f\) 下的像，并记作  \(f(x)\) ，即  \(y=f(x)\) ，

\sphinxAtStartPar
​  而元素 \(x\) 称为元素 \(y\) 在映射 \(f\) 下的一个原像; 集合 \(D\) 为映射的定义域；集合E称为映射的陪域;  \(D\) 中所有元素的像所组成的集合称为映射的值域，记作  \(R_{f}\) 或  \(f(D)\) ，即
\begin{equation*}
\begin{split}R_{f}=f(D)=\{f(x) \mid x \in D\}=\{y \in E \mid \exists x \in D, f(x)=y\}\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中符号 \(\exists\) 表示存在，可以看出，f的值域是f的陪域的子集。

\sphinxAtStartPar
​  集合D到自身一个映射，通常称为D上的一个变换。集合D到数集E的一个映射，常称为从D到E的函数。

\sphinxAtStartPar
​  如果映射f与映射g的定义域、陪域、对应法则分别对应相同，那么称这两个映射相等。

\sphinxAtStartPar
​  映射 \(f: D \rightarrow D\) ​如果把D中每一个元素对应到它自身，即
\begin{quote}

\sphinxAtStartPar
\(\forall x \in D\) ，有 \(f(x)=x\) ，
\end{quote}

\sphinxAtStartPar
​  那么称f为恒等映射（或D上的恒等变换），记作 \(I_{D}\) 。

\sphinxAtStartPar
​  先后施行映射 \(g: \mathrm{S}{1} \rightarrow S{2}\) 和 \(f: S_{2} \rightarrow S_{3}\) ，得到 \(S_{1}\) 到 \(S_{3}\) 的一个映射，称为 \(f\) 与 \(g\) 的合成（或乘积），记作 \(fg\) 。即
\begin{equation*}
\begin{split}(f g)(x) \equiv f(g(x)), \forall x \in S_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
​  定理 映射的乘法适合结合律。即如果
\begin{equation*}
\begin{split}h: S_{1} \rightarrow S_{2}, g: \mathrm{S}_{2} \rightarrow S_{3}, f: S_{3} \rightarrow S_{4}\end{split}
\end{equation*}
\sphinxAtStartPar
​  那么
\begin{equation*}
\begin{split}f(g h)=(f g) h\end{split}
\end{equation*}
\sphinxstepscope


\section{1.3 向量空间}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78402:id1}}\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78402::doc}}
\sphinxAtStartPar
​  学习量子计算，要对量子力学有所了解，而量子力学是由希尔伯特空间来描述的，希尔伯特空间又是向量空间，因此首先要来介绍向量空间（vector spaces）{[}2,4,6,8{]}。

\sphinxAtStartPar
​  向量空间本质上是一个由向量组成的集合，然后引进一些运算规则。那什么是向量呢？向量相对数量来说的，数量是只有大小的量，而向量不仅有大小而且还有方向的量。有时，向量也称为矢量。可以认为向量是数量的一个自然的扩充。

\sphinxAtStartPar
​  假设有一个数域 \(K\) （集合  \(K\) 中任意两个元素的和、差、积、商（除数不为0）还属于集合 \(K\) ，称该集合为数域 \(K\) ），自然想到用直积将数域 \(K\) 进行扩充，n个数域 \(K\) 的直积可以表示为
\begin{equation*}
\begin{split}K^{n}=\left\{\left(v_{1}, v_{2}, \cdots, v_{n}\right) \mid v_{i} \in K, i=1,2, \cdots, n\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中  \(K^{n}\) 元素  \(\left(v_{1}, v_{2}, \cdots, v_{n}\right)\) 称为  \(n\) 维向量，称  \(v_{i}\) 为其第  \(i\) 个分量。为了表示方便与统一将带小括号的元素  \(\left(v_{1}, v_{2}, \cdots, v_{n}\right)\) 记作列向量, 即:
\begin{equation*}
\begin{split}\left(v_{1}, v_{2}, \cdots, v_{n}\right):=\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  在数学上，向量常用加粗的小写拉丁字母  \sphinxstylestrong{a, b, c, ……} 或者带箭头的小写拉丁字母  \(\vec{a}, \vec{b},\vec{c},\ldots\) 来表示。而在量子物理上，常用带有狄拉克符号  \((|*\rangle)\) 的字母  \(|a\rangle\) , \(|b\rangle\) , \(|c\rangle\) , \(\ldots\) 来表示。这里统一采用带有狄拉克符号的表示方法，即:
\begin{equation*}
\begin{split}|v\rangle:=\left(v_{1}, v_{2}, \cdots, v_{n}\right):=\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  两个向量  \(| {u}\rangle\) 、 \(| {v}\rangle\) 相等的定义为向量的分量分别对应相等，即：
\begin{equation*}
\begin{split}|u\rangle=|v\rangle \Leftrightarrow\left[\begin{array}{c} u_{1} \\ u_{2} \\ \vdots \\ u_{n} \end{array}\right]=\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right] \Leftrightarrow u_{1}=v_{1}, u_{2}=v_{2}, \cdots, u_{n}=v_{n}\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中  \(\Longleftrightarrow\) 表示”等价于”。 规定  \(K^{n}\) 中任意两向量  \(|u\rangle\) 、 \(|v\rangle\) 的加法运算为两向量对应分量分别做普通加法，即：
\begin{equation*}
\begin{split}|u\rangle+|v\rangle=\left[\begin{array}{c} u_{1} \\ u_{2} \\ \vdots \\ u_{n} \end{array}\right]+\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right]:=\left[\begin{array}{c} u_{1}+v_{1} \\ u_{2}+v_{2} \\ \vdots \\ u_{n}+v_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
  规定数量  \(k \in K\) 与向量  \(|u\rangle \in K^{n}\) 之间的数乘运算为数量 \(k`与  :math:`|u\rangle\) 的每一个分量分别做普通乘法，即：
\begin{equation*}
\begin{split}k|u\rangle:=\left[\begin{array}{c} k u_{1} \\ k u_{2} \\ \vdots \\ k u_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  设  \(V \equiv K^{n}\) ， 根据数域的性质，可以验证，对任意的  \(| {u}\rangle\) , \(| {v}\rangle\) , \(| {w}\rangle \in V\) ，任意的  \(\alpha, \beta \in K\) 满足以下运算法 则

\sphinxAtStartPar
  (1) \(| {u}\rangle+| {v}\rangle=| {v}\rangle+| {u}\rangle\) ；（加法交换律）

\sphinxAtStartPar
  (2) \((|u\rangle+|v\rangle)+|w\rangle=|u\rangle+(|v\rangle+|w\rangle)\) ; (加法结合律)

\sphinxAtStartPar
  (3) \(\mathrm{V}\) 中有一个元素  \((0,0, \cdots, 0)\) ，记作  \(|\hat{0}\rangle\) .它满足
\begin{equation*}
\begin{split}|\hat{0}\rangle+|v\rangle=|v\rangle+|\hat{0}\rangle=|v\rangle, \forall|v\rangle \in V\end{split}
\end{equation*}
\sphinxAtStartPar
​具有该性质的元素  \(|\hat{0}\rangle\) 称为V的零向量 (zero\sphinxhyphen{}vector) ;

\sphinxAtStartPar
  (4) 对于  \(|v\rangle \in V\) 存在  \(\quad|\bar{v}\rangle:=\left[\begin{array}{c}-v_{1} \ -v_{2} \ \vdots \ -v_{n}\end{array}\right] \in V\) , 使得
\begin{equation*}
\begin{split}|v\rangle+|\bar{v}\rangle=|\hat{0}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​具有该性质的元素  \(|\bar{v}\rangle\) 称为  \(|v\rangle\) 的负向量 (inverse)；

\sphinxAtStartPar
  (5)  \(1|v\rangle=|v\rangle\) , 其中 1 是  \(K\) 的单位元;

\sphinxAtStartPar
  (6)  \((\alpha \beta)|v\rangle=\alpha(\beta|v\rangle)\) ;

\sphinxAtStartPar
  (7)  \((\alpha+\beta)|v\rangle=\alpha| {v}\rangle+\beta|v\rangle\) ;

\sphinxAtStartPar
  (8)  \(\alpha(|u\rangle+|v\rangle)=\alpha|u\rangle+\alpha|v\rangle\) 。

\sphinxAtStartPar
​  数域 \(K\) 上所有n元有序数组组成的集合  \(K^{n}\) ，再加上定义在其上的加法运算和数乘运算，以及满足的 8 条运算法则一起，称为数域 \(K\) 上的一个n维向量空间。 在 \(V\) 中，可以根据向量的加法运算来定义向量的减法运算为
\begin{equation*}
\begin{split}|u\rangle-|v\rangle:=|u\rangle+|\bar{v}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  在 \(V\) 上，定义加法运算和数乘运算之后，满足的8条运算法则可以推导出向量空间的一些其他性质：

\sphinxAtStartPar
  性质1:  \(V\) 中零向量是唯一的。

\sphinxAtStartPar
  性质2:  \(V\) 中每个向量  \(\alpha\) 的负向量是唯一的。

\sphinxAtStartPar
  性质3:  \(0|v\rangle=|0\rangle, \forall|v\rangle \in V\) 。

\sphinxAtStartPar
  性质4:  \(\alpha|0\rangle=|0\rangle, \forall \alpha \in K\) 。

\sphinxAtStartPar
  性质5: 如果  \(\alpha|v\rangle=|0\rangle\) ，那么  \(\alpha=0\) 或  \(|v\rangle=|0\rangle\) 。

\sphinxAtStartPar
  性质6:  \((-1)|v\rangle=-|v\rangle, \forall|v\rangle \in V\) 。

\sphinxAtStartPar
​若  \(K^{n}\) 的一个非空子集  \(U\) 满足以下两条性质：

\sphinxAtStartPar
  (1)  \(| {u}\rangle,| {v}\rangle \in U \Rightarrow| {u}\rangle+| {v}\rangle \in U\) ,

\sphinxAtStartPar
  (2)  \(| {u}\rangle \in U, k \in K \Rightarrow k| {u}\rangle \in U\) ,

\sphinxAtStartPar
​  则称  \(U\) 为  \(K^{n}\) 的一个线性子空间，简称为子空间 (subspace)。


\subsection{1.3.1 线性无关与基}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78402:id2}}
\sphinxAtStartPar
​  若想研究数域 \(K\) 上向量空间V的结构特征，根据向量空间的定义，只能从V的向量的加法以及数乘这两种运算开始。对于V中的一组向量  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) ，数域 \(K\) 中的一组元素  \(\{\alpha_{1}, \alpha_{2}, \cdots, \alpha_{s}\}\) ，作数乘和加法得到
\begin{equation*}
\begin{split}\alpha_{1}|v_{1}\rangle+\alpha_{2}|v_{2}\rangle+\cdots+\alpha_{s}|v_{s}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  根据V中加法和数乘的封闭性，  \(\alpha_{1}|v_{1}\rangle+\alpha_{2}|v_{2}\rangle+\cdots+\alpha_{s}|v_{s}\rangle\) 还是V中的一个向量, 称该向量是  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 一个线性组合 (linear combination)，  \(\{\alpha_{1}, \alpha_{2}, \cdots, \alpha_{s}\}\) 称为系数。 为了方便，像  \(\{\alpha_{1}, \alpha_{2}, \cdots, \alpha_{s}\}\) 这样按照一定顺序写出的有限多个向量称为  \(V\) 的一个向量组。 如果 V中的一个向量  \(| {u}\rangle\) 可以表示成向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 的一个线性组合, 即：
\begin{equation*}
\begin{split}|u\rangle=\sum_{i=1}^{s} \alpha_{i}|v_{i}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  那么称  \(| {u}\rangle\) 可以由向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 线性表示(或线性表出)。 若向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 中至少存在一个向量可以由除自身外的其他向量线性表示, 则称这组向量线性相关 (linearly dependent)。否则, 向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 中任意一个向量都不可以由其他向量线性表示，则称这组向量线性无关 (linearly independent)。 若向量空间V中的任意向量都可以由向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{s}\rangle\}\) 线性表示, 则称该向量组为向量空间 V的生成集 (spanning set)。 线性无关的生成集称为极小生成集。向量空间的极小生成集定义为向量空间的基，极小生成集中向量的个数定义为向量空间的维数。比如，当数域  \(K\) 为复数域   \(C\) 时，向量空间  \(C^{2}\) 的基为由向量
\begin{equation*}
\begin{split}\left|b_{1}\right\rangle:=\left[\begin{array}{l} 1 \\ 0 \end{array}\right], \quad\left|b_{2}\right\rangle=\left[\begin{array}{l} 0 \\ 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​组成的集合。因为向量空间  \(C^{2}\) 中的任意向量
\begin{equation*}
\begin{split}|u\rangle=\left[\begin{array}{l}u_{1} \\u_{2}\end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  都可以写成向量组  \(\{|b_{1}\rangle\,|b_{2}\rangle\}\) 的线性组合，即：
\begin{equation*}
\begin{split}|u\rangle=u_{1}\left|b_{1}\right\rangle+u_{2}\left|b_{2}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  并且向量组  \(\{|b_{1}\rangle,|b_{2}\rangle\}\) 线性无关。

\sphinxAtStartPar
​​  因此，当知道向量空间的基时，就可以来用它们来线性表示该向量空间中的任意的向量。也可以说这组基张成了这个向量空间。

\sphinxAtStartPar
​  然而需要注意的是向量空间的基并不唯一。比如，一组向量
\begin{equation*}
\begin{split}\left|b_{1}\right\rangle:=\frac{1}{\sqrt{2}}\left[\begin{array}{l}1 \\1\end{array}\right],\left|b_{2}\right\rangle=\frac{1}{\sqrt{2}}\left[\begin{array}{c}1 \\-1\end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  就可以作为向量空间  \(C^{2}\) 的另一组基。因为向量空间  \(C^{2}\) 中的任意向量
\begin{equation*}
\begin{split}|u\rangle=\left[\begin{array}{l} u_{1} \\ u_{2} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  可以写成  \(\left|b_{1}\right\rangle\) 与  \(\left|b_{2}\right\rangle\) 的线性组合
\begin{equation*}
\begin{split}|u\rangle=\frac{u_{1}+u_{2}}{\sqrt{2}}\left|b_{1}\right\rangle+\frac{u_{1}-u_{2}}{\sqrt{2}}\left|b_{2}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  假设给定  \(n\) 维向量空间  \(V\) 的基  \(\{|b_{1}\rangle,|b_{2}\rangle, \cdots,|b_{n}\rangle\}\) 和任意向量  \(|u\rangle\) , 该向量都可以由该基线性表示，即
\begin{equation*}
\begin{split}|u\rangle=\alpha_{1}\left|b_{1}\right\rangle+\alpha_{2}\left|b_{2}\right\rangle+\cdots+\alpha_{n}\left|b_{n}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  将  \(|u\rangle\) 在该基  \(\{|b_{1}\rangle,|b_{2}\rangle, \cdots,|b_{n}\rangle\}\) 下的系数称为  \(|u\rangle\) 在该基下的坐标表示, 可以写成列向量的形式，即
\begin{equation*}
\begin{split}|u\rangle=\left[\begin{array}{c} \alpha_{1} \\ \alpha_{2} \\ \vdots \\ \alpha_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  从二维复向量空间的例子可以看出，同一个向量在不同的基下有着不同的坐标表示。

\sphinxAtStartPar
​   \sphinxstylestrong{定理}  在  \(\mathrm{n}\) 维向量空间中， 给定一个基, 向量空间中的任意向量的坐标表示是唯一的。 证明设  \(\{|b_{1}\rangle,|b_{2}\rangle, \cdots,|b_{n}\rangle\}\) 为n维向量空间的一个基，根据基的定义，任意向量  \(|u\rangle\) 都可以由这组基线性表示，即
\begin{equation*}
\begin{split}|u\rangle=\alpha_{1}\left|b_{1}\right\rangle+\alpha_{2}\left|b_{2}\right\rangle+\cdots+\alpha_{n}\left|b_{n}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  假设  \(| {u}\rangle\) 在该基下的坐标表示是不唯一的，因此，存在另一种线性表示方式，即：
\begin{equation*}
\begin{split}|u\rangle=\bar{\alpha}_{1}\left|b_{1}\right\rangle+\bar{\alpha}_{2}\left|b_{2}\right\rangle+\cdots+\bar{\alpha}_{n}\left|b_{n}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  将这两个不同的坐标表示的向量做差，得到
\begin{equation*}
\begin{split}|u\rangle-|u\rangle=\left(\alpha_{1}-\bar{\alpha}_{1}\right)\left|b_{1}\right\rangle+\left(\alpha_{2}-\bar{\alpha}_{2}\right)\left|b_{2}\right\rangle+\cdots+\left(\alpha_{n}-\bar{\alpha}_{n}\right)\left|b_{n}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
  即
\begin{equation*}
\begin{split}|\hat{0}\rangle=\left(\alpha_{1}-\bar{\alpha}_{1}\right)\left|b_{1}\right\rangle+\left(\alpha_{2}-\bar{\alpha}_{2}\right)\left|b_{2}\right\rangle+\cdots+\left(\alpha_{n}-\bar{\alpha}_{n}\right)\left|b_{n}\right\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  因为基是线性无关的，所以有
\begin{equation*}
\begin{split}\alpha_{i}-\bar{\alpha}_{i}=0, i=1,2, \cdots, n\end{split}
\end{equation*}
\sphinxAtStartPar
​  即：
\begin{equation*}
\begin{split}\alpha_{i}=\bar{\alpha}_{i}, i=1,2, \cdots, n\end{split}
\end{equation*}
\sphinxAtStartPar
​  从而假设不成立，因此在给定基下，任意给定向量的坐标表示唯一。


\subsection{1.3.2 向量的内积}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78402:id3}}
\sphinxAtStartPar
​  向量的内积是一个从向量空间  \(V \times V\) 到数域 \(K\) 的一个映射  \((-,-)\) , 并满足以下性质:

\sphinxAtStartPar
​  1、映射  \((-,-)\) 对第二项是线性的，即：
\begin{equation*}
\begin{split}\left(|u\rangle, \sum_{i} \lambda_{i}\left|v_{i}\right\rangle\right)=\sum_{i} \lambda_{i}\left(|u\rangle,\left|v_{i}\right\rangle\right)\end{split}
\end{equation*}
\sphinxAtStartPar
​  2、交换共轭性，即：
\begin{equation*}
\begin{split}(|u\rangle,|v\rangle)=(|v\rangle,|u\rangle)^{*}\end{split}
\end{equation*}
\sphinxAtStartPar
​  3、自内积非负性，即：
\begin{equation*}
\begin{split}(|v\rangle,|v\rangle) \geq 0\end{split}
\end{equation*}
\sphinxAtStartPar
​  等号成立当且仅当  \(|v\rangle\) 为零向量  \(|\hat{0}\rangle\) 。 比如，在  \(\mathrm{n}\) 维复向量空间中，定义内积为
\begin{equation*}
\begin{split}(|u\rangle,|v\rangle):=\sum_{i} u_{i}^{*} v_{i}\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中
\begin{equation*}
\begin{split}|u\rangle=\left[\begin{array}{c} u_{1} \\ u_{2} \\ \vdots \\ u_{n} \end{array}\right],|v\rangle=\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  在量子力学中，内积  \((|u\rangle,|v\rangle)\) 的标准符号为  \(\langle u \mid v\rangle\) ，即：
\begin{equation*}
\begin{split}\langle u \mid v\rangle :=(|u\rangle,|v\rangle)\end{split}
\end{equation*}
\sphinxAtStartPar
​  这里  \(| {u}\rangle,| {v}\rangle\) 均为内积空间中的向量，符号  \(\langle u|\) 表示向量  \(| {u}\rangle\) 的对偶向量 (dual vector)，
\begin{equation*}
\begin{split}\langle u|:=\left[u_{1}^{*}, u_{2}^{*}, \cdots, u_{n}^{*}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​​  将拥有内积的空间称为内积空间（inner product space）。量子力学中常提到希尔伯特空间（Hilbert space），在有限维的情况下，希尔伯特空间与内积空间是一致的。无限维的情况，这里不加考虑。

\sphinxAtStartPar
​  若向量  \(| {u}\rangle\) 和向量  \(| {v}\rangle\) 的内积为 0 ，则称这两个向量正交 (orthogonal) 。比如，向量  \(| {u}\rangle \equiv(1, 0),|v\rangle \equiv(0, 1)\) ， 根据上面复向量空间内积的定义，可得  \(\langle u \mid v\rangle=1 \times 0+0 \times 1=0\) 故  \(| {u}\rangle\) , \(| {v}\rangle\) 两向量正交。 向量  \(|v\rangle\) 的模 (norm) 定义为
\begin{equation*}
\begin{split}\|| v\rangle \|:=\sqrt{\langle v \mid v\rangle}\end{split}
\end{equation*}
\sphinxAtStartPar
​  若向量  \(| {v}\rangle\) 满足  \(| v\rangle |=1\) ，则称该向量为单位向量 (unit vector) 或归一化的 (normalized)。对于任意非零向量  \(| {u}\rangle\) ，可以通过将该向量除以它的范数得到其归一化形式，即：
\begin{equation*}
\begin{split}\frac{\left|v\right\rangle}{\mid\mid\left|v\right\rangle \mid\mid}\end{split}
\end{equation*}
\sphinxAtStartPar
​  设  \(\left|b_{1}\right\rangle,\left|b_{2}\right\rangle, \cdots,\left|b_{n}\right\rangle\) 为向量空间的一组基，满足每一个向量都是单位向量, 并且不同向量的内积为 0 , 即：
\begin{equation*}
\begin{split}\left\langle b_{i} \mid b_{j}\right\rangle= \begin{cases}1, & i=j \\ 0, & i \neq j\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
​  则称这组向量为向量空间的标准正交 (orthonormal) 基。 标准正交基能带来很多方便，比如在计算向量的内积时，就可以将向量的坐标对应相乘。 假设知道向量空间的一个非标准正交基  \(\left|u_{1}\right\rangle,\left|u_{2}\right\rangle, \cdots,\left|u_{n}\right\rangle\) ，那么，可以通过Gram\sphinxhyphen{}Schmidt正交化来将非标准正交基转化为标准正交基。具体过程如下， 用向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{n}\rangle\}\) 来表示待生成的标准正交基, 首先定义
\begin{equation*}
\begin{split}\left|v_{1}\right\rangle:=\frac{\left|u_{1}\right\rangle}{\mid\mid\left|u_{1}\right\rangle \mid\mid}\end{split}
\end{equation*}
\sphinxAtStartPar
​  接着对  \(1 \leq k \leq n-1\) ， 递归地计算并定义
\begin{equation*}
\begin{split}\left|v_{k+1}\right\rangle:=\frac{\left|u_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i}\left| \langle u_{k-1}\right| \mid v_{i}\right\rangle}{\|\left|u_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i} \mid u_{k-1}\right\rangle\left|v_{i}\right\rangle \|}\end{split}
\end{equation*}
\sphinxAtStartPar
​  在量子计算中，通常，用一组带有指标 \(i\) 的向量 \(\mid i\rangle\) 来表示标准正交基。

\sphinxstepscope


\section{1.4 矩阵与矩阵的运算}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78403:id1}}\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78403::doc}}
\sphinxAtStartPar
​  事实上，当提到矩阵时，并不陌生，只是在平时不把它叫做矩阵而已，而通常称作表。比如，一个班级有35名同学，这学期要修6门课程，在本学期期末考试后，为了便于管理和分析，老师将每位同学的各科成绩放在一起，做成一个35行，6列的表。在日常生活或在其他学科中有很多类似的表，将它们的特点进行提取，进而形成数学上的矩阵这样的抽象概念。其实这样的抽象过程也并不陌生，比如自然数的发明就是这样的一个过程。


\subsection{1.4.1 矩阵的概念}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78403:id2}}
\sphinxAtStartPar
​  定义 \(1.4.1\)  由  \(m \cdot n\) 个数排成  \(m\) 行、  \(n\) 列的一张表称为一个  \(m \times n\) 矩阵{[}3{]}，其中的每一个数称为这个矩阵的一个元素，第  \(i\) 行与第  \(j\) 列交叉位置的元素称 为矩阵的  \((i, j)\) 元。

\sphinxAtStartPar
​  如  \(\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}\quad\) 或   \(\left(\begin{array}{lll}1 & 2 & 3 \\ 4 & 5 & 6\end{array}\right)\) 都是一个矩阵。 矩阵通常用大写英文字母  \(A\) , \(B\) , \(C\) , \(\ldots\) 表示。一个  \(m \times n\) 矩阵可以简单地记作  \(A_{m m}\) ，它的  \((i, j)\) 元记作  \(A(i, j)\) 。如果矩阵  \(A\) 的  \((i, j)\) 元是  \(a_{i j}\) ，那么可以记作 \(A=\left[a_{i j}\right]\) 或  \(A=\left(a_{i j}\right)\) 。 如果某个矩阵  \(A\) 的行数与列数相等, 则称之为方阵。  \(m\) 行  \(m\) 列的方阵也称为  \(m\) 级矩阵。 元素全为 0 的矩阵称为零矩阵，简记作  \(0\) 。 \(m\) 行  \(n\) 列的零矩阵可以记成  \(0_{n \times n}\) 。 数域  \(G\) 上两个矩阵称为相等，如果它们的行数相等，列数也相等，并且它们所有元素对应相等（即第一个矩阵的  \((i, j)\) 元等于第二个矩阵的  \((i, j)\) 元） 。

\sphinxAtStartPar
​  定义 \(1.4.2\)  设矩阵  \(A=\left(a_{i j}\right){m \times n}\) , 若矩阵  \(B=\left(b{i j}\right){n \times m}\) 满足  \(a{i j}=b_{j i}\) ，则称矩阵  \(B\) 为矩阵  \(A\) 的转置，将其记作  \(A^{T}\) 或  \(A^{\prime}\) 。一个矩阵  \(A\) 如果满足  \(A=A^{T}\) , 那么称  \(A\) 是对称矩阵。

\sphinxAtStartPar
​  定义 \(1.4.3\)  设  \({n}\) 级矩阵  \(A=\left(a_{i j}\right){n \times n}\) ，称  \(T=\sum{i=1}^{n} a_{i i}\) 为矩阵  \(A\) 的迹，记作  \(\text{tr}(A)\) 。 可以验证矩阵的迹有如下性质:
\begin{equation*}
\begin{split}\begin{aligned}&1_{\circ} \text{tr}(A B)=\text{tr}(B A) \\&2_{\circ} \text{tr}(A+B)=\text{tr}(A)+\text{tr}(B)\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
​  由矩阵  \(A\) 的若干行、若干列的交叉位置元素按原来顺序排列成的矩阵称为  \(A\) 的一个子矩阵。

\sphinxAtStartPar
​  定义 \(1.4.4\)   把一个矩阵  \(A\) 的行分成若干组, 列也分成若干组，从而  \(A\) 被分成若干个子矩阵，把  \(A\) 看成是由 这些子矩阵组成的，这称为矩阵的分块，这种由子矩阵组成的矩阵称为分块矩阵。 例如矩阵  \(A\) 可写成分块矩阵的形式:
\begin{equation*}
\begin{split}A=\left[\begin{array}{ll} A_{1} & A_{2} \\ A_{3} & A_{4} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  从而
\begin{equation*}
\begin{split}A^{T}=\left[\begin{array}{cc} A_{1}^{T} & A_{3}^{T} \\ A_{2}^{T} & A_{4}^{T} \end{array}\right]\end{split}
\end{equation*}

\subsection{1.4.2 矩阵的加法与乘法}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78403:id3}}
\sphinxAtStartPar
​  定义 \(1.4.5\)   设  \(A=\left(a_{i j}\right), B=\left(b_{i j}\right)\) 都是数域 \(G\) 上 \(m \times n\) 矩阵，令
\begin{equation*}
\begin{split}C=\left(a_{i j}+b_{i j}\right)_{m n}\end{split}
\end{equation*}
\sphinxAtStartPar
​  则称矩阵  \(C\) 是矩阵  \(A\) 与  \(B\) 的和，记作  \(C=A+B\) 。

\sphinxAtStartPar
​  定义 \(1.4.6\)  设  \(A=\left(a_{ij}\right)\) 是数域 \(G\) 上 \(m \times n\) 矩阵,  \(k \in G\)  ，令
\begin{equation*}
\begin{split}M=\left(k a_{i j}\right)_{m \times n}\end{split}
\end{equation*}
\sphinxAtStartPar
​  则称矩阵  \(M\) 是 \(k\)  与矩阵  \(A\)  的数量乘积，记作  \(M=k A\)  。 8条运算法则：设  \(A\) , \(B\) , \(C\) , 都是  \(G\)  上  \(m \times n\) 矩阵 \(k, l \in G\) , 有:
\begin{equation*}
\begin{split}\begin{aligned}& 1^{\circ} A+B=B+A ; \\&
2^{\circ}(A+B)+C=A+(B+C) ;\\&
3^{\circ} A+0=0+A=A ;\\&
4^{\circ} A+(-A)=(-A)+A=0 ;  \\&
5^{\circ} 1 A=A ;\\&
6^{\circ}(k l) A=k(l A) ;\\&
7^{\circ}(k+l) A=k A+l A ; \\&
8^{\circ} k(A+B)=k A+k B .\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
​  利用负矩阵的概念，可以定义矩阵的减法如下：设  \(A\) 、 \(B\)  都是  \(m \times n\) 矩阵，则  \(A-B:=A+(-B)\)

\sphinxAtStartPar
​  定义 \(1.4.7\)   设  \(A=\left(a_{i j}\right)_{m \times n}\) ，  \(B=\left(b_{i j}\right)_{n \times s}\) ，令
\begin{equation*}
\begin{split}C=\left(c_{i j}\right)_{m \times s}\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中
\begin{equation*}
\begin{split}c_{i j}=a_{11} b_{1 j}+a_{12} b_{2 j}+\ldots+a_{i n} b_{n j}=\sum_{k=1}^{n} a_{ik} b_{kj}\end{split}
\end{equation*}
\sphinxAtStartPar
\(i=1,2, \ldots, m ; j=1,2, \ldots, s\) 。则矩阵  \(C\)  称为矩阵  \(A\)  与  \(B\)  的乘积, 记作  \(C=A B\) 。

\sphinxAtStartPar
​  矩阵乘法需要注意以下两点:

\sphinxAtStartPar
​  ​  (1) 只有左矩阵的列数与右矩阵的行数相同的两个矩阵才能相乘;

\sphinxAtStartPar
​  ​  (2) 乘积矩阵的行数等于左矩阵的行数, 乘积矩阵的列数等于右矩阵的列数。

\sphinxAtStartPar
​  例如设：
\begin{equation*}
\begin{split}A=\left(\begin{array}{ll} 1 & 2 \\ 3 & 4 \\ 5 & 6 \end{array}\right), B=\left(\begin{array}{cc} 7 & 8 \\ 9 & 10 \end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
​  则:
\begin{equation*}
\begin{split}A B=\left(\begin{array}{cc}25 & 28 \\57 & 64 \\89 & 100\end{array}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
​  矩阵的乘法有下面两条性质：

\sphinxAtStartPar
   \(1^{\circ}\)  矩阵的乘法适合结合律，但一般不适合交换律:

\sphinxAtStartPar
  设  \(A=\left(a_{ij}\right)_{m \times n}, B=\left(b_{i j}\right)_{n \times s}, C=\left(c_{i j}\right)_{s \times m}\) , 则  \((A B) C=A(B C)\) 。 一般对矩阵  \(A, B\)  不成立  \(A B=B A\)  如
\begin{equation*}
\begin{split}A=\left(\begin{array}{ll} 1 & 1 \end{array}\right), B=\left(\begin{array}{l} 1 \\ 1 \end{array}\right), A B=(2), B A=\left(\begin{array}{ll} 1 & 1 \\ 1 & 1 \end{array}\right), A B \neq B A\end{split}
\end{equation*}
\sphinxAtStartPar
​  若对矩阵  \(A\) , \(B\)  成立  \(A B=B A\)  则称  \(A\)  与  \(B\)  可交换。

\sphinxAtStartPar
   \(2^{\circ}\)  矩阵的乘法适合左分配律，也适合右分配律:
\begin{equation*}
\begin{split}A(B+C)=A B+A C,(B+C) D=B D+C D\end{split}
\end{equation*}
\sphinxAtStartPar
\(n\) 级矩阵 \(A=\left(a_{i j}\right)\) 中的元素 \(a_{i i}(i=1,\ldots, n)\) 称为主对角线上元素。主对角线上元素都是  \(1\) ， 其余元素都是 0 的  \(n\) 级矩阵称为 \(n\)  级单位阵，记作  \(I_{n}\)  ，或简记作  \(I\)  。容易直接计算得：
\begin{equation*}
\begin{split}I_{ n} A_{n \times m }=A_{n \times m}, A_{n \times m} I_{m}=A_{n m}\end{split}
\end{equation*}
\sphinxAtStartPar
​  特别的，如果  \(A\)  是  \(n\)  阶矩阵，则
\begin{equation*}
\begin{split}I A=A I=A\end{split}
\end{equation*}
\sphinxAtStartPar
​  矩阵的乘法与数量乘法满足下述关系式:
\begin{equation*}
\begin{split}k(A B)=(k A) B=A(k B)\end{split}
\end{equation*}
\sphinxAtStartPar
​  矩阵的加法、数量乘法、乘法与矩阵的转置有如下关系:
\begin{equation*}
\begin{split}(A+B)^{\prime}=A^{\prime}+B^{\prime} ;(k A)^{\prime}=k A^{\prime} ;(A B)^{\prime}=B^{\prime} A^{\prime}\end{split}
\end{equation*}
\sphinxAtStartPar
​  定义 \(1.4.8\)   主对角线以外的元素全为 0 的方阵称为对角矩阵，简记作
\begin{equation*}
\begin{split}\text{diag}\left\{d_{1}, d_{2}, \ldots, d_{n}\right\}\end{split}
\end{equation*}

\subsection{1.4.3 可逆矩阵和矩阵相似}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78403:id4}}
\sphinxAtStartPar
​  定义 \(1.4.9\)   对于数域  \(G\)  上的矩阵  \(A\)  ，如果存在数域  \(G\)  上的矩阵  \(B\)  ，使得
\begin{equation*}
\begin{split}A B=B A=I\end{split}
\end{equation*}
\sphinxAtStartPar
那么称  \(A\)  是可逆矩阵 (或非奇异矩阵) ; 称  \(B\)  为  \(A\)  的逆矩阵，记作  \(A^{-1}\)  。

\sphinxAtStartPar
​  定义 \(1.4.10\)   设  \(A\)  与  \(B\)  都是数域  \(G\)  上的  \(n\)  级矩阵，如果存在数域  \(G\)  上的一个  \(n\)  级可逆矩阵  \(P\)  ，使得  \(P^{-1} A P=B\)  那么称  \(A\)  与  \(B\)  是相似的。

\sphinxstepscope


\section{1.5 矩阵的特征及矩阵}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78404:id1}}\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78404::doc}}

\subsection{1.5.1 矩阵的特征值与特征向量}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78404:id2}}
\sphinxAtStartPar
​  定义  \(1.5.1\)  设 \(A\) 是数域  \(G\) 上的  \(n\) 级矩阵，如果  \(G^n\) 中有非零列向量 \(| {v}\rangle\) ，使得
\begin{equation*}
\begin{split}A|v\rangle=v|v\rangle\text{且}v \in G\end{split}
\end{equation*}
\sphinxAtStartPar
那么称 \(v\) 是 \(A\) 的一个特征值，称 \(| {v}\rangle\) 是 \(A\) 的属于特征值 \(v\) 的一个特征向量。

\sphinxAtStartPar
注意这里数值 \(v\) 和列向量 \(| {v}\rangle\) 是两个不同的概念，只不过为了突出它们之间的关系，都采用了 \(v\) 这个记号。

\sphinxAtStartPar
由线性代数中行列式及线性方程组的知识可知：
\begin{quote}

\sphinxAtStartPar
\(v\) 是 \(A\) 的一个特征值， \(| {v}\rangle\) 是 \(A\) 的属于特征值 \(v\) 的一个特征向量
\end{quote}
\begin{equation*}
\begin{split}\begin{aligned} &\Leftrightarrow A|v\rangle=v|v\rangle,|v\rangle \neq 0, v \in G \\ &\Leftrightarrow(v I-A)|v\rangle=0,|v\rangle \neq 0, v \in G \\ &\Leftrightarrow|v I-A|=0 , |v\rangle \text {是} (v I-A)|v\rangle=0 \text {的一个非零解} v \in G \\ &\Leftrightarrow v \text {是多项式} |\lambda I-A| \text {在} G \text{中的一个根}|v\rangle \text{是} (v I-A)|x\rangle=0 \text{的一个非零解}& \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\(|\lambda I-A|\) 称为  \(A\) 的特征多项式。 设  \({v}\) 是  \(A\) 的一个特征值，把齐次线性方程组  \((v I-A)|x\rangle=0\) 的解空间称为  \(A\) 的属于  \(v\) 的特征子空间，其中的全部非零向量就是  \(A\) 的属于  \(v\) 的全部特征向量。

\sphinxAtStartPar
​  定义  \(1.5.2\)  如果  \(n`级矩阵  :math:`A\)  能够相似于一个对角矩阵，那么称  \(A\)  可对角化。

\sphinxAtStartPar
​  定理 \(1.5.1\)  数域  \(G\)  上  \(n\)  级矩阵  \(A\)  可对角化的充分必要条件是，  \(G^{n}\)  中有  \(n\)  个线性无关的列向量  \(\left|x_{1}\right\rangle,\left|x_{2}\right\rangle, \ldots,\left|x_{n}\right\rangle\) , 以及  \(G\)  中有  \(n\)  个数  \(x_{1}, x_{2}, \ldots, x_{n}\)  (它们之中有些可能相等)，使得
\begin{equation*}
\begin{split}A\left|x_{i}\right\rangle=x_{i}\left|x_{i}\right\rangle, i=1,2, \ldots, n\end{split}
\end{equation*}
\sphinxAtStartPar
这时, 令  \(P=\left(\left|x_{1}\right\rangle,\left|x_{2}\right\rangle, \ldots,\left|x_{n}\right\rangle\right)\)  ，则
\begin{equation*}
\begin{split}P^{-1} A P=\text{diag}\left\{x_{1}, x_{2}, \ldots, x_{n}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
证明 设  \(A\)  与对角矩阵  \(D=\text{diag}\{x_{1}, x_{2}, \ldots, x_{n}\}\)  相似，其中  \(x_{i} \in G, i=1,2,\ldots,n\)  。这等价于存在  \(G\)  上  \(n\)  级可逆矩阵  \(P=(|x_{1}\rangle,|x_{2}\rangle,\ldots,|x_{n}\rangle)\), 使得  \(P^{-1} A P=D\)  即  \(A P=P D ` ， 即  :math:`A(|x_{1}\rangle , |x_{2}\rangle, \ldots, |x_{n}\rangle)=(|x_{1}\rangle, |x_{2}\rangle,  \ldots, |x_{n}\rangle) D ` ， 即  :math:`(A|x_{1}\rangle, A|x_{2}\rangle ,\ldots, A|x_{n}\rangle)=(x_{1}|x_{1}\rangle, x_{2}|x_{2}\rangle , \ldots, x_{n}|x_{n}\rangle)\)  这等价于  \(G^{n}\)  中有  \(n\)  个线性无关的列向量  \(|x_{1}\rangle\) , \(|x_{2}\rangle, \ldots,|x_{n}\rangle\) , 使得
\begin{equation*}
\begin{split}A\left|x_{i}\right\rangle=x_{i}\left|x_{i}\right\rangle, i=1,2, \ldots, n\end{split}
\end{equation*}
\sphinxAtStartPar
证毕。


\subsection{1.5.2 Hermite矩阵}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78404:hermite}}
\sphinxAtStartPar
​  定义  \(1.5.3\)   若矩阵  \(B\)  中的每个元素都是矩阵  \(A\)  中相应元素的共轭，则称矩阵  \(B\)  是矩阵  \(A\)  的共轭矩阵，将  \(B\)  记作  \(A^{*}\)  。

\sphinxAtStartPar
​  定义  \(1.5.4\)   若矩阵  \(B\)  满足  \(B=\left(A^{*}\right)^{\prime}\)  ，则把  \(B\)  记作  \(A^{\dagger}\)  。若  \(A=A^{\dagger}\)  ，则称  \(A\)  为Hermite矩阵。如果  \(| {v}\rangle_{\text {是 }}\)  向量, 那么也记  \(\left(|v\rangle^{*}\right)^{\prime}=|v\rangle^{+}:=\langle v|\)  。 易验证Hermite矩阵有如下性质:  \(1^{\circ}\)  对于任意的向量  \(|v\rangle,|w\rangle\) 及矩阵 \(A\)  ，存在唯一的矩阵  \(A^{\dagger}\)  ，使得
\begin{equation*}
\begin{split}(|v\rangle, A|w\rangle)=\left(A^{\dagger}|v\rangle,|w\rangle\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}2^{\circ}(A B)^{\dagger}=B^{\dagger} A^{\dagger} :math:`,` (A|v\rangle)^{\dagger}=\langle v| A^{\dagger} :math:`,` \left(A^{\dagger}\right)^{\dagger}=A\end{split}
\end{equation*}
\sphinxAtStartPar
​  定义  \(1.5.5\)   矩阵  \(A\)  称为正规的 (normal)，如果  \(A A^{\dagger}=A^{\dagger} A\)  。

\sphinxAtStartPar
​  定义  \(1.5.6\)   矩阵  \(U\) 称为是酉的 (unitary)，如果  \(U^{\dagger}\)   \(U=I\) 。 易看出酉矩阵有如下性质:
\begin{equation*}
\begin{split}(U|v\rangle, U|w\rangle)=\left\langle v\left|U^{\dagger} U\right| w\right\rangle=\langle v \mid w\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  定理 \(1.5.2\)  酉矩阵的所有特征值的模都是 1 。 证明 设  \(U\) 是酉矩阵，  \(v\) 是 \(U\) 的一个特征值，  \(|v \rangle\) 是矩阵 \(U\)  的属于特征值  \(v\) 的特征向量, 那么有
\begin{equation*}
\begin{split}0 \neq\langle v \mid v\rangle=\left\langle v\left|U^{\dagger} U\right| v\right\rangle=(U|v\rangle)^{\dagger}(U|v\rangle)=(v|v\rangle)^{\dagger}(v|v\rangle)=v^{*} v\langle v \mid v\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
所以 \(v^*v=1\) ，即 \(v\) 的模为1。

\sphinxAtStartPar
证毕。


\subsection{1.5.3 对易式与反对易式}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78404:id3}}
\sphinxAtStartPar
​  定义  \(1.5.7\)  {[}6{]}  设有两个矩阵  \(A, B\)  ，称
\begin{equation*}
\begin{split}[A, B]:=A B-B A\end{split}
\end{equation*}
\sphinxAtStartPar
为  \(A\)  与  \(B\)  之间的对易式 (commutator)，若  \([A, B]=0\)  ，即  \(A B=B A\)  ，则称  \(A\)  和  \(B\)  是对易的。类似 的，两个矩阵的反对易式 (anti\sphinxhyphen{}commutator) 定义为
\begin{equation*}
\begin{split}\{A, B\}:=A B+B A\end{split}
\end{equation*}
\sphinxAtStartPar
如果  \({A, B}=0\)  ，即  \(A\)  与  \(B\)  反对易。 下面几条性质的证明比较简单，请读者自己思考。

\sphinxAtStartPar
   \(1^{\circ}\)  若  \([A, B]=0,{A, B}=0\)  ，且  \(A\)  可逆，则  \(B\)  必为 0 。
\begin{equation*}
\begin{split}2^{\circ}[A, B]^{\dagger}=\left[B^{\dagger}, A^{\dagger}\right],[A, B]=-[B, A]\end{split}
\end{equation*}
\sphinxAtStartPar
   \(3^{\circ}\)  设  \(A\) 和 \(B\)  都是Hermite的，则  \(i[A, B]\)  是Hermite的。

\sphinxAtStartPar
下面不加证明地给出同时对角化定理。里面用到了一些线性代数的概念。 定理 1.5.3 (同时对角化定理) 设  \(A\)  和  \(B\)  是Hermite矩阵,  \([A, B]=0\)  当且仅当存在一组标准正交基，使  \(A\) 和 \(B\)  在这组基下是同时对角的。在这种情况下  \(A\) 和 \(B\)  称为可同时对角化。

\sphinxstepscope


\section{1.6 矩阵的函数}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id1}}\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405::doc}}
\sphinxAtStartPar
​  类似于实数的函数，可以定义矩阵的函数。例如在实数的多项式函数中只用到了加法和幂运算，也可以类似地定义矩阵的多项式函数，这里的矩阵一般为方阵，因为需要用到幂运算。下面主要介绍矩阵（方阵）的指数函数。

\sphinxAtStartPar
​  定义 \(1.6.1\)  \(e^{A}={I+A+\frac{A^{2}}{2!}+\frac{A^{3}}{3!}+\frac{A^{4}}{4!}+ \cdots}\)

\sphinxAtStartPar
​  这个定义相当于把 \(f(x)=e^{x}\) 在原点泰勒展开（关于泰勒展开可见于微积分书中内容），然后把矩阵 \(A\) 带入泰勒展开式进行运算。

\sphinxAtStartPar
​  如果  \(A=diag\left\{A_{11}, A_{22} ,\cdots,A_{nn}\right\}\) ，其中 \(A_{ii}\)  是子矩阵，容易验证：
\begin{equation*}
\begin{split}e^{A}=diag\left\{A_{11}, A_{22} ,\cdots,A_{nn}\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
​  如果 \(A\) 不是一个对角阵，可以运用线性代数中的酉变换，找到一个酉矩阵 \(U\)  使得对角矩阵  \(D=diag\left\{D_{11}, D_{22} ,\cdots,D_{nn}\right\}\)  满足 \(D=U A U^{\dagger}\)  ，易知 \(A^{n}=U^{\dagger} D^{n} U\) ，从而
\begin{equation*}
\begin{split}e^{A}=U^{\dagger} e^{D} U = U^{\dagger}diag\left\{e^{D_{11}}, e^{D_{22}} ,\cdots,e^{D_{nn}}\right\}U\end{split}
\end{equation*}
\sphinxAtStartPar
​  类似于矩阵指数函数的定义，可以定义矩阵的其它函数。把矩阵代入其它函数的泰勒展开式即可。如矩阵的正弦函数可定义为：
\begin{equation*}
\begin{split}sin(A)={A-\frac{A^{3}}{3!}+\frac{A^{5}}{5!}-\cdots}\end{split}
\end{equation*}
\sphinxAtStartPar
​  矩阵的余弦函数可定义为：
\begin{equation*}
\begin{split}cos(A)={1-\frac{A^{2}}{2!}+\frac{A^{4}}{4!}-\cdots+(-1)^{n}\frac{A^{2n}}{(2n)!}+\cdots}\end{split}
\end{equation*}
\sphinxAtStartPar
​  下面介绍一个很重要的欧拉公式
\begin{equation*}
\begin{split}e^{i \theta} =cos(\theta)+isin(\theta)\end{split}
\end{equation*}
\sphinxAtStartPar
​  这个公式其实是说等式两边的泰勒展式是相等的，下面来验证一下。先给出一些泰勒展式：
\begin{equation*}
\begin{split}e^{i \theta} = 1 +\theta + \frac{\theta^{2}}{2!}+ \frac{\theta^{3}}{3!}+\cdots+ \frac{\theta^{n}}{n!}+\cdots\end{split}
\end{equation*}\begin{equation*}
\begin{split}sin(\theta) =  1 - \frac{\theta^{2}}{2!}+ \frac{\theta^{4}}{4!} - \cdots+ (-1)^{n}\frac{\theta^{2n}}{2n!}+\cdots\end{split}
\end{equation*}\begin{equation*}
\begin{split}cos(\theta) =  \theta - \frac{\theta^{3}}{3!}+ \frac{\theta^{5}}{5!} - \cdots+ (-1)^{n}\frac{\theta^{2n+1}}{(2n+1)!}+\cdots\end{split}
\end{equation*}
\sphinxAtStartPar
​  将以上三式代入欧拉公式等式两端，不难验证两端相等。


\section{1.7 线性算子与矩阵表示}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id2}}

\subsection{1.7.1 线性算子}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id3}}
\sphinxAtStartPar
​  正比例函数  \(y=k x(k \neq 0)\)  ，即  \(f(x)=k x\)  。比如，在日常生活中，一斤米 \(k\) 元，买了 \(x\) 斤，就要付给商家  \({kx}\)  元钱。正比例函数对任意的实数  \(x_{1}\) , \(x_{2}\)  ，  \(f\left(x_{1}+x_{2}\right)=k\left(x_{1}+x_{2}\right)=k x_{1}+k x_{2}=f\left(x_{1}\right)+f\left(x_{2}\right)\) ; 对 任意的  \(x\) , \(a\) ,有  \(f(a x)=k(a x)=a(k x)=a f(x)\)  。这说明正比例函数保持加法运算与数乘运算  \([4]\)  。受这类事例启发，给出线性算子的概念。 如果数域K上的向量空间  \(V \equiv K^{m}\)  到向量空间  \(W \equiv K^{n}\)  的一个映射  \(\sigma\) 保持加法和数乘运算，即  \(\forall|u\rangle\) , \(| {v}\rangle \in V\) , \(k \in K\) , 有
\begin{equation*}
\begin{split}\begin{aligned} &\sigma(|u\rangle+|v\rangle)=\sigma(|u\rangle)+\sigma|v\rangle \\ &\sigma(k|u\rangle)=k \sigma(|u\rangle) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
​  那么称  \(\sigma\) 为  \(V\) 到 \(W\) 的一个线性算子。 根据线性算子的定义可以验证以下性质:
\begin{equation*}
\begin{split}\sigma\left(\sum_{i} a_{i}\left|v_{i}\right\rangle\right)=\sum_{i} a_{i} \sigma\left(\left|v_{i}\right\rangle\right)\end{split}
\end{equation*}
\sphinxAtStartPar
​  通常  \(\sigma(|v\rangle)\) 简记为 \(\sigma|v\rangle\)  。当定义在向量空间  \(V\)  上的线性算子  \(\sigma\) 时， 意味着 \(\sigma\) 是从 \(V\)  到  \(V\)  的一个线性算子。

\sphinxAtStartPar
​  一个重要的线性算子是向量空间  \(V\)  上的单位算子  \(I_{v}\)  (identity operator)，它将  \(V\)  中任意向量对应到自身 即
\begin{equation*}
\begin{split}I_{v}|v\rangle \equiv|v\rangle, \forall|v\rangle \in V\end{split}
\end{equation*}
\sphinxAtStartPar
​  另一个重要的线性算子是向量空间  \(V\) 上的零算子0 (zero operator)，它将  \(V\)  中任意向量对应到V中零向量  \(|\hat{0}\rangle\)  , 即
\begin{equation*}
\begin{split}0|v\rangle \equiv|\hat{0}\rangle, \forall|v\rangle \in V\end{split}
\end{equation*}
\sphinxAtStartPar
​  由于线性算子是映射的一种特殊情况，因此线性算子也可以做映射的合成，并满足合成的结合律。


\subsection{1.7.2 矩阵表示}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id4}}
\sphinxAtStartPar
​  最直观的理解线性算子的方式就是通过线性算子的矩阵表示 (matrix representations)，因为矩阵能有一个直观的认识  \([3,4,6,7]\) 。

\sphinxAtStartPar
​  设  \(\sigma: \mathrm{V} \rightarrow \mathrm{W}\) 是向量空间  \(V\) 到向量空间W的线性算子，选定向量组  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{n}\rangle\}\)  为向量空间  \(V\) 的一 个基，向量组  \(\{|w_{1}\rangle,|w_{2}\rangle, \cdots,|w_{m}\rangle\}\)  为向量空间  \(W\)  的一个基，由于向量空间 \(V\) 中的任意向量  \(|v\rangle\)  都可以由基  \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{n}\rangle\}\) 线性表示, 根据线性算子的保持加法和数乘的性质，只要确定 \(\sigma\) 作用在基 \(\{|v_{1}\rangle,|v_{2}\rangle, \cdots,|v_{n}\rangle\}\) 上的像，从而也就确定了线性算子 \(\sigma\) 作用在任意向量  \(| {v}\rangle\) 上的像。

\sphinxAtStartPar
​  根据线性算子的定义可知，线性算子本质上是两个向量空间之间的映射，而映射表示一种对应关系。如果确 定空间V中每一个  \(|v\rangle\) 在映射作用到向量空间 \(W\) 中的像，也就确定从向量空间 \(V\) 到向量空间 \(W\) 的对应关系，即 线性算子  \(\sigma: V \rightarrow W\) 也就被确定。

\sphinxAtStartPar
​  而 \(V\) 中的每个元素都能被 \(V\) 中的基线性表示，因此将线性算子  \(\sigma\) 作用在基的每一个元素上面，得到 \(W\) 中的像  \(\sigma|v_{1}\rangle, \sigma|v_{2}\rangle, \cdots, \sigma|v_{n}\rangle\) 都确定，从而基的线性表示的像也被确定，那么线性算子也就被确定。 由于  \(\sigma|v_{j}\rangle, j=1,2, \cdots, n\) 是 \(W\) 中的元素，因此可以由 \(W\) 中的基  \(\{\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \cdots,\left|w_{m}\right\rangle\}\) 来线性表示， 即
\begin{equation*}
\begin{split}\sigma|v_{j}\rangle=a_{1 j}|w_{1}\rangle+a_{2 j}|w_{2}\rangle+\cdots+a_{m j}|w_{m}\rangle=\sum_{i=1}^{m} a_{i j}|w_{i}\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  写成矩阵的形式
\begin{equation*}
\begin{split}\left[\sigma\left|v_{1}\right\rangle, \sigma\left|v_{2}\right\rangle, \cdots, \sigma\left|v_{n}\right\rangle\right]=\left[\left|w_{1}\right\rangle, \quad\left|w_{2}\right\rangle, \quad \cdots \quad,\left|w_{m}\right\rangle\right]\left[\begin{array}{cccc} a_{11} & a_{12} & \cdots & a_{1 n} \\ a_{21} & a_{22} & \cdots & a_{2 n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m 1} & a_{m 2} & \ldots & a_{m n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  把上式右端的  \(m \times n\) 矩阵记作 \(A\) ， 称  \(A\)  是线性算子  \(\sigma\) 在 \(V\) 的基 \(\left|v_{1}\right\rangle,\left|v_{2}\right\rangle, \ldots,\left|v_{n}\right\rangle\) 和 \(W\) 的基  \(\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \cdots,\left|w_{m}\right\rangle\) 下的矩阵表示(matrix representation) 。

\sphinxAtStartPar
​  因此，对于给定基下的线性算子都可以找到与之对应的矩阵。并且这种矩阵表示方式是唯一的。

\sphinxAtStartPar
​  根据矩阵的运算法则以及线性算子的定义，也可以验证矩阵是一个线性算子。因此，在给定向量空间的基 下，线性算子与矩阵作用在同一向量空间上是等价的。 设  \(\sigma\) 是域  \(G\) 上 \(n\)  维线性空间  \(V\)  到  \(m\) 维线性空间 \(W\)  的一个线性算子，它在  \(V\)  下的一个基  \(\left|v_{1}\right\rangle,\left|v_{2}\right\rangle, \ldots,\left|v_{n}\right\rangle\) 和 \(W\) 的一个基  \(\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \cdots,\left|w_{m}\right\rangle\) 下的矩阵为 \(A\) ,  \(V\) 中向量 \(|v\rangle\) 在基  \(\left|v_{1}\right\rangle,\left|v_{2}\right\rangle, \ldots,\left|v_{n}\right\rangle\) 下的坐标为  \(X\)  ，则有：
\begin{equation*}
\begin{split}\begin{aligned} &\sigma|v\rangle=\sigma\left[\left(\left|v_{1}\right\rangle,\left|v_{2}\right\rangle, \ldots,\left|v_{n}\right\rangle\right) X\right]\\ & =\left[\sigma\left(\left|v_{1}\right\rangle,\left|v_{2}\right\rangle, \ldots,\left|v_{n}\right\rangle\right)\right] X \\ &=\left[\left(\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \ldots,\left|w_{m}\right\rangle\right) A\right] X \\ &{=}\left(\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \ldots,\left|w_{m}\right\rangle\right)(A X) \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
​  因此  \(\sigma|v\rangle\) 在 \(W\) 的一个基  \(\left|w_{1}\right\rangle,\left|w_{2}\right\rangle, \cdots,\left|w_{m}\right\rangle\) 下的坐标为  \(A X\) 。 线性算子作用于向量空间中的元素所得到的新元素的坐标，实际上就是矩阵乘以向量空间中的元素的坐标。 因此前文矩阵的性质也对应于线性算子的性质。

\sphinxAtStartPar
​  根据线性算子的定义，可以将向量空间V中，两向量  \(| {u}\rangle\) 和 \(| {v}\rangle\) 的内积中的对偶  \(\left\langle {u} \right|\) 也可以看作从向量空间  \(V\) 到复数域 \(C\) 的线性算子，即
\begin{equation*}
\begin{split}\langle u|(|v\rangle)=\langle u \mid v\rangle=(|u\rangle,|v\rangle)=\sum_{i=1}^{n} u_{i}^{*} v_{i}=\left[\begin{array}{lll} u_{1}^{*} & \cdots & u_{n}^{*} \end{array}\right]\left[\begin{array}{c} v_{1} \\ \vdots \\ v_{n} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  而线性算子  \(\left\langle u\right|\) 在向量空间V中标准正交基下的矩阵表示为1乘n的矩阵  \(\left[\begin{array}{lll}u_{1}^{*} & \cdots & u_{n}^{*}\end{array}\right]\)  。


\subsection{1.7.3 向量外积}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id5}}
\sphinxAtStartPar
​  一个n维向量可以看作一个1乘n或n乘1的矩阵，反过来，m乘n的矩阵可不可以看作一个向量呢? 本质上向量 和矩阵是一样的，只不过人们在不同的情况下，运用不同的表示方式。类比向量，矩阵的基又是什么呢? 矩 阵是一个线性映射，在给定基下，线性算子与矩阵等价，向量空间中的基与矩阵表示又有什么关系呢?

\sphinxAtStartPar
​  基于以上的疑问，下面引进向量外积的概念{[}6{]}。假设  \(| {v}\rangle | {w}\rangle ` 是m维内积空间 :math:`W\)  中的向量，定义  \(| {v}\rangle\left\langle {w}\right|\) 是从 \(V\) 到 \(W\) 的线性算子，并且满足运算规则。
\begin{equation*}
\begin{split}(|w\rangle\langle v|)(|\tilde{v}\rangle):=|w\rangle(\langle v \mid \tilde{v}\rangle)=\langle v \mid \tilde{v}\rangle|w\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
​  这里借助于内积的运算定义了外积。 设在给定标准正价基下，向量  \(|v\rangle,|w\rangle\) 的坐标表示分别为:
\begin{equation*}
\begin{split}|v\rangle=\left[\begin{array}{c} v_{1} \\ v_{2} \\ \vdots \\ v_{n} \end{array}\right],|w\rangle=\left[\begin{array}{c} w_{1} \\ w_{2} \\ \vdots \\ w_{m} \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  从而线性算子  \(| {w}\rangle\left\langle\left. {v}\right|\right.\) 的矩阵表示为:
\begin{equation*}
\begin{split}|w\rangle\langle v|=\left[\begin{array}{c}w_{1} \\w_{2} \\\vdots \\w_{m}\end{array}\right]\left[\begin{array}{llll}v_{1}^{*} & v_{2}^{*} & \cdots & v_{n}^{*}\end{array}\right]=\left[\begin{array}{cccc}w_{1} v_{1}^{*} & w_{1} v_{2}^{*} & \cdots & w_{1} v_{n}^{*} \\w_{2} v_{1}^{*} & w_{2} v_{2}^{*} & \cdots & w_{2} v_{n}^{*} \\\vdots & \vdots & \ddots & \vdots \\w_{m} v_{1}^{*} & w_{m} v_{2}^{*} & \cdots & w_{m} v_{n}^{*}\end{array}\right] \text {. }\end{split}
\end{equation*}
\sphinxAtStartPar
​  可以看出，在给定标准正交基下，线性算子  \(|w\rangle\left\langle\left. v\right| \right.\) 的矩阵表示为向量 \(\mid {w}\rangle\) 的坐标表示与  \(| {v}\rangle\) 的对偶向量的坐标表示的矩阵乘法得到。


\subsection{1.7.4 对角表示}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id6}}
\sphinxAtStartPar
​  向量空间V上的线性算子A的对角表示 (diagonal representation)  \([4,6]\)  是指 \(A\) 可以表示成
\begin{equation*}
\begin{split}A=\sum_{i} \lambda_{\rho}|i\rangle\langle i|\end{split}
\end{equation*}
\sphinxAtStartPar
​  其中向量  \(|i\rangle\)  为线性算子 \(A\) 的属于特征值 \(\lambda_{i}\)  的标准正交化的特征向量。 若一个线性算子有对角表示，则该线性算子一定可对角化的 (diagonalizable)。 比如，Pauli Z矩阵有对角表示
\begin{equation*}
\begin{split}Z=\left[\begin{array}{cc} 1 & 0 \\ 0 & -1 \end{array}\right]=1 \cdot|0\rangle\langle 0|+(-1) \cdot| 1\rangle\langle 1|\end{split}
\end{equation*}
\sphinxAtStartPar
​  而线性算子可对角化，不一定有对角表示。 比如，矩阵
\begin{equation*}
\begin{split}\left[\begin{array}{ll} 1 & -2 \\ 0 & -1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  特征值1对应的特征向量为  \(k_{1}\left[\begin{array}{cc}1 & 0\end{array}\right]^{T}\)  ，特征值\sphinxhyphen{}1对应的特征向量为  \(k_{2}\left[\begin{array}{cc}1 & 1\end{array}\right]^{T}\)  ，这两个特征向量并不正交， 因此不可以对角表示。 而矩阵
\begin{equation*}
\begin{split}\left[\begin{array}{ll} 1 & 0 \\ 1 & 1 \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
​  是不可对角化的。

\sphinxAtStartPar
​  \sphinxstylestrong{定理} 向量空间V上任意线性算子A是正规算子的充要条件是在  \(V\)  的某个标准正交基下， 线性算子A有对角表示。


\subsection{1.7.5 影算子}
\label{\detokenize{rst/_u9644_u5f551_u91cf_u5b50_u8ba1_u7b97_u6570_u5b66_u57fa_u78405:id7}}
\sphinxAtStartPar
​  假设  \(U\)  是  \(n\)  维向量空间  \(V\)  的k维子空间，可以从V标准正交基中找到  \(k\)  维子空间  \(U\)  的标准正交基并标记为  \(|1\rangle, \cdots|k\rangle\)  ，定义
\begin{equation*}
\begin{split}P:=\sum_{i=1}^{k}|i\rangle\langle i|\end{split}
\end{equation*}
\sphinxAtStartPar
​  为子空间 \(W\) 上的投影算子 (projector) {[}6{]}。定义
\begin{equation*}
\begin{split}Q:=\sum_{i=k+1}^{n}|i\rangle\langle i|\end{split}
\end{equation*}
\sphinxAtStartPar
​  为投影算子 \(P\) 的正交补 (orthogonal complement )。可以验证
\begin{equation*}
\begin{split}P+Q=I\end{split}
\end{equation*}
\sphinxAtStartPar
​  \sphinxstylestrong{定理} 对于任意投影  \(P\)  ，满足  \(P^{2}=P\)  。
\begin{equation*}
\begin{split}P^{2}=\left(\sum_{i=1}^{k}|i\rangle\langle i|\right)^{2}=\sum_{i, j=1}^{k}|i\rangle\langle i \mid j\rangle\langle j|\end{split}
\end{equation*}\begin{equation*}
\begin{split}\left\langle i \mid j\right\rangle=\delta_{i j} \begin{cases}1, & (i=j) \\ 0, & (i \neq j)\end{cases}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sum_{ i, j=1}^{k}|i\rangle\langle i \mid j\rangle  \langle j |=\sum_{i=1}^{k} \ | i\rangle \langle i|=P\end{split}
\end{equation*}
\sphinxAtStartPar
即  \(P^{2}=P\)  。证毕。

\sphinxAtStartPar
\sphinxstylestrong{参考文献}

\sphinxAtStartPar
{[}1{]} 同济大学数学系.高等数学\sphinxhyphen{}上册（第六版）{[}M{]}.高等教育出版社，2007年4月.

\sphinxAtStartPar
{[}2{]} 同济大学数学系.高等数学\sphinxhyphen{}下册（第六版）{[}M{]}.高等教育出版社，2007年6月.

\sphinxAtStartPar
{[}3{]} 丘维声. 高等代数\sphinxhyphen{}上册 {[}M{]}.清华大学出版社，2010年6月.

\sphinxAtStartPar
{[}4{]} 丘维声. 高等代数\sphinxhyphen{}下册 {[}M{]}.清华大学出版社，2010年10月.

\sphinxAtStartPar
{[}5{]} James Stewart. Calculus(Eight Edition){[}M{]}. CENGAGE Learning, 2016.

\sphinxAtStartPar
{[}6{]} Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information{[}M{]}. Cambridge University Press, 2010.

\sphinxAtStartPar
{[}7{]} Giuliano Benenti, Giulio Casati and Giuliano Strini. Principles of Quantum Computation and Information(Volume I: Basic Concepts){[}M{]}. World Scientific, 2004.

\sphinxAtStartPar
{[}8{]} Mikio Nakahara and Tetsuo Ohmi . Quantum Computing\sphinxhyphen{}From Linear Algebra to Physical Realizations{[}M{]}. CRC Press, 2004.

\sphinxstepscope


\section{2.1 QPanda}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:qpanda}}\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e::doc}}
\sphinxAtStartPar
​  一种功能齐全，运行高效的量子软件开发工具包

\sphinxAtStartPar
​  QPanda 2是由本源量子开发的开源量子计算框架，它可以用于构建、运行和优化量子算法。QPanda 2作为本源量子计算系列软件的基础库，为QRunes、Qurator、量子计算服务提供核心部件。

\sphinxAtStartPar
\sphinxstylestrong{编译环境}

\sphinxAtStartPar
​  QPanda 2是以C++为宿主语言，其对系统的环境要求如表附2.1.1：

\begin{center}表附2.1.1 环境要求
\end{center}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{software}
&
\sphinxAtStartPar
\sphinxstylestrong{version}
\\
\sphinxhline
\sphinxAtStartPar
CMake
&
\sphinxAtStartPar
>= 3.1
\\
\sphinxhline
\sphinxAtStartPar
GCC
&
\sphinxAtStartPar
>= 5.0
\\
\sphinxhline
\sphinxAtStartPar
Python
&
\sphinxAtStartPar
>= 3.7.0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{下载QPanda 2}

\sphinxAtStartPar
​  如果在您的系统上已经安装了git， 你可以直接输入以下命令来获取QPanda2：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/OriginQ/QPanda 2.git
\end{sphinxVerbatim}

\sphinxAtStartPar
​  对于一些为安装git的伙伴来说，也可以直接通过浏览器去下载QPanda 2， 具体的操作步骤如下：

\sphinxAtStartPar
​  1.在浏览器中输入 \sphinxurl{https://github.com/OriginQ/QPanda} 2 ，进入网页会看到：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{图附2.1.1}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.1 Github界面
\end{center}
\sphinxAtStartPar
​  2.点击 Clone or download 看到界面：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1252}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.2 Github界面
\end{center}
\sphinxAtStartPar
​  3.然后点击 Download ZIP， 就会完成QPanda2的下载。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1253}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.3 下载
\end{center}
\sphinxAtStartPar
\sphinxstylestrong{编译}

\sphinxAtStartPar
​  我们支持在Windows、Linux、MacOS下构建QPanda 2。用户可以通过CMake的方式来构建QPanda 2。

\sphinxAtStartPar
Windows

\sphinxAtStartPar
​  在Windows构建QPanda 2。用户首先需要保证在当前主机下安装了CMake环境和C++编译环境，用户可以通过Visual Studio和MinGW方式编译QPanda 2。

\sphinxAtStartPar
  1. 使用Visual Studio

\sphinxAtStartPar
​  这里以Visual Studio 2017为例，使用Visual Studio 2017 编译QPanda 2,只需要安装Visual Studio 2017，并需要在组件中安装CMake组件。安装完成之后，用Visual Studio 2017打开QPanda 2文件夹，即可使用CMake编译QPanda 2。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1254}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.4 使用CMake编译QPanda2
\end{center}
\sphinxAtStartPar
  2. 使用MinGW

\sphinxAtStartPar
​  使用MinGW编译QPanda 2，需要自行搭建CMake和MinGW环境，用户可自行在网上查询环境搭建教程。（注意： MinGW需要安装64位版本）

\sphinxAtStartPar
​  CMake+MinGW的编译命令如下：

\sphinxAtStartPar
    1. 在QPanda 2根目录下创建build文件夹

\sphinxAtStartPar
    2. 进入build文件夹，打开cmd

\sphinxAtStartPar
    3. 由于MinGW对CUDA的支持存在一些问题，所以在编译时需要禁掉CUDA，输入以下命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{G}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinGW Makefiles}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{DFIND\PYGZus{}CUDA}\PYG{o}{=}\PYG{n}{OFF} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}\PYG{o}{=}\PYG{n}{C}\PYG{p}{:}\PYG{o}{/}\PYG{n}{QPanda2} \PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{2.}\PYG{n}{mingw32}\PYG{o}{\PYGZhy{}}\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
Linux 和MacOS

\sphinxAtStartPar
​  在Linux和MacOS下编译QPanda 2，命令是一样的。

\sphinxAtStartPar
​  编译步骤如下：

\sphinxAtStartPar
    1. 进入QPanda 2根目录

\sphinxAtStartPar
    2. 输入以下命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{build}
\PYG{l+m+mf}{2.}\PYG{n}{cd} \PYG{n}{build}
\PYG{l+m+mf}{3.}\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{4.}\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  如果有需求，用户通过命令修改QPanda 2的安装路径，配置方法如下所示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{build}
\PYG{l+m+mf}{2.}\PYG{n}{cd} \PYG{n}{build}
\PYG{l+m+mf}{3.}\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local} \PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{4.}\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{安装}

\sphinxAtStartPar
​  QPanda 2编译完成后，会以库的形式存在。为了方便调用，大家可以把QPanda 2库安装到指定位置，安装的方式如下所示。

\sphinxAtStartPar
Windows

\sphinxAtStartPar
  1. 使用Visual Studio

\sphinxAtStartPar
​  同样以Visual Studio 2017为例,在QPanda 2编译完成后，用户可以安装，Visual Studio 2017的安装方式很简单，只需要在Cmake菜单中选择安装即可。

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1255}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.5 在Cmake菜单中选择“安装”
\end{center}
\sphinxAtStartPar
​  QPanda 2会安装在用户在CMakeSettings.json中配置的安装目录下。安装成功后会在用户配置的的目录下生成install文件夹，里面安装生成include和lib文件。如果有需求，用户可以在Visual Studio的CMakeSettings.json配置文件修改的安装路径。生成CMakeSettings.json的方法如下图所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1256}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.6 生成CMakeSettings.json的方法
\end{center}
\sphinxAtStartPar
​  修改QPanda 2的安装路径如下图所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics{{wps1257}.jpg}\hspace*{\fill}}

\begin{center}图附2.1.7 修改QPanda 2的安装路径
\end{center}
\sphinxAtStartPar
​  参数修改完成后，cmake选项下执行安装，QPanda 2的lib库文件和include头文件会安装到用户指定的安装位置。(注意：需先进行编译成功后才能进行安装)

\sphinxAtStartPar
  2. 使用MinGW

\sphinxAtStartPar
​  在QPanda 2编译完成后，用户可以安装QPanda 2，安装命令如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{mingw32}\PYG{o}{\PYGZhy{}}\PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

\sphinxAtStartPar
Linux 和MacOS

\sphinxAtStartPar
​  在Linux和MacOS下安装命令QPanda 2，命令是一样的，安装命令如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{sudo} \PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{使用}

\sphinxAtStartPar
​  不同的平台和不同的IDE在构建C++项目是的方法是不一样的，调用库的方式也不尽相同，大家可以选择用自己的方式调用QPanda 2库, 下面我们以cmake构建项目为例，演示调用QPanda 2库进行量子编程。

\sphinxAtStartPar
​  Visual Studio调用QPanda 2库

\sphinxAtStartPar
​  Visual Studio下调用QPanda 2库的CMakeList的写法为

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.cmake\PYGZus{}minimum\PYGZus{}required(VERSION 3.1)
2.project(testQPanda)
3.SET(CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX  \PYGZdq{}C:/QPanda2\PYGZdq{}) \PYGZsh{} QPanda2安装的路径
4.SET(CMAKE\PYGZus{}MODULE\PYGZus{}PATH \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}MODULE\PYGZus{}PATH\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYGZcb{}/lib/cmake\PYGZdq{})
5.
6.set(CMAKE\PYGZus{}CXX\PYGZus{}STANDARD 14)
7.set(CMAKE\PYGZus{}CXX\PYGZus{}STANDARD\PYGZus{}REQUIRED ON)
8.if (NOT USE\PYGZus{}MSVC\PYGZus{}RUNTIME\PYGZus{}LIBRARY\PYGZus{}DLL)
9.    foreach (flag
10.        CMAKE\PYGZus{}C\PYGZus{}FLAGS
11.        CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}DEBUG
12.        CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELEASE
13.        CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}MINSIZEREL
14.        CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO
15.        CMAKE\PYGZus{}CXX\PYGZus{}FLAGS
16.        CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG
17.        CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE
18.        CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}MINSIZEREL
19.        CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELWITHDEBINFO)
20.
21.        if (\PYGZdl{}\PYGZob{}flag\PYGZcb{} MATCHES \PYGZdq{}/MD\PYGZdq{})
22.            string(REGEX REPLACE \PYGZdq{}/MD\PYGZdq{} \PYGZdq{}/MT\PYGZdq{} \PYGZdl{}\PYGZob{}flag\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}\PYGZdl{}\PYGZob{}flag\PYGZcb{}\PYGZcb{}\PYGZdq{})
23.        endif()
24.        if (\PYGZdl{}\PYGZob{}flag\PYGZcb{} MATCHES \PYGZdq{}/MDd\PYGZdq{})
25.            string(REGEX REPLACE \PYGZdq{}/MDd\PYGZdq{} \PYGZdq{}/MTd\PYGZdq{} \PYGZdl{}\PYGZob{}flag\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}\PYGZdl{}\PYGZob{}flag\PYGZcb{}\PYGZcb{}\PYGZdq{})
26.        endif()
27.        if (\PYGZdl{}\PYGZob{}flag\PYGZcb{} MATCHES \PYGZdq{}/W3\PYGZdq{})
28.            string(REGEX REPLACE \PYGZdq{}/W3\PYGZdq{} \PYGZdq{}/W0\PYGZdq{} \PYGZdl{}\PYGZob{}flag\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}\PYGZdl{}\PYGZob{}flag\PYGZcb{}\PYGZcb{}\PYGZdq{})
29.        endif()
30.    endforeach()
31.endif()
32.
33.set(LIBRARY\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/lib)
34.set(EXECUTABLE\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/bin)
35.
36.find\PYGZus{}package(OpenMP)
37.if(OPENMP\PYGZus{}FOUND)
38.    option(USE\PYGZus{}OPENMP \PYGZdq{}find OpenMP\PYGZdq{} ON)
39.    message(\PYGZdq{}OPENMP FOUND\PYGZdq{})
40.    set(CMAKE\PYGZus{}C\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
41.    set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
42.    set(CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
43.else(OPENMP\PYGZus{}FOUND)
44.    option(USE\PYGZus{}OPENMP \PYGZdq{}not find OpenMP\PYGZdq{} OFF)
45.endif(OPENMP\PYGZus{}FOUND)
46.
47.find\PYGZus{}package(QPANDA REQUIRED)
48.if (QPANDA\PYGZus{}FOUND)
49.    include\PYGZus{}directories(\PYGZdl{}\PYGZob{}QPANDA\PYGZus{}INCLUDE\PYGZus{}DIR\PYGZcb{})
50.endif (QPANDA\PYGZus{}FOUND)
51.
52.add\PYGZus{}executable(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} test.cpp)
53.target\PYGZus{}link\PYGZus{}libraries(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} \PYGZdl{}\PYGZob{}QPANDA\PYGZus{}LIBRARIES\PYGZcb{})
\end{sphinxVerbatim}

\sphinxAtStartPar
​MinGW调用QPanda 2库

\sphinxAtStartPar
​  MinGW调用QPanda 2库的CMakeList的写法为

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.cmake\PYGZus{}minimum\PYGZus{}required(VERSION 3.1)
2.project(testQPanda)
3.SET(CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX  \PYGZdq{}C:/QPanda2\PYGZdq{}) \PYGZsh{} QPanda2安装的路径
4.SET(CMAKE\PYGZus{}MODULE\PYGZus{}PATH \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}MODULE\PYGZus{}PATH\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYGZcb{}/lib/cmake\PYGZdq{})
5.
6.
7.add\PYGZus{}definitions(\PYGZdq{}\PYGZhy{}w \PYGZhy{}DGTEST\PYGZus{}USE\PYGZus{}OWN\PYGZus{}TR1\PYGZus{}TUPLE=1\PYGZdq{})
8.set(CMAKE\PYGZus{}BUILD\PYGZus{}TYPE \PYGZdq{}Release\PYGZdq{})
9.set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG \PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O0 \PYGZhy{}g \PYGZhy{}ggdb\PYGZdq{})
10.set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE \PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O3\PYGZdq{})
11.add\PYGZus{}compile\PYGZus{}options(\PYGZhy{}fpermissive)
12.
13.set(LIBRARY\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/lib)
14.set(EXECUTABLE\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/bin)
15.
16.find\PYGZus{}package(OpenMP)
17.if(OPENMP\PYGZus{}FOUND)
18.    option(USE\PYGZus{}OPENMP \PYGZdq{}find OpenMP\PYGZdq{} ON)
19.    message(\PYGZdq{}OPENMP FOUND\PYGZdq{})
20.    set(CMAKE\PYGZus{}C\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
21.    set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
22.    set(CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
23.else(OPENMP\PYGZus{}FOUND)
24.    option(USE\PYGZus{}OPENMP \PYGZdq{}not find OpenMP\PYGZdq{} OFF)
25.endif(OPENMP\PYGZus{}FOUND)
26.
27.find\PYGZus{}package(QPANDA REQUIRED)
28.if (QPANDA\PYGZus{}FOUND)
29.    include\PYGZus{}directories(\PYGZdl{}\PYGZob{}QPANDA\PYGZus{}INCLUDE\PYGZus{}DIR\PYGZcb{})
30.endif (QPANDA\PYGZus{}FOUND)
31.
32.add\PYGZus{}executable(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} test.cpp)
33.target\PYGZus{}link\PYGZus{}libraries(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} \PYGZdl{}\PYGZob{}QPANDA\PYGZus{}LIBRARIES\PYGZcb{})
\end{sphinxVerbatim}

\sphinxAtStartPar
linux、MacOS下使用QPanda2

\sphinxAtStartPar
​  linux、MacOS使用QPanda2的方式是相同的，其CmakeList.txt的写法为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.cmake\PYGZus{}minimum\PYGZus{}required(VERSION 3.1)
2.project(testQPanda)
3.SET(CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX  \PYGZdq{}/usr/local\PYGZdq{}) \PYGZsh{} QPanda2安装的路径
4.SET(CMAKE\PYGZus{}MODULE\PYGZus{}PATH \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}MODULE\PYGZus{}PATH\PYGZcb{} \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYGZcb{}/lib/cmake\PYGZdq{})
5.
6.
7.add\PYGZus{}definitions(\PYGZdq{}\PYGZhy{}w \PYGZhy{}DGTEST\PYGZus{}USE\PYGZus{}OWN\PYGZus{}TR1\PYGZus{}TUPLE=1\PYGZdq{})
8.set(CMAKE\PYGZus{}BUILD\PYGZus{}TYPE \PYGZdq{}Release\PYGZdq{})
9.set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG \PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O0 \PYGZhy{}g \PYGZhy{}ggdb\PYGZdq{})
10.set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE \PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O3\PYGZdq{})
11.add\PYGZus{}compile\PYGZus{}options(\PYGZhy{}fpermissive)
12.
13.set(LIBRARY\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/lib)
14.set(EXECUTABLE\PYGZus{}OUTPUT\PYGZus{}PATH \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/bin)
15.
16.find\PYGZus{}package(OpenMP)
17.if(OPENMP\PYGZus{}FOUND)
18.    option(USE\PYGZus{}OPENMP \PYGZdq{}find OpenMP\PYGZdq{} ON)
19.    message(\PYGZdq{}OPENMP FOUND\PYGZdq{})
20.    set(CMAKE\PYGZus{}C\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}C\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
21.    set(CMAKE\PYGZus{}CXX\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}CXX\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
22.    set(CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS \PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{} \PYGZdl{}\PYGZob{}OpenMP\PYGZus{}EXE\PYGZus{}LINKER\PYGZus{}FLAGS\PYGZcb{}\PYGZdq{})
23.else(OPENMP\PYGZus{}FOUND)
24.    option(USE\PYGZus{}OPENMP \PYGZdq{}not find OpenMP\PYGZdq{} OFF)
25.endif(OPENMP\PYGZus{}FOUND)
26.
27.find\PYGZus{}package(QPANDA REQUIRED)
28.if (QPANDA\PYGZus{}FOUND)
29.    include\PYGZus{}directories(\PYGZdl{}\PYGZob{}QPANDA\PYGZus{}INCLUDE\PYGZus{}DIR\PYGZcb{})
30.endif (QPANDA\PYGZus{}FOUND)
31.
32.add\PYGZus{}executable(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} test.cpp)
33.target\PYGZus{}link\PYGZus{}libraries(\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}NAME\PYGZcb{} \PYGZdl{}\PYGZob{}QPANDA\PYGZus{}LIBRARIES\PYGZcb{})
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
test.cpp 为使用QPanda2的一个示例。有兴趣的可以试着将其合并在一起形成一个跨平台的CMakeList.txt。
\end{sphinxadmonition}

\sphinxAtStartPar
​  通过一个示例介绍QPanda 2的使用，下面的例子可以在量子计算机中构建量子纠缠态 \((|00\rangle +|11\rangle)\) ，对其进行测量，重复制备1000次。 预期的结果是约有50\%的概率使测量结果分别在00或11上。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}QPanda.h\PYGZdq{}}
\PYG{l+m+mf}{2.}\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{QPanda}\PYG{p}{;}
\PYG{l+m+mf}{3.}\PYG{n}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{5.}    \PYG{n}{auto} \PYG{n}{qvm} \PYG{o}{=} \PYG{n}{CPUQVM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{6.}    \PYG{n}{auto} \PYG{n}{prog} \PYG{o}{=} \PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{7.}    \PYG{n}{auto} \PYG{n}{q} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{qAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{8.}    \PYG{n}{auto} \PYG{n}{c} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{cAllocMany}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{9.}    \PYG{n}{prog} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{H}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{10.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{11.}        \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{MeasureAll}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{12.}    \PYG{n}{auto} \PYG{n}{results} \PYG{o}{=} \PYG{n}{qvm}\PYG{o}{.}\PYG{n}{runWithConfiguration}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{result} \PYG{p}{:} \PYG{n}{results}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{14.}        \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{result}\PYG{o}{.}\PYG{n}{first} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ : }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{result}\PYG{o}{.}\PYG{n}{second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{l+m+mf}{15.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{16.} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mf}{17.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  编译方式与编译QPanda库的方式基本类似，在这里就不多做赘述。

\sphinxAtStartPar
​  编译之后的可执行文件会生成在build下的bin文件夹中，进入到bin目录下就可以执行自己编写的量子程序了。

\sphinxAtStartPar
​  计算结果如下所示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.00} \PYG{p}{:} \PYG{l+m+mi}{493}
\PYG{l+m+mf}{2.11} \PYG{p}{:} \PYG{l+m+mi}{507}
\end{sphinxVerbatim}


\section{2.2 pyQPanda}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:pyqpanda}}
\sphinxAtStartPar
系统配置和安装

\sphinxAtStartPar
​  我们通过pybind11工具，以一种直接和简明的方式，对QPanda2中的函数、类进行封装，并且提供了几乎完美的映射功能。 封装部分的代码在QPanda2编译时会生成为动态库，从而可以作为Python的包引入。

\sphinxAtStartPar
系统配置

\sphinxAtStartPar
​  pyqpanda是以C++为宿主语言，其对系统的环境要求如表附2.2.1：

\begin{center}表附2.2.1 环境要求
\end{center}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{software}
&
\sphinxAtStartPar
\sphinxstylestrong{version}
\\
\sphinxhline
\sphinxAtStartPar
GCC
&
\sphinxAtStartPar
>= 5.4.0
\\
\sphinxhline
\sphinxAtStartPar
Python
&
\sphinxAtStartPar
>= 3.7.0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
下载pyqpanda

\sphinxAtStartPar
​  如果你已经安装好了Python环境和pip工具， 在终端或者控制台输入下面命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{pyqpanda}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
在linux下若遇到权限问题需要加 sudo
\end{sphinxadmonition}


\section{2.3 VQNet}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:vqnet}}

\subsection{2.3.1 VQNet python包安装}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:vqnet-python}}
\sphinxAtStartPar
​  我们提供了Linux,Windows,MacOS上的python预编译包供安装，需要python==3.8。还需要numpy>=1.18.5,pyqpanda>=3.7.8。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{pyvqnet}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{VQNet 测试安装成功}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pyvqnet}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{tensor} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{2.3.2  VQNet 的一个简单例子}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:id1}}
\sphinxAtStartPar
​  这里使用VQNet的经典神经网络模块以及量子模块完成一个机器学习模型的整体流程的例子介绍。该例子参考 {[}Data re\sphinxhyphen{}uploading for a universal quantum classifier{]}(\sphinxurl{https://arxiv.org/abs/1907.02085}) 。 量子机器学习中的量子计算模块一般有如下几个部分：

\sphinxAtStartPar
​  （1）编码线路（Encoder），用于将经典数据编码到量子数据； （2）可变参数的量子线路（Ansatz），用于训练带参量子门中的参数； （3）测量模块(Measurement)，用于检测测量值（也就是某个量子比特的量子态在某些轴上的投影）。

\sphinxAtStartPar
​  量子计算模块与经典神经网络的运算模块一样是可微分的，是量子经典神经网络混合模型的理论基础。 VQNet支持将量子计算模块与经典计算模块（例如：卷积，池化，全连接层，激活函数等）一起构成混合机器学习模型，提供多种优化算法优化参数。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{vqnet}.png}\hspace*{\fill}}

\sphinxAtStartPar
​  在量子计算模块，VQNet支持使用本源量子高效的量子软件计算包 {[}pyQPanda{]}(\sphinxurl{https://pyqpanda-toturial.readthedocs.io/zh/latest/}) 进行量子模块构建。 使用pyQPanda提供的各种常用 {[}量子逻辑门函数接口{]}(\sphinxurl{https://pyqpanda-toturial.readthedocs.io/zh/latest/QGate.html}) ， {[}量子线路接口{]}(\sphinxurl{https://pyqpanda-toturial.readthedocs.io/zh/latest/QCircuit.html}) , {[}量子虚拟机函数接口{]}(\sphinxurl{https://pyqpanda-toturial.readthedocs.io/zh/latest/QuantumMachine.html}) ， {[}测量函数接口{]}(\sphinxurl{https://pyqpanda-toturial.readthedocs.io/zh/latest/Measure.html})，用户可以快速构建量子计算模块。

\sphinxAtStartPar
​  接下来的例子我们使用pyQPanda构建了一个量子计算模块。通过VQNet，该量子计算模块可以直接嵌入到混合机器学习模型中进行量子线路参数训练。 本例使用1个量子比特，使用了多个带参数的旋转门 RZ，RY，RZ 对输入x进行编码，并使用 prob\_run\_dict() 函数观测量子比特的概率测量结果作为输出。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{qdrl\PYGZus{}circuit}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,}\PYG{n}{weights}\PYG{p}{,}\PYG{n}{qlist}\PYG{p}{,}\PYG{n}{clist}\PYG{p}{,}\PYG{n}{machine}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{x1} \PYG{o}{=} \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{param1} \PYG{o}{=} \PYG{n}{weights}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口构建量子线路实例}
    \PYG{n}{circult} \PYG{o}{=} \PYG{n}{pq}\PYG{o}{.}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[0]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位x1[1]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[2]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[0]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位param1[1]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[2]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[0]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位x1[1]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[2]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[3]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位param1[4]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[5]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[0]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位x1[1]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位x1[2]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[6]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RY门，参数位param1[7]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}使用pyqpanda接口在第一个量子比特上插入逻辑门RZ门，参数位param1[8]}
    \PYG{n}{circult}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pq}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{param1}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}构建量子程序}
    \PYG{n}{prog} \PYG{o}{=} \PYG{n}{pq}\PYG{o}{.}\PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{circult}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}获取概率测量值}
    \PYG{n}{prob} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{prob\PYGZus{}run\PYGZus{}dict}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{,} \PYG{n}{qlist}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{prob} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{prob}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{prob}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  本例子中机器学习的任务是对随机生成的数据根据进行二分类，其中下图是该数据样例，零为圆点，半径为1以内红色的二维点为一类，蓝色的点为另一类。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=350\sphinxpxdimen]{{图附2.3.1}.png}\hspace*{\fill}}

\begin{center}图附2.3.1 数据样例
\end{center}
\sphinxAtStartPar
​  训练测试代码流程：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}导入必须的库和函数}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{qnn}\PYG{n+nn}{.}\PYG{n+nn}{qdrl}\PYG{n+nn}{.}\PYG{n+nn}{vqnet\PYGZus{}model} \PYG{k+kn}{import} \PYG{n}{qdrl\PYGZus{}circuit}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{qnn}\PYG{n+nn}{.}\PYG{n+nn}{quantumlayer} \PYG{k+kn}{import} \PYG{n}{QuantumLayer}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{optim} \PYG{k+kn}{import} \PYG{n}{adam}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{nn}\PYG{n+nn}{.}\PYG{n+nn}{loss} \PYG{k+kn}{import} \PYG{n}{CategoricalCrossEntropy}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{tensor} \PYG{k+kn}{import} \PYG{n}{QTensor}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{pyvqnet}\PYG{n+nn}{.}\PYG{n+nn}{nn}\PYG{n+nn}{.}\PYG{n+nn}{module} \PYG{k+kn}{import} \PYG{n}{Module}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  定义模型Model，其中 \_\_init\_\_ 函数定义内部各个神经网络模块以及量子模块，forward 函数定义前传函数。QuantumLayer 为封装量子计算的抽象类。 您只需将刚才定义的量子计算函数 qdrl\_circuit，待训练参数个数 param\_num ，运行后端配置 “cpu” , 量子比特数 qbit\_num 输入参数，该类就在 VQNet 中自动计算参数梯度。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}待训练参数个数}
\PYG{n}{param\PYGZus{}num} \PYG{o}{=} \PYG{l+m+mi}{9}
\PYG{c+c1}{\PYGZsh{}量子计算模块量子比特数}
\PYG{n}{qbit\PYGZus{}num}  \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{}定义一个继承于Module的机器学习模型类}
\PYG{k}{class} \PYG{n+nc}{Model}\PYG{p}{(}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{Model}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}使用QuantumLayer类，可以把带训练参数的量子线路纳入VQNet的自动微分的训练流程中}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pqc} \PYG{o}{=} \PYG{n}{QuantumLayer}\PYG{p}{(}\PYG{n}{qdrl\PYGZus{}circuit}\PYG{p}{,}\PYG{n}{param\PYGZus{}num}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cpu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{qbit\PYGZus{}num}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}定义模型前向函数}
    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pqc}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  定义一些训练模型需要的函数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 随机产生待训练数据的函数}
\PYG{k}{def} \PYG{n+nf}{circle}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{,}  \PYG{n}{rads} \PYG{o}{=}  \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{p}{:}
    \PYG{n}{data\PYGZus{}x}\PYG{p}{,} \PYG{n}{data\PYGZus{}y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
        \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{rads}\PYG{p}{:}
            \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{data\PYGZus{}x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data\PYGZus{}y}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 数据载入函数}
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}minibatch\PYGZus{}data}\PYG{p}{(}\PYG{n}{x\PYGZus{}data}\PYG{p}{,} \PYG{n}{label}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{x\PYGZus{}data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{batch\PYGZus{}size}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{idxs} \PYG{o}{=} \PYG{n+nb}{slice}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{n}{batch\PYGZus{}size}\PYG{p}{)}
        \PYG{k}{yield} \PYG{n}{x\PYGZus{}data}\PYG{p}{[}\PYG{n}{idxs}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{p}{[}\PYG{n}{idxs}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}计算准确率的函数}
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}score}\PYG{p}{(}\PYG{n}{pred}\PYG{p}{,} \PYG{n}{label}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pred}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pred}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{label}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{pred} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{pred}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{score} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{label}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{score} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{pred} \PYG{o}{==} \PYG{n}{score}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{score}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  VQNet遵循机器学习一般的训练测试流程: 迭代进行载入数据，前传计算，损失函数计算，反向计算，更新参数的操作。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}实例化定义的模型}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}定义一个优化器，这里用的是Adam}
\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{adam}\PYG{o}{.}\PYG{n}{Adam}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{lr} \PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}定义一个损失函数，这里用的交叉熵损失函数}
\PYG{n}{Closs} \PYG{o}{=} \PYG{n}{CategoricalCrossEntropy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  训练模型部分的函数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{train}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} 随机产生待训练数据}
    \PYG{n}{x\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train} \PYG{o}{=} \PYG{n}{circle}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}train} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}train}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}train}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 定义每个批次训练的数据个数}
    \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{32}
    \PYG{c+c1}{\PYGZsh{} 最大训练迭代次数}
    \PYG{n}{epoch} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{start training...........}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{epoch}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{model}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{accuracy} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{loss} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{data}\PYG{p}{,} \PYG{n}{label} \PYG{o+ow}{in} \PYG{n}{get\PYGZus{}minibatch\PYGZus{}data}\PYG{p}{(}\PYG{n}{x\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{,}\PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} 优化器中缓存梯度清零}
            \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{zero\PYGZus{}grad}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 模型前向计算}
            \PYG{n}{output} \PYG{o}{=} \PYG{n}{model}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 损失函数计算}
            \PYG{n}{losss} \PYG{o}{=} \PYG{n}{Closs}\PYG{p}{(}\PYG{n}{label}\PYG{p}{,} \PYG{n}{output}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 损失反向传播}
            \PYG{n}{losss}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 优化器参数更新}
            \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{\PYGZus{}step}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 计算准确率等指标}
            \PYG{n}{accuracy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{get\PYGZus{}score}\PYG{p}{(}\PYG{n}{output}\PYG{p}{,}\PYG{n}{label}\PYG{p}{)}

            \PYG{n}{loss} \PYG{o}{+}\PYG{o}{=} \PYG{n}{losss}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{batch\PYGZus{}size}

        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{epoch:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, train\PYGZus{}accuracy:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{accuracy}\PYG{o}{/}\PYG{n}{count}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{epoch:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, train\PYGZus{}loss:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{loss}\PYG{o}{/}\PYG{n}{count}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  验证模型部分的函数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{start eval...................}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{xtest}\PYG{p}{,} \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{circle}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
    \PYG{n}{test\PYGZus{}accuracy} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{x\PYGZus{}test} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xtest}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xtest}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{predicted\PYGZus{}test} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{test\PYGZus{}data}\PYG{p}{,} \PYG{n}{test\PYGZus{}label} \PYG{o+ow}{in} \PYG{n}{get\PYGZus{}minibatch\PYGZus{}data}\PYG{p}{(}\PYG{n}{x\PYGZus{}test}\PYG{p}{,}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{test\PYGZus{}data}\PYG{p}{,} \PYG{n}{test\PYGZus{}label} \PYG{o}{=} \PYG{n}{QTensor}\PYG{p}{(}\PYG{n}{test\PYGZus{}data}\PYG{p}{)}\PYG{p}{,}\PYG{n}{QTensor}\PYG{p}{(}\PYG{n}{test\PYGZus{}label}\PYG{p}{)}
        \PYG{n}{output} \PYG{o}{=} \PYG{n}{model}\PYG{p}{(}\PYG{n}{test\PYGZus{}data}\PYG{p}{)}
        \PYG{n}{test\PYGZus{}accuracy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{get\PYGZus{}score}\PYG{p}{(}\PYG{n}{output}\PYG{p}{,} \PYG{n}{test\PYGZus{}label}\PYG{p}{)}
        \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{batch\PYGZus{}size}

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}accuracy:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{test\PYGZus{}accuracy}\PYG{o}{/}\PYG{n}{count}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  训练测试结果图

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{start} \PYG{n}{training}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.6145833333333334}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.020432369535168013}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.6854166666666667}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.01872217481335004}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.8104166666666667}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.016634768371780715}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.7479166666666667}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.016975031544764835}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.7875}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.016502128106852372}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.8083333333333333}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.0163204787299037}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.8083333333333333}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.01634311651190122}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.016330583145221074}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.8125}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.01629052646458149}

\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{n}{train\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.8083333333333333}
\PYG{n}{epoch}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{n}{train\PYGZus{}loss}\PYG{p}{:}\PYG{l+m+mf}{0.016270687493185203}

\PYG{n}{start} \PYG{n+nb}{eval}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{test\PYGZus{}accuracy}\PYG{p}{:}\PYG{l+m+mf}{0.826}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{图附2.3.2}.png}\hspace*{\fill}}

\begin{center}图附2.3.2 训练测试结果图
\end{center}

\section{2.4 Qurator}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:qurator}}
\sphinxAtStartPar
  一种基于VS Code的量子程序开发工具。

\sphinxAtStartPar
   qurator\sphinxhyphen{}vscode 是本源量子推出的一款可以开发量子程序的 VS Code 插件。其支持 QRunes2 语言量子程序开发，并支持 Python 和 C++ 语言作为经典宿主语言。

\sphinxAtStartPar
  在 qurator\sphinxhyphen{}vscode 中，量子程序的开发主要分为编写和运行两个部分。

\sphinxAtStartPar
  ·编写程序：插件支持模块化编程，在不同的模块实现不同的功能，其中量子程序的编写主要在 qcodes 模块中；

\sphinxAtStartPar
  ·程序运行：即是收集结果的过程，插件支持图表化数据展示，将运行结果更加清晰的展现在您的面前。


\subsection{2.4.1 设计思想}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:id2}}
\sphinxAtStartPar
​  考虑到目前量子程序的开发离不开经典宿主语言的辅助，qurator\sphinxhyphen{}vscode 插件设计时考虑到一下几点：

\sphinxAtStartPar
    （1）模块编程：

\sphinxAtStartPar
​  qurator\sphinxhyphen{}vscode 插件支持模块编程，将整体程序分为三个模块：settings、qcodes 和 script 模块。在不同的模块完成不同的功能。 在 settings 模块中，您可以进行宿主语言类型、编译还是运行等设置；在 qcodes 模块中， 您可以编写 QRunes2 语言程序； 在 script 模块中，您可以编写相应的宿主语言程序。

\sphinxAtStartPar
    （2）切换简单：

\sphinxAtStartPar
  ​qurator\sphinxhyphen{}vscode 插件目前支持两种宿主语言，分别为 Python 和 C++。您可以在两种宿主语言之间自由的切换，您只需要在 settings 模块中设置 language 的 类型，就可以在 script 模块中编写对应宿主语言的代码。插件会自动识别您所选择的宿主语言，并在 script 模块中提供相应的辅助功能。

\sphinxAtStartPar
    （3）图形展示：

\sphinxAtStartPar
​  qurator\sphinxhyphen{}vscode 插件提供图形化的结果展示，程序运行后会展示 json 格式的运行结果，您可以点击运行结果，会生成相应的柱状图，方便您对运行结果的分析。


\subsection{2.4.2 准备工作}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:id3}}
\sphinxAtStartPar
​  使用 qurator\sphinxhyphen{}vscode 插件之前需要做一些准备工作，以确保量子程序能够正确的运行。

\sphinxAtStartPar
​  需要依赖的运行环境有：

\sphinxAtStartPar
​  ​  ​  ​·Python (版本 3.6.4 \sphinxhyphen{} 3.6.8)

\sphinxAtStartPar
​  ​  ​  ​·Pip (版本 10.1 及以上)

\sphinxAtStartPar
​  ​  ​  ·Microsoft Visual C++ Redistributable (Windows)

\sphinxAtStartPar
​  ​  ​  ·MinGw\sphinxhyphen{}w64 (Windows 64位版本)

\sphinxAtStartPar
​  其中，pip 负责下载宿主语言为 Python 时程序运行所依赖的包。Microsoft Visual C++ Redistributable 和 MinGw\sphinxhyphen{}w64 是宿主语言为 C++ 时程序运行所依赖的包。

\sphinxAtStartPar
​    （1）安装插件

\sphinxAtStartPar
​  首先需要您安装 {[}VS Code{]}(\sphinxurl{https://code.visualstudio.com/}) ，然后打开 VS Code 安装 qurator\sphinxhyphen{}vscode 插件： 使用 Ctrl + Shift + X 快捷键打开插件页面，或者您可以在最左侧栏找到 Extensions 点击进入，然后输入 qurator\sphinxhyphen{}vscode 来搜索插件，点击 Install 按钮进行插件的安装。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.1}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.1 插件安装
\end{center}
\sphinxAtStartPar
​  ​  ​（2）检测运行环境

\sphinxAtStartPar
​​  插件安装好之后，您可以创建以 .qrunes 结尾的文件，此时插件会自动检测是否存在程序运行所依赖的环境。您也可以自己检测程序运行环境，使用 Ctrl + Shift + P 快捷键打开 VS Code 命令行， 输入 qurator\sphinxhyphen{}vscode 时您可以看到 qurator\sphinxhyphen{}vscode: Check Qurator VSCode Extension dependencies 选择项，点击此项就可以进行运行环境的检测。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.2}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.2 运行环境检测
\end{center}
\sphinxAtStartPar
​​  检测到运行时所需环境，会在右下角展示软件及版本号：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.3}.jpg}\hspace*{\fill}}

\begin{center}图附2.3.3 软件及版本号
\end{center}

\subsection{2.4.3 快速入门}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:id4}}
\sphinxAtStartPar
​​  在做好准备工作之后，下面就可以编写属于您自己的量子程序了。

\sphinxAtStartPar
​​  ​​  （1）项目文件夹中启动 VS Code

\sphinxAtStartPar
​​​  在命令提示符或终端上，创建一个名为 “test” 的空文件夹，切换到该文件夹，然后输入命令 code . 在该文件夹中打开 VS Code：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{n}{mkdir} \PYG{n}{test}
\PYG{l+m+mf}{2.}\PYG{n}{cd} \PYG{n}{test}
\PYG{l+m+mf}{3.}\PYG{n}{code} \PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
​​​  或者，您可以点击运行 VS Code，然后点击 “File” > “Open File…” 打开项目文件夹。在文件夹中启动 VS Code，该文件夹将成为您的“工作区”。您可以在 .vscode/settings.json 文件中更改工作区的相关设置。

\sphinxAtStartPar
​​​  ​​​  （2）创建一个 qrunes 文件

\sphinxAtStartPar
​​​  在文件资源管理器工具栏中，单击 “test” 文件夹上的 “New File” 按钮，并命名该文件为 qurator\_test.qrunes。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.4}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.4 创建 qrunes 文件
\end{center}
\sphinxAtStartPar
​​​  ​​​  （3）编写量子程序

\sphinxAtStartPar
​​​  qrunes 文件创建完成之后，便可以编写量子程序了。整个量子程序分为三个部分：settings、qcodes 和 script 三个模块。

\sphinxAtStartPar
​​​  其中，settings 模块中可以设置宿主语言，编译还是运行；qcodes 模块中可以编写 QRunes2 量子语言代码； script 模块中可以编写宿主语言代码，目前支持 Python 和 C++ 两种宿主语言。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.5}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.5 编写量子程序
\end{center}
\sphinxAtStartPar
​​​  ​​​  （4）编译运行

\sphinxAtStartPar
​​​  点击右上方 Run this QRunes 运行程序，或者使用命令提示符 qurator\sphinxhyphen{}vscode: Run this QRunes 来运行程序(快捷键 F5)：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.6.1}.jpg}\hspace*{\fill}}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.6.2}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.6 编译运行
\end{center}
\sphinxAtStartPar
​​​  上述示例程序的运行结果如图附2.3.7：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.7}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.7 运行结果
\end{center}

\subsection{2.4.4 功能介绍}
\label{\detokenize{rst/_u9644_u5f552_u91cf_u5b50_u7f16_u7a0b_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u914d_u7f6e:id5}}
\sphinxAtStartPar
​​​
​​​  相信在快速入门步骤之后，您已大体了解插件的整体功能，下面将介绍您在编辑量子程序过程中插件提供的辅助功能：

\sphinxAtStartPar
​​​  ​​​  （1）自动补全

\sphinxAtStartPar
​​​  对于 QRunes2 语言内设的关键字可以智能提示，根据输入的字符列为您提供当前上下文中适用的最相关符号列表并提示其功能， 以便您可以更快地选择。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.8}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.8 自动补全
\end{center}
\sphinxAtStartPar
​​​​  ​​​  （2）验证提示

\sphinxAtStartPar
​​​​  对于输入进行验证并提示。每当插件检测到您编写的代码发生语法错误时，编辑器中会显示红色波浪线， 鼠标放上去可看到一系列错误信息，您可以准确定位错误发生的位置。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.9}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.9 验证提示
\end{center}
\sphinxAtStartPar
​​​​  ​​​​  （3）高亮展示

\sphinxAtStartPar
​​​​​​​  不同的模块有不同的颜色划分，您可以清晰地编写每一个模块的代码，一目了然，快速开发。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.10}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.10 高亮展示
\end{center}
\sphinxAtStartPar
​​​​  ​​​​  （4）悬浮提示

\sphinxAtStartPar
​​​​  QRunes2 语言中的方法、变量都有详细的解释及用法。每当您编写 QRunes2 语言内设关键字时， 将鼠标放在该关键字上，编辑器将会显示该关键字的功能信息。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.11}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.11 悬浮提示
\end{center}
\sphinxAtStartPar
​​​​  ​​​​  （5）智能片段

\sphinxAtStartPar
​​​​  智能片段功能是指用户输入简短的触发指令而生成完整的代码片段，在本插件中内置了自定义代码片段， 可帮助您整理一些重复性代码，提高开发效率。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.12}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.12 智能片段
\end{center}
\sphinxAtStartPar
​​​​  ​​​​  （6）语言切换

\sphinxAtStartPar
​​​​  目前 QRunes2 语言可以支持 Python 及 C++ 宿主语言，您可以在 settings 模块的 language 关键字来设置 所需支持的语言类型，就可以在script模块编写相应语言的代码。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.13}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.13 语言切换
\end{center}
\sphinxAtStartPar
​​​​  ​​​​  （7）编译运行

\sphinxAtStartPar
​​​​  运行 QRunes2 语言代码，编译器会根据设定的语言去编译该代码，从而实现不同的语言编写生成相同的结构。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附2.4.14}.jpg}\hspace*{\fill}}

\begin{center}图附2.4.14 编译运行
\end{center}
\sphinxstepscope

\sphinxAtStartPar
  ChemiQ是在量子计算机或虚拟机上模拟化学分子结构和性质的仿真软件——也是全球首款运用量子算法模拟的仿真软件——接入量子计算机计算速度呈指数增长。ChemiQ利用Jordan\sphinxhyphen{}Wigner，Parity等方法将二次量子化的Fermion的Hamiltonian算符转化（mapping）成Qubit的Hamiltonian算符（量子计算机识别的算符），算符间的转换是量子计算模拟化学过程的第一步，不同的转化方法对应着不同的Qubit信息，研究出所转化的算符少的mapping，相应的计算少，可大大简化计算；使用Unitary Coupled Cluster（简称UCC）等拟设构造模拟量子电路，分别代表不同的电路模型，所包含的参数数目和线路深度也不尽相同，构造出参数少、线路浅的线路拟设是量子计算模拟的关键，使得复杂的化学过程得到有效模拟；再结合量子相位评估（QPE），变分量子本征求解（VQE）算法，或量子虚时演化（QITE）算法模拟分子哈密顿量的期望值，进一步预测分子性质。这些算法不仅能保证量子态的相干性，其计算结果还能达到化学精度，在可预见的未来，有着极大的应用前景和优势。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.0}.png}\hspace*{\fill}}

\begin{center}图附3.1.1 ChemiQ软件
\end{center}

\section{3.1 ChemiQ化学软件的安装}
\label{\detokenize{rst/_u9644_u5f553_u91cf_u5b50_u5316_u5b66_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u4f7f_u7528:chemiq}}\label{\detokenize{rst/_u9644_u5f553_u91cf_u5b50_u5316_u5b66_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u4f7f_u7528::doc}}
\sphinxAtStartPar
  1、登录本源量子云官网图附3.1.1.png（\sphinxurl{https://qcloud.originqc.com.cn/}），选择“应用推广云”，如图附3.1.2 所示；选择“生物医药”方向，点击“了解详情”如图附3.1.3所示；点击“Windows进行下载”，如图附3.1.4所示。（直达页面：\sphinxurl{https://qcloud.originqc.com.cn/chemistryIntroduce}）

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.1}.png}\hspace*{\fill}}

\begin{center}图附3.1.2 选择“应用推广云”
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.2}.png}\hspace*{\fill}}

\begin{center}图附3.1.3 选择“生物医药”
\end{center}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.3}.png}\hspace*{\fill}}

\begin{center}图附3.1.4 下载
\end{center}
\sphinxAtStartPar
  2、下载完成后，双击安装该软件，点击“我同意”；

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.4}.png}\hspace*{\fill}}

\begin{center}图附3.1.5 点击“我同意”
\end{center}
\sphinxAtStartPar
  3、然后点击“下一步”；

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.5}.png}\hspace*{\fill}}

\begin{center}图附3.1.6 下一步
\end{center}
\sphinxAtStartPar
  4、再安装到默认目录，点击“安装”；

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.6}.png}\hspace*{\fill}}

\begin{center}图附3.1.7 点击“安装”
\end{center}
\sphinxAtStartPar
​  5、安装完成后，运行该软件。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.7}.png}\hspace*{\fill}}

\begin{center}图附3.1.8 安装完成
\end{center}

\section{3.2 ChemiQ软件应用示例}
\label{\detokenize{rst/_u9644_u5f553_u91cf_u5b50_u5316_u5b66_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u4f7f_u7528:id1}}
\sphinxAtStartPar
​  1、 新建项目。先新建一个项目名称——test H2，然后是填好创建人、计算模式、保存路径和项目描述，最后点击确定。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.8}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.1 新建项目
\end{center}
\sphinxAtStartPar
​  2、 主界面。该软件左侧显示的是项目下的任务列表；左下显示的是项目或者任务详情；右侧显示分为上下两部分，上部分为分子模型，下部分为结果展示，可上下拖动调节大小。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.9}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.2 主页面
\end{center}
\sphinxAtStartPar
​  3、 分子建模。以氢分子势能曲线为例，首先是构建分子模型。点击设置\sphinxhyphen{}分子模型，或者工具栏中图标构建分子模型。在这里可使用构建分子快捷工具，如右侧弹出框。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.10}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.3 分子建模
\end{center}
\sphinxAtStartPar
​  4、 配置参数。在参数配置框中选择计算类型——势能曲线，基组、电荷、自旋多重度可根据用户对应设置，在这里以STO\sphinxhyphen{}3G基组模拟氢分子PES；扫描坐标选择氢分子中键长距离为变量，设置对应的节点个数和扫描区间；映射、拟设和优化器对应选择如下图所示：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.11}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.4 配置参数
\end{center}
\sphinxAtStartPar
​  5、任务详情。左下部分显示任务的参数详情，如计算结果中展示的计算列表，其中往下拉会显示20个节点任务；此外为了便于显示，可点击视图中便捷工具，如图展示是分子模型中的元素名称和元素编号。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.12}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.5 任务详情
\end{center}
\sphinxAtStartPar
​  6、 计算完成。可以看到计算结果已经展示出来，同时也可以看到每个氢分子坐标计算得到能量如下：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.13}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.6 计算完成
\end{center}
\sphinxAtStartPar
​  7、 结果展示。势能曲线中可点击单个节点进入结果详情中，或者点击计算列表/势能曲线切换结果展示。

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.14}.bmp}\hspace*{\fill}}

\begin{center}图附3.2.7 结果展示
\end{center}

\section{3.3  ChemiQ接口介绍与使用}
\label{\detokenize{rst/_u9644_u5f553_u91cf_u5b50_u5316_u5b66_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u4f7f_u7528:id2}}
\sphinxAtStartPar
\sphinxstylestrong{使用封装的ChemiQ计算接口进行实现}

\sphinxAtStartPar
  表附3.3.1，列出的是ChemiQ封装的计算接口：

\begin{center}表附3.3.1
\end{center}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{接口名称}
&
\sphinxAtStartPar
\sphinxstylestrong{描述}
\\
\sphinxhline
\sphinxAtStartPar
initialize
&
\sphinxAtStartPar
初始化量子化学计算的环境
\\
\sphinxhline
\sphinxAtStartPar
finalize
&
\sphinxAtStartPar
释放量子化学计算的环境
\\
\sphinxhline
\sphinxAtStartPar
setMolecule
&
\sphinxAtStartPar
设置单个分子模型
\\
\sphinxhline
\sphinxAtStartPar
setMolecules
&
\sphinxAtStartPar
设置一组分子模型
\\
\sphinxhline
\sphinxAtStartPar
setMultiplicity
&
\sphinxAtStartPar
设置重数
\\
\sphinxhline
\sphinxAtStartPar
setCharge
&
\sphinxAtStartPar
设置电荷数
\\
\sphinxhline
\sphinxAtStartPar
setBasis
&
\sphinxAtStartPar
设置计算基
\\
\sphinxhline
\sphinxAtStartPar
setTransformType
&
\sphinxAtStartPar
设置费米子到泡利算子的转换类型
\\
\sphinxhline
\sphinxAtStartPar
setUccType
&
\sphinxAtStartPar
设置UCC模型类型
\\
\sphinxhline
\sphinxAtStartPar
setOptimizerType
&
\sphinxAtStartPar
设置优化器类型
\\
\sphinxhline
\sphinxAtStartPar
setOptimizerIterNum
&
\sphinxAtStartPar
设置优化器迭代次数
\\
\sphinxhline
\sphinxAtStartPar
setOptimizerFuncCallNum
&
\sphinxAtStartPar
设置优化器函数调用次数
\\
\sphinxhline
\sphinxAtStartPar
setOptimizerXatol
&
\sphinxAtStartPar
设置优化器参数收敛阈值
\\
\sphinxhline
\sphinxAtStartPar
setOptimizerFatol
&
\sphinxAtStartPar
设置优化器函数收敛阈值
\\
\sphinxhline
\sphinxAtStartPar
setLearningRate
&
\sphinxAtStartPar
设置学习率
\\
\sphinxhline
\sphinxAtStartPar
setEvolutionTime
&
\sphinxAtStartPar
设置演化时间
\\
\sphinxhline
\sphinxAtStartPar
setHamiltonianSimulationSlices
&
\sphinxAtStartPar
设置哈密顿量模拟切片数
\\
\sphinxhline
\sphinxAtStartPar
setSaveDataDir
&
\sphinxAtStartPar
设置中间数据存放目录
\\
\sphinxhline
\sphinxAtStartPar
setRandomPara
&
\sphinxAtStartPar
设置随机优化参数
\\
\sphinxhline
\sphinxAtStartPar
setDefaultOptimizedPara
&
\sphinxAtStartPar
设置默认优化参数
\\
\sphinxhline
\sphinxAtStartPar
setToGetHamiltonianFromFile
&
\sphinxAtStartPar
设置从文件获取体系哈密顿量
\\
\sphinxhline
\sphinxAtStartPar
setHamiltonianGenerationOnly
&
\sphinxAtStartPar
设置只生成体系哈密顿量
\\
\sphinxhline
\sphinxAtStartPar
exec
&
\sphinxAtStartPar
执行计算
\\
\sphinxhline
\sphinxAtStartPar
getLastError
&
\sphinxAtStartPar
获取最后一条错误日志
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
  initialize接口，作用是用来初始化量子化学计算环境，它需要传入一个变量就是量子化学计算包的路径，这里已经把PSi4安装在了python能检索到的环境路径下，使用时只需要传入空的字符串即可。  下面演示一下如何使用ChemiQ计算接口来实现氢分子的基态能量计算。

\sphinxAtStartPar
  首先构造一组不同距离下的氢分子模型；然后生成ChemiQ的一个实例，调用setMolecules接口设置一组氢分子模型，设置氢分子的电荷数为0，自旋多重度为1；使用的计算基是sto\sphinxhyphen{}3g；UCC模型我们使用的是UCCS，费米子哈密顿量到泡利哈密顿量的转换这里用的是JW变换；这里使用的优化器是Nelder\sphinxhyphen{}Mead，优化器迭代次数为200，函数调用次数为200，显示优化器计算的中间结果；最后执行计算。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{l+m+mf}{2.}
\PYG{l+m+mf}{3.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{n}{distances} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mf}{0.1} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mf}{8.}    \PYG{n}{molecule} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H 0 0 0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{H 0 0 }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{molecules} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{11.}    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{distances}\PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{n}{molecules}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{chemiq} \PYG{o}{=} \PYG{n}{ChemiQ}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{initialize}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{l+m+mf}{16.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setMolecules}\PYG{p}{(}\PYG{n}{molecules}\PYG{p}{)}
\PYG{l+m+mf}{17.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setCharge}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{l+m+mf}{18.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setMultiplicity}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{19.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setBasis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sto\PYGZhy{}3g}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{l+m+mf}{20.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setUccType}\PYG{p}{(}\PYG{n}{UccType}\PYG{o}{.}\PYG{n}{UCCS}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setTransformType}\PYG{p}{(}\PYG{n}{TransFormType}\PYG{o}{.}\PYG{n}{Jordan\PYGZus{}Wigner}\PYG{p}{)}
\PYG{l+m+mf}{22.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setOptimizerType}\PYG{p}{(}\PYG{n}{OptimizerType}\PYG{o}{.}\PYG{n}{NELDER\PYGZus{}MEAD}\PYG{p}{)}
\PYG{l+m+mf}{23.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setOptimizerIterNum}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{setOptimizerFatol}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{l+m+mf}{25.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{exec}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{26.}    \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{27.}
\PYG{l+m+mf}{28.}    \PYG{n}{value} \PYG{o}{=} \PYG{n}{chemiq}\PYG{o}{.}\PYG{n}{getEnergies}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{29.}
\PYG{l+m+mf}{30.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{distances} \PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{31.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{distance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{32.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{33.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VQE PLOT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{34.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  获取优化后的能量，绘制曲线图。这条曲线就是优化得到的氢分子在不同距离下对应的基态能量：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.16}.png}\hspace*{\fill}}

\begin{center}图附3.3.1 氢分子在不同距离下对应的基态能量
\end{center}

\section{3.4 非梯度下降法实现VQE算法代码示例}
\label{\detokenize{rst/_u9644_u5f553_u91cf_u5b50_u5316_u5b66_u5de5_u5177_u7684_u5b89_u88c5_u4e0e_u4f7f_u7528:vqe}}
\sphinxAtStartPar
​  首先，导入pyQPanda和psi4\_wrapper中的所有模块，以及一些其它组件模块准备。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k+kn}{from} \PYG{n+nn}{pyqpanda} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{2.}\PYG{k+kn}{from} \PYG{n+nn}{psi4\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{l+m+mf}{3.}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{l+m+mf}{4.}\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{partial}
\PYG{l+m+mf}{5.}\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{l+m+mf}{6.}\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  然后，定义非梯度下降优化器使用的损失函数为loss\_func，loss\_func接受的一组参数为待优化的参数列表，轨道个数，电子个数，体系哈密顿量。这个接口是先用ccsd模型构造的费米子哈密顿量，然后利用JW变换将费米子哈密顿量转换为泡利哈密顿量，再接着将CC转化成UCC，再计算体系哈密顿量在试验态下的期望，最后返回期望值来实现的。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{loss\PYGZus{}func}\PYG{p}{(}\PYG{n}{para\PYGZus{}list}\PYG{p}{,} \PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{Hamiltonian}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    \PYGZlt{}𝜓\PYGZca{}∗|𝐻|𝜓\PYGZgt{}, Calculation system expectation of Hamiltonian in experimental state.}
\PYG{l+s+s1}{4.    para\PYGZus{}list: parameters to be optimized}
\PYG{l+s+s1}{5.    qubit\PYGZus{}number: qubit number}
\PYG{l+s+s1}{6.    electron\PYGZus{}number: electron number}
\PYG{l+s+s1}{7.    Hamiltonian: System Hamiltonian}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{9.}    \PYG{n}{fermion\PYGZus{}cc} \PYG{o}{=}\PYG{n}{get\PYGZus{}ccsd}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{para\PYGZus{}list}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n}{pauli\PYGZus{}cc} \PYG{o}{=} \PYG{n}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{ucc} \PYG{o}{=} \PYG{n}{cc\PYGZus{}to\PYGZus{}ucc\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}cc}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{n}{component} \PYG{o+ow}{in} \PYG{n}{Hamiltonian}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{n}{expectation}\PYG{o}{+}\PYG{o}{=}\PYG{n}{get\PYGZus{}expectation}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}number}\PYG{p}{,} \PYG{n}{electron\PYGZus{}number}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{n}{component}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{expectation}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}
\PYG{l+m+mf}{16.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{expectation}\PYG{p}{)}
\PYG{l+m+mf}{17.}    \PYG{k}{return} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{expectation}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  下面将对loss\_func使用到的接口逐个进行讲解：

\sphinxAtStartPar
​  get\_ccsd\_n\_term接口的作用是返回构造CCSD模型需要用到的参数个数，这个接口接收的参数是轨道个数和电子个数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    coupled cluster single and double model.}
\PYG{l+s+s1}{4.    e.g. 4 qubits, 2 electrons}
\PYG{l+s+s1}{5.    then 0 and 1 are occupied,just consider 0\PYGZhy{}\PYGZgt{}2,0\PYGZhy{}\PYGZgt{}3,1\PYGZhy{}\PYGZgt{}2,1\PYGZhy{}\PYGZgt{}3,01\PYGZhy{}\PYGZgt{}23}
\PYG{l+s+s1}{6.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{\PYGZgt{}}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{k}{return} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}} \PYG{n}{en}\PYG{p}{)} \PYG{o}{*} \PYG{n}{en} \PYG{o}{+} \PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}} \PYG{n}{en}\PYG{p}{)}\PYG{o}{*} \PYG{p}{(}\PYG{n}{qn} \PYG{o}{\PYGZhy{}}\PYG{n}{en} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{en} \PYG{o}{*} \PYG{p}{(}\PYG{n}{en} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  get\_ccsd接口则是用来构造普通参数对应的CCSD模型费米子哈密顿量，该接口接收的参数是轨道个数、电子个数和单激发双激发前面对应的系数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ccsd}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{,} \PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    get Coupled cluster single and double model.}
\PYG{l+s+s1}{4.    e.g. 4 qubits, 2 electrons}
\PYG{l+s+s1}{5.    then 0 and 1 are occupied,just consider 0\PYGZhy{}\PYGZgt{}2,0\PYGZhy{}\PYGZgt{}3,1\PYGZhy{}\PYGZgt{}2,1\PYGZhy{}\PYGZgt{}3,01\PYGZhy{}\PYGZgt{}23.}
\PYG{l+s+s1}{6.    returned FermionOperator like this:}
\PYG{l+s+s1}{7.    }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{2+ 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[0]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[1]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{2+ 1}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[2]\PYGZcb{},}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 1}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[3]\PYGZcb{},}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{3+ 2+ 1 0}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:var[4]\PYGZcb{} \PYGZcb{}}
\PYG{l+s+s1}{9.}
\PYG{l+s+s1}{10.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{11.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{\PYGZgt{}}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{12.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{13.}    \PYG{k}{if} \PYG{n}{n\PYGZus{}electron}\PYG{o}{==}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{k}{return} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{k}{if} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{qn}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)} \PYG{o}{!=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{17.}        \PYG{k}{assert} \PYG{k+kc}{False}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}    \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{20.}    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{21.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{22.}        \PYG{k}{for} \PYG{n}{ex} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{,} \PYG{n}{qn}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{23.}            \PYG{n}{fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{24.}            \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{25.}
\PYG{l+m+mf}{26.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}electron}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{27.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n\PYGZus{}electron}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{k}{for} \PYG{n}{ex1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}electron}\PYG{p}{,}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{29.}                \PYG{k}{for} \PYG{n}{ex2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ex1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{30.}                    \PYG{n}{fermion\PYGZus{}op} \PYG{o}{+}\PYG{o}{=} \PYG{n}{FermionOperator}\PYG{p}{(}
\PYG{l+m+mf}{31.}                        \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex2}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{ex1}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{32.}                        \PYG{n}{para}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}
\PYG{l+m+mf}{33.}                    \PYG{p}{)}
\PYG{l+m+mf}{34.}                    \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}    \PYG{k}{return} \PYG{n}{fermion\PYGZus{}op}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  JordanWignerTransform接口的作用是将费米子哈密顿量转换成泡利哈密顿量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{data} \PYG{o}{=} \PYG{n}{fermion\PYGZus{}op}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{3.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{pauli} \PYG{o}{+}\PYG{o}{=} \PYG{n}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{6.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  get\_fermion\_jordan\_wigner接口则是将费米子哈密顿量的子项转换成泡利哈密顿量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}fermion\PYGZus{}jordan\PYGZus{}wigner}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}item}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{pauli} \PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fermion\PYGZus{}item}\PYG{p}{:}
\PYG{l+m+mf}{5.}        \PYG{n}{op\PYGZus{}qubit} \PYG{o}{=} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{6.}        \PYG{n}{op\PYGZus{}str} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{7.}        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}            \PYG{n}{op\PYGZus{}str} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}        \PYG{n}{op\PYGZus{}str1} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{11.}        \PYG{n}{op\PYGZus{}str2} \PYG{o}{=} \PYG{n}{op\PYGZus{}str} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{op\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{12.}
\PYG{l+m+mf}{13.}        \PYG{n}{pauli\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{14.}        \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}        \PYG{k}{if} \PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
\PYG{l+m+mf}{17.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{18.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{19.}            \PYG{n}{pauli\PYGZus{}map}\PYG{p}{[}\PYG{n}{op\PYGZus{}str2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{n}{j}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}        \PYG{n}{pauli} \PYG{o}{*}\PYG{o}{=} \PYG{n}{PauliOperator}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}map}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{k}{return} \PYG{n}{pauli}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  cc\_to\_ucc\_hamiltonian接口的作用是CC模型对应的哈密顿量转成UCC模型对应的哈密顿量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{cc\PYGZus{}to\PYGZus{}ucc\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{cc\PYGZus{}op}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    generate Hamiltonian form of unitary coupled cluster}
\PYG{l+s+s1}{4.    based on coupled cluster,H=1j*(T\PYGZhy{}dagger(T)),}
\PYG{l+s+s1}{5.    then exp(\PYGZhy{}iHt)=exp(T\PYGZhy{}dagger(T))}
\PYG{l+s+s1}{6.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{7.}    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{p}{(}\PYG{n}{cc\PYGZus{}op}\PYG{o}{\PYGZhy{}}\PYG{n}{cc\PYGZus{}op}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  get\_expectation接口，作用是计算体系哈密顿量在试验态下的期望，接收的参数是轨道个数，电子个数，UCC模型，体系哈密顿量的一个子项。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}expectation}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,}\PYG{n}{component}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    get expectation of one hamiltonian.}
\PYG{l+s+s1}{4.    n\PYGZus{}qubit: qubit number}
\PYG{l+s+s1}{5.    n\PYGZus{}en: electron number}
\PYG{l+s+s1}{6.    ucc: unitary coupled cluster operator}
\PYG{l+s+s1}{7.    component: paolioperator and coefficient,e.g. (}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X0 Y1 Z2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,0.2)}
\PYG{l+s+s1}{8.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{n}{machine}\PYG{o}{=}\PYG{n}{init\PYGZus{}quantum\PYGZus{}machine}\PYG{p}{(}\PYG{n}{QMachineType}\PYG{o}{.}\PYG{n}{CPU}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{q} \PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qAlloc\PYGZus{}many}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{prog}\PYG{o}{=}\PYG{n}{QProg}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{13.}
\PYG{l+m+mf}{14.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{prepareInitialState}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{15.}    \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{simulate\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{ucc}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}
\PYG{l+m+mf}{17.}    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{18.}        \PYG{k}{if} \PYG{n}{j}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{19.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{20.}        \PYG{k}{elif} \PYG{n}{j}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{21.}            \PYG{n}{prog}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{directly\PYGZus{}run}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{n}{result}\PYG{o}{=}\PYG{n}{machine}\PYG{o}{.}\PYG{n}{get\PYGZus{}prob\PYGZus{}dict}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{select\PYGZus{}max}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+m+mf}{25.}    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{qFree\PYGZus{}all}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\PYG{l+m+mf}{26.}
\PYG{l+m+mf}{27.}    \PYG{n}{expectation}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{28.}    \PYG{c+c1}{\PYGZsh{}奇负偶正}
\PYG{l+m+mf}{29.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{result}\PYG{p}{:}
\PYG{l+m+mf}{30.}        \PYG{k}{if} \PYG{n}{parity\PYGZus{}check}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{31.}            \PYG{n}{expectation}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{32.}        \PYG{k}{else}\PYG{p}{:}
\PYG{l+m+mf}{33.}            \PYG{n}{expectation}\PYG{o}{+}\PYG{o}{=}\PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{l+m+mf}{34.}    \PYG{k}{return} \PYG{n}{expectation}\PYG{o}{*}\PYG{n}{component}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  prepareInitialState接口的作用是制备初态，接收的参数是一组量子比特和电子个数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{prepareInitialState}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{,} \PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    prepare initial state.}
\PYG{l+s+s1}{4.    qlist: qubit list}
\PYG{l+s+s1}{5.    en: electron number}
\PYG{l+s+s1}{6.    return a QCircuit}
\PYG{l+s+s1}{7.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{8.}    \PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{en}\PYG{p}{:}
\PYG{l+m+mf}{10.}        \PYG{k}{return} \PYG{n}{circuit}
\PYG{l+m+mf}{11.}
\PYG{l+m+mf}{12.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{en}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{13.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{X}\PYG{p}{(}\PYG{n}{qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{14.}
\PYG{l+m+mf}{15.}    \PYG{k}{return} \PYG{n}{circuit}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  simulate\_hamiltonian接口，作用是构造哈密顿量的模拟线路，接收的参数是一组量子比特，泡利哈密顿量、演化时间演化次数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}hamiltonian}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,}\PYG{n}{pauli}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{slices}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a general case of hamiltonian by Trotter\PYGZhy{}Suzuki}
\PYG{l+s+s1}{4.    approximation. U=exp(\PYGZhy{}iHt)=(exp(\PYGZhy{}i H1 t/n)*exp(\PYGZhy{}i H2 t/n))\PYGZca{}n}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{circuit} \PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{slices}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{for} \PYG{n}{op} \PYG{o+ow}{in} \PYG{n}{pauli}\PYG{o}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{10.}            \PYG{n}{term} \PYG{o}{=} \PYG{n}{op}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{l+m+mf}{11.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}
\PYG{l+m+mf}{12.}                \PYG{n}{simulate\PYGZus{}one\PYGZus{}term}\PYG{p}{(}
\PYG{l+m+mf}{13.}                    \PYG{n}{qubit\PYGZus{}list}\PYG{p}{,}
\PYG{l+m+mf}{14.}                    \PYG{n}{term}\PYG{p}{,} \PYG{n}{op}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}
\PYG{l+m+mf}{15.}                    \PYG{n}{t}\PYG{o}{/}\PYG{n}{slices}
\PYG{l+m+mf}{16.}                \PYG{p}{)}
\PYG{l+m+mf}{17.}            \PYG{p}{)}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}    \PYG{k}{return} \PYG{n}{circuit}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  simulate\_one\_term是构造哈密顿量子项的模拟线路。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{simulate\PYGZus{}one\PYGZus{}term}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{,} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{,} \PYG{n}{coef}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    Simulate a single term of Hamilonian like }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{X0 Y1 Z2}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ with}
\PYG{l+s+s1}{4.    coefficient and time. U=exp(\PYGZhy{}it*coef*H)}
\PYG{l+s+s1}{5.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{6.}    \PYG{n}{circuit} \PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{p}{:}
\PYG{l+m+mf}{9.}        \PYG{k}{return} \PYG{n}{circuit}
\PYG{l+m+mf}{10.}
\PYG{l+m+mf}{11.}    \PYG{n}{transform}\PYG{o}{=}\PYG{n}{QCircuit}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{12.}    \PYG{n}{tmp\PYGZus{}qlist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{13.}    \PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{term} \PYG{o+ow}{in} \PYG{n}{hamiltonian\PYGZus{}term}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{14.}        \PYG{k}{if} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{15.}            \PYG{n}{transform}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{16.}        \PYG{k}{elif} \PYG{n}{term} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{17.}            \PYG{n}{transform}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{18.}
\PYG{l+m+mf}{19.}        \PYG{n}{tmp\PYGZus{}qlist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}list}\PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}    \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{transform}\PYG{p}{)}
\PYG{l+m+mf}{22.}
\PYG{l+m+mf}{23.}    \PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{)}
\PYG{l+m+mf}{24.}    \PYG{k}{if} \PYG{n}{size} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{25.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{26.}    \PYG{k}{elif} \PYG{n}{size} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{l+m+mf}{27.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{29.}        \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{coef}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{30.}        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{31.}            \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}qlist}\PYG{p}{[}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{32.}
\PYG{l+m+mf}{33.}    \PYG{n}{circuit}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{transform}\PYG{o}{.}\PYG{n}{dagger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{34.}
\PYG{l+m+mf}{35.}    \PYG{k}{return} \PYG{n}{circuit}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  paity\_check是对量子态中指定比特1的个数做奇偶校验。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{parity\PYGZus{}check}\PYG{p}{(}\PYG{n}{number}\PYG{p}{,} \PYG{n}{terms}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{3.    pairty check}
\PYG{l+s+s1}{4.    number: quantum state}
\PYG{l+s+s1}{5.    terms: a single term of PauliOperator, like}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{[(0, X), (1, Y)]}\PYG{l+s+s1}{\PYGZdq{}}
\PYG{l+s+s1}{6.    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+m+mf}{7.}    \PYG{n}{check}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{l+m+mf}{8.}    \PYG{n}{number}\PYG{o}{=}\PYG{n}{number}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{l+m+mf}{9.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{terms}\PYG{p}{:}
\PYG{l+m+mf}{10.}        \PYG{k}{if} \PYG{n}{number}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{l+m+mf}{11.}            \PYG{n}{check}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{l+m+mf}{12.}    \PYG{k}{return} \PYG{n}{check}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  optimize\_by\_no\_gradient是非梯度下降优化算法的主体接口，需要传入的一组参数是体系哈密顿量，轨道个数，电子个数，优化器迭代次数

\sphinxAtStartPar
​  接口的具体实现步骤是：首先初始化一组待优化的参数，然后构造一个非梯度下降优化器，这里构造的优化器是Nelder\sphinxhyphen{}Mead，设置优化器的迭代次数并向优化器注册计算期望的损失函数，然后执行优化器，最后返回优化器优化的最低期望值。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{optimize\PYGZus{}by\PYGZus{}no\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{mol\PYGZus{}pauli}\PYG{p}{,} \PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}en}\PYG{p}{,} \PYG{n}{iters}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{n\PYGZus{}para} \PYG{o}{=} \PYG{n}{get\PYGZus{}ccsd\PYGZus{}n\PYGZus{}term}\PYG{p}{(}\PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}electron}\PYG{p}{)}
\PYG{l+m+mf}{3.}
\PYG{l+m+mf}{4.}    \PYG{n}{para\PYGZus{}vec} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{5.}    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}para}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{6.}        \PYG{n}{para\PYGZus{}vec}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{l+m+mf}{7.}
\PYG{l+m+mf}{8.}    \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer} \PYG{o}{=} \PYG{n}{OptimizerFactory}\PYG{o}{.}\PYG{n}{makeOptimizer}\PYG{p}{(}\PYG{n}{OptimizerType}\PYG{o}{.}\PYG{n}{NELDER\PYGZus{}MEAD}\PYG{p}{)}
\PYG{l+m+mf}{9.}    \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{setMaxIter}\PYG{p}{(}\PYG{n}{iters}\PYG{p}{)}
\PYG{l+m+mf}{10.}    \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{setMaxFCalls}\PYG{p}{(}\PYG{n}{iters}\PYG{p}{)}
\PYG{l+m+mf}{11.}    \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{registerFunc}\PYG{p}{(}\PYG{n}{partial}\PYG{p}{(}
\PYG{l+m+mf}{12.}        \PYG{n}{loss\PYGZus{}func}\PYG{p}{,}
\PYG{l+m+mf}{13.}        \PYG{n}{qubit\PYGZus{}number} \PYG{o}{=} \PYG{n}{n\PYGZus{}qubit}\PYG{p}{,}
\PYG{l+m+mf}{14.}        \PYG{n}{electron\PYGZus{}number} \PYG{o}{=} \PYG{n}{n\PYGZus{}en}\PYG{p}{,}
\PYG{l+m+mf}{15.}        \PYG{n}{Hamiltonian}\PYG{o}{=}\PYG{n}{mol\PYGZus{}pauli}\PYG{o}{.}\PYG{n}{toHamiltonian}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mf}{16.}        \PYG{n}{para\PYGZus{}vec}\PYG{p}{)}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{exec}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{19.}    \PYG{n}{result} \PYG{o}{=} \PYG{n}{no\PYGZus{}gd\PYGZus{}optimizer}\PYG{o}{.}\PYG{n}{getResult}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{20.}    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{fun\PYGZus{}val}\PYG{p}{)}
\PYG{l+m+mf}{21.}
\PYG{l+m+mf}{22.}    \PYG{k}{return} \PYG{n}{result}\PYG{o}{.}\PYG{n}{fun\PYGZus{}val}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  etAtomElectronNum接口作用是返回原子对应的电子个数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{def} \PYG{n+nf}{getAtomElectronNum}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{atom\PYGZus{}electron\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{3.}        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{He}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Li}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Be}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ne}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}
\PYG{l+m+mf}{4.}        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Na}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Al}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Si}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{18}
\PYG{l+m+mf}{5.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{6.}
\PYG{l+m+mf}{7.}    \PYG{k}{if} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{atom\PYGZus{}electron\PYGZus{}map}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}contains\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{8.}        \PYG{k}{return} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{9.}
\PYG{l+m+mf}{10.}    \PYG{k}{return} \PYG{n}{atom\PYGZus{}electron\PYGZus{}map}\PYG{p}{[}\PYG{n}{atom}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  该算法演示示例对应的主函数，首先构造一组不同距离下的氢分子模型，然后计算每个氢分子模型对应的基态能量，最后将计算的结果绘制成曲线图。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
\PYG{l+m+mf}{2.}    \PYG{n}{distances} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mf}{0.1} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mf}{3.}    \PYG{n}{molecule} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H 0 0 0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{H 0 0 }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+m+mf}{4.}
\PYG{l+m+mf}{5.}    \PYG{n}{molecules} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{6.}    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{distances}\PYG{p}{:}
\PYG{l+m+mf}{7.}        \PYG{n}{molecules}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{8.}
\PYG{l+m+mf}{9.}    \PYG{n}{chemistry\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
\PYG{l+m+mf}{10.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mol}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mf}{11.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{multiplicity}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{l+m+mf}{12.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{l+m+mf}{13.}        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{basis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sto\PYGZhy{}3g}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mf}{14.}    \PYG{p}{\PYGZcb{}}
\PYG{l+m+mf}{15.}
\PYG{l+m+mf}{16.}    \PYG{n}{energies} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{l+m+mf}{17.}
\PYG{l+m+mf}{18.}    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{distances}\PYG{p}{:}
\PYG{l+m+mf}{19.}        \PYG{n}{mol} \PYG{o}{=} \PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{l+m+mf}{20.}
\PYG{l+m+mf}{21.}        \PYG{n}{chemistry\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mol}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{molecule}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{l+m+mf}{22.}        \PYG{n}{data} \PYG{o}{=} \PYG{n}{run\PYGZus{}psi4}\PYG{p}{(}\PYG{n}{chemistry\PYGZus{}dict}\PYG{p}{)}
\PYG{l+m+mf}{23.}        \PYG{c+c1}{\PYGZsh{}get molecule electron number}
\PYG{l+m+mf}{24.}        \PYG{n}{n\PYGZus{}electron} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{25.}        \PYG{n}{mol\PYGZus{}splits} \PYG{o}{=} \PYG{n}{mol}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{26.}        \PYG{n}{cnt} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{27.}        \PYG{k}{while} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mol\PYGZus{}splits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{l+m+mf}{28.}            \PYG{n}{n\PYGZus{}electron} \PYG{o}{+}\PYG{o}{=} \PYG{n}{getAtomElectronNum}\PYG{p}{(}\PYG{n}{mol\PYGZus{}splits}\PYG{p}{[}\PYG{n}{cnt}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{29.}            \PYG{n}{cnt} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{l+m+mf}{30.}
\PYG{l+m+mf}{31.}        \PYG{n}{fermion\PYGZus{}op} \PYG{o}{=} \PYG{n}{parsePsi4DataToFermion}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mf}{32.}        \PYG{n}{pauli\PYGZus{}op} \PYG{o}{=} \PYG{n}{JordanWignerTransform}\PYG{p}{(}\PYG{n}{fermion\PYGZus{}op}\PYG{p}{)}
\PYG{l+m+mf}{33.}
\PYG{l+m+mf}{34.}        \PYG{n}{n\PYGZus{}qubit} \PYG{o}{=} \PYG{n}{pauli\PYGZus{}op}\PYG{o}{.}\PYG{n}{getMaxIndex}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mf}{35.}
\PYG{l+m+mf}{36.}        \PYG{n}{energies}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{optimize\PYGZus{}by\PYGZus{}no\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}op}\PYG{p}{,} \PYG{n}{n\PYGZus{}qubit}\PYG{p}{,} \PYG{n}{n\PYGZus{}electron}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}
\PYG{l+m+mf}{37.}
\PYG{l+m+mf}{38.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{distances} \PYG{p}{,} \PYG{n}{energies}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{39.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{distance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{40.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{41.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VQE PLOT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mf}{42.}    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
​  该示例对应的输出结果如下，曲线图是氢分子在不同距离下对应的基态能量：

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{图附3.1.15}.png}\hspace*{\fill}}

\begin{center}图附3.3.2 氢分子在不同距离下对应的基态能量
\end{center}


\renewcommand{\indexname}{Index}
\printindex
\end{document}